import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';
import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:flutter/services.dart' show PlatformException, Clipboard, ClipboardData, MethodChannel, FilteringTextInputFormatter, SystemNavigator;
import 'package:flutter/foundation.dart' show kIsWeb, defaultTargetPlatform, ValueNotifier;
import 'package:flutter/foundation.dart' show TargetPlatform;
import 'package:firebase_core/firebase_core.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:excel/excel.dart' as excel_package;
import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';
import 'package:cross_file/cross_file.dart';
import 'package:image_picker/image_picker.dart' as image_picker;
import 'package:permission_handler/permission_handler.dart';
import 'package:flutter_native_ocr/flutter_native_ocr.dart';
import 'package:image/image.dart' as img;
import 'dart:typed_data';
import 'package:image_cropper/image_cropper.dart';
// NFC import
import 'package:flutter_nfc_reader/flutter_nfc_reader.dart';
// Egyptian ID Parser - Using egyptian_id_parser 1.1.0 for card detection
import 'package:egyptian_id_parser/egyptian_id_parser.dart';
import 'dart:io' show Platform;
import 'firebase_options.dart'; // Auto-generated by FlutterFire CLI
import 'services/firebase_service.dart';
import 'services/firebase_collections_setup.dart';
import 'services/admin_service.dart';
import 'services/admin_request_service.dart';
import 'services/role_service.dart';
import 'services/distribution_area_service.dart';
import 'services/queue_service.dart';
import 'services/unit_service.dart';
import 'services/beneficiary_service.dart';
import 'utils/firebase_init.dart';
import 'screens/setup_screen.dart';
import 'live_text_detection_screen.dart';
import 'google_lens_result_helper.dart';

// Language Manager
class AppLanguage {
  static String currentLanguage = 'English';
  static final ValueNotifier<String> languageNotifier = ValueNotifier<String>('English');
  
  static Map<String, Map<String, String>> translations = {
    'English': {
      // Common
      'Settings': 'Settings',
      'Profile': 'Profile',
      'Logout': 'Logout',
      'Dashboard': 'Dashboard',
      'Reports': 'Reports',
      'Admin Management': 'Q Admin Management',
      'Add Volunteer': 'Add Q Co-admin',
      'Preferences': 'Preferences',
      'Language': 'Language',
      'Enable Notifications': 'Enable Notifications',
      'Dark Mode': 'Dark Mode',
      'About': 'About',
      'App Version': 'App Version',
      'Terms & Conditions': 'Terms & Conditions',
      'Privacy Policy': 'Privacy Policy',
      'Select Language': 'Select Language',
      'English': 'English',
      'Arabic': 'Arabic',
      'EQMS Dashboard': 'EQMS Dashboard',
      'Total Queues': 'Total Queues',
      'Active Queues': 'Active Queues',
      'Total Beneficiaries': 'Total Beneficiaries',
      'Served Beneficiaries': 'Served Beneficiaries',
      'Statistics Overview': 'Statistics Overview',
      'Queue Details': 'Queue Details',
      'Status': 'Status',
      'units': 'units',
      'Add Queue': 'Add Queue',
      'Add Beneficiary': 'Add Beneficiary',
      'Beneficiaries': 'Beneficiaries',
      'No beneficiaries found': 'No beneficiaries found',
      'Search by name or ID': 'Search by name or ID',
      'NFC': 'NFC',
      'National ID': 'National ID',
      'Mobile': 'Mobile',
      'Scan NFC Card': 'Scan NFC Card',
      'NFC Detection': 'NFC Detection',
      'NFC is not available on this device': 'NFC is not available on this device',
      'Please enable NFC in your device settings if it is not already enabled, then bring the NFC card close to your device.': 'Please enable NFC in your device settings if it is not already enabled, then bring the NFC card close to your device.',
      'Waiting for NFC card...': 'Waiting for NFC card...',
      'NFC Disabled': 'NFC Disabled',
      'Please enable NFC in your device settings and try again.': 'Please enable NFC in your device settings and try again.',
      'NFC card detected': 'NFC card detected',
      'NFC card ID': 'NFC card ID',
      'NFC scanning is temporarily unavailable. Please enter NFC code manually.': 'NFC scanning is temporarily unavailable. Please enter NFC code manually.',
      'Tap NFC card or enter NFC code': 'Tap NFC card or enter NFC code',
      'NFC tag detected but no ID found. The tag may be empty or unformatted.': 'NFC tag detected but no ID found. The tag may be empty or unformatted.',
      'Enter mobile number': 'Enter mobile number',
      'Enter National ID or scan': 'Enter National ID or scan',
      'Camera permission is required to scan National ID. Please enable it in app settings.': 'Camera permission is required to scan National ID. Please enable it in app settings.',
      'Could not extract National ID from image. Please try again or enter manually.': 'Could not extract National ID from image. Please try again or enter manually.',
      'Scan National ID': 'Scan National ID',
      'Enter Mobile Number': 'Enter Mobile Number',
      'Scan NFC, Enter Mobile or National ID': 'Scan NFC, Enter Mobile or National ID',
      'Beneficiary not found': 'Beneficiary not found',
      'Serve Units': 'Serve Units',
      'Units to serve (max:': 'Units to serve (max:',
      'Add Area': 'Add Area',
      'Issue Queue Number': 'Issue Queue Number',
      'View Queue Status': 'View Queue Status',
      'Queue History': 'Queue History',
      'Login': 'Login',
      'Register': 'Register',
      'Cancel': 'Cancel',
      'Save': 'Save',
      'Delete': 'Delete',
      'Edit': 'Edit',
      'View': 'View',
      'Start': 'Start',
      'Suspend': 'Suspend',
      'Complete': 'Complete',
      'Resume': 'Resume',
      // Login & Auth
      'Sign In': 'Sign In',
      'Continue as Guest': 'Continue as Guest',
      'Mobile Number': 'Mobile Number',
      'Password': 'Password',
      'Enter mobile number': 'Enter mobile number',
      'Enter password': 'Enter password',
      'Please enter your mobile number': 'Please enter your mobile number',
      'Please enter your password': 'Please enter your password',
      'Enter your mobile number': 'Enter your mobile number',
      'Enter your password': 'Enter your password',
      'OR': 'OR',
      // Guest Mode
      'Guest Mode': 'Guest Mode',
      'Welcome Guest': 'Welcome Guest',
      'Register yourself as a beneficiary': 'Register yourself as a beneficiary',
      'Register as Beneficiary': 'Register as Beneficiary',
      'Live Text Detection (Google Lens-like)': 'Live Text Detection (Google Lens-like)',
      'Live Text Detection': 'Live Text Detection',
      'Waiting...': 'Waiting...',
      'Waiting for Google Lens result. Copy text from Google Lens and return to app.': 'Waiting for Google Lens result. Copy text from Google Lens and return to app.',
      'Data extracted from Google Lens and filled automatically': 'Data extracted from Google Lens and filled automatically',
      'Could not parse data from Google Lens. Please enter manually.': 'Could not parse data from Google Lens. Please enter manually.',
      'Request Admin Account': 'Request Admin Account',
      // Queue Management
      'Queue Name': 'Queue Name',
      'Queue Manager': 'Queue Manager',
      'Queue Type': 'Queue Type',
      'Single Day': 'Single Day',
      'Multi Day': 'Multi Day',
      'From Date': 'From Date',
      'To Date': 'To Date',
      'From Time': 'From Time',
      'To Time': 'To Time',
      'From Date & Time *': 'From Date & Time *',
      'To Date & Time *': 'To Date & Time *',
      'Select Date': 'Select Date',
      'Select Time': 'Select Time',
      'Unit Name': 'Unit Name',
      'Meals': 'Meals',
      'Bags': 'Bags',
      'Blankets': 'Blankets',
      'Others': 'Others',
      'Custom Unit Name': 'Custom Unit Name',
      'Number of Available Units': 'Number of Available Units',
      'Estimated Queue Size': 'Estimated Queue Size',
      'Direct Serve Option': 'Direct Serve Option',
      'Priority': 'Priority',
      'Female': 'Female',
      'Elderly': 'Elderly',
      'Disability': 'Disability',
      'Create Queue': 'Create Queue',
      'Update Queue': 'Update Queue',
      'Queue created successfully': 'Queue created successfully',
      'Queue updated successfully': 'Queue updated successfully',
      'Queue started successfully': 'Queue started successfully',
      'Queue suspended successfully': 'Queue suspended successfully',
      'Queue resumed successfully': 'Queue resumed successfully',
      'Queue completed successfully': 'Queue completed successfully',
      // Beneficiary
      'Beneficiary Registration': 'Beneficiary Registration',
      'Self Registration': 'Self Registration',
      'Initial Assigned Queue Point': 'Initial Assigned Queue Point',
      'Type': 'Type',
      'Normal': 'Normal',
      'Child': 'Child',
      'Widowed': 'Widowed',
      'Divorced': 'Divorced',
      'Sick': 'Sick',
      'ID Copy': 'ID Copy',
      'Scan ID': 'Scan ID',
      'Capture ID': 'Capture ID',
      'Upload ID': 'Upload ID',
      'ID Copy saved successfully': 'ID Copy saved successfully',
      'Remove ID Copy': 'Remove ID Copy',
      'Gender': 'Gender',
      'Male': 'Male',
      'Female': 'Female',
      'Name': 'Name',
      'ID Number': 'ID Number',
      'Mobile Number': 'Mobile Number',
      'Entity': 'Entity',
      'Number of Units': 'Number of Units',
      'NFC Preprinted Code': 'NFC Preprinted Code',
      'Photo': 'Photo',
      'Photo (Optional)': 'Photo (Optional)',
      'Take Photo': 'Take Photo',
      'Select Photo': 'Select Photo',
      'Take ID Copy': 'Take ID Copy',
      'Retake ID Copy': 'Retake ID Copy',
      'Register': 'Register',
      'Update': 'Update',
      'Beneficiary registered successfully': 'Beneficiary registered successfully',
      'Beneficiary updated successfully': 'Beneficiary updated successfully',
      // Queue Point
      'Add Distribution Area': 'Add Queue Point',
      'Distribution Area Name': 'Queue Point Name',
      'Enter distribution area name': 'Enter queue point name',
      'Create Area': 'Create Queue Point',
      'Area created successfully': 'Queue point created successfully',
      // Common Messages
      'Please select a distribution area': 'Please select a queue point',
      'Please select an initial assigned queue point': 'Please select an initial assigned queue point',
      'Please enter entity name': 'Please enter entity name',
      'Please select an entity': 'Please select an entity',
      'Please enter number of units': 'Please enter number of units',
      'ID scanned successfully': 'ID scanned successfully',
      'Name extracted from ID': 'Name extracted from ID',
      'Please scan ID first': 'Please scan ID first',
      'This ID is already registered': 'This ID is already registered',
      'Are you sure you want to delete this queue?': 'Are you sure you want to delete this queue?',
      'Yes': 'Yes',
      'No': 'No',
      'Queue deleted successfully': 'Queue deleted successfully',
      'Are you sure you want to logout?': 'Are you sure you want to logout?',
      'Receive push notifications': 'Receive push notifications',
      'Switch to dark theme': 'Switch to dark theme',
      'Select': 'Select',
      'Select previous field first': 'Select previous field first',
      'Enter full name': 'Enter full name',
      'Enter mobile number': 'Enter mobile number',
      'Enter email (optional)': 'Enter email (optional)',
      'Enter notes (optional)': 'Enter notes (optional)',
      'Enter notes': 'Enter notes',
      'Enter reference': 'Enter reference',
      'Volunteer added successfully': 'Volunteer added successfully',
      'Full Name': 'Full Name',
      'Email': 'Email',
      'Notes': 'Notes',
      'Reference (Optional)': 'Reference (Optional)',
      'Country': 'Country',
      'Governorate': 'Governorate',
      'City': 'City',
      'Distribution Point': 'Distribution Point',
      'Distribution Area': 'Distribution Area',
      'Other': 'Other',
      'Enter custom entity name': 'Enter custom entity name',
      'Select entity': 'Select entity',
      'App Statistics': 'App Statistics',
      'Our Queue List': 'Today List',
      'Remember Me': 'Remember Me',
      'Queue Point': 'Queue Point',
      'Date Range': 'Date Range',
      'Time Range': 'Time Range',
      'Available Units': 'Available Units',
      'Estimated Size': 'Estimated Size',
      'Serving Options': 'Serving Options',
      'Grace 5': 'Grace 5',
      'Grace 10': 'Grace 10',
      'No Order for serving': 'No Order for serving',
      'Serving without tickets': 'Serving without tickets',
      'Eligible for': 'Eligible for',
      'meals': 'meals',
      'Already taken': 'Already taken',
      'Mark as Served': 'Mark as Served',
      'Total Attendees': 'Total Attendees',
      'Current Queue Number': 'Current Queue Number',
      'Ticket Number': 'Ticket Number',
      'Verify Beneficiary': 'Verify Beneficiary',
      'Search by': 'Search by',
      'Enter ID number': 'Enter ID number',
      'Enter mobile number': 'Enter mobile number',
      'Scan NFC': 'Scan NFC',
      'Verify': 'Verify',
      'Send OTP': 'Send OTP',
      'Verified': 'Verified',
      'Enter OTP': 'Enter OTP',
      'Mobile number verified': 'Mobile number verified',
      'Please verify mobile number with OTP first': 'Please verify mobile number with OTP first',
      'Please enter a valid Egyptian mobile number': 'Please enter a valid Egyptian mobile number',
      'OTP sent to': 'OTP sent to',
      'OTP verified successfully': 'OTP verified successfully',
      'Invalid OTP. Please try again': 'Invalid OTP. Please try again',
      'OTP Verification': 'OTP Verification',
      'Your OTP code is': 'Your OTP code is',
      'Fill OTP': 'Fill OTP',
      'Please enter mobile number first': 'Please enter mobile number first',
      'Please enter mobile number': 'Please enter mobile number',
      'Invalid Egyptian mobile number': 'Invalid Egyptian mobile number',
      'Tap "Fill OTP" to automatically fill and verify': 'Tap "Fill OTP" to automatically fill and verify',
      'Admin request submitted successfully. Waiting for approval.': 'Admin request submitted successfully. Waiting for approval.',
      'Registration successful! You can now login to access your queue number.': 'Registration successful! You can now login to access your queue number.',
      'Required': 'Required',
      'Invalid Egyptian mobile number': 'Invalid Egyptian mobile number',
      'Please select governorate and city': 'Please select governorate and city',
      'Please select or create a queue point': 'Please select or create a queue point',
      'Please enter queue point name': 'Please enter queue point name',
      'Please select date and time ranges': 'Please select date and time ranges',
      'Please enter unit name': 'Please enter unit name',
      'Queue Point Name': 'Queue Point Name',
      'Queue Point Description': 'Queue Point Description',
      'Q Point (Distribution Point)': 'Q Point (Distribution Point)',
      'Create Admin': 'Create Admin',
      'Admin Requests': 'Admin Requests',
      'Approve': 'Approve',
      'Reject': 'Reject',
      'Request Admin Account': 'Request Admin Account',
      'Fill in your information to request admin access': 'Fill in your information to request admin access',
      'Admin request approved': 'Admin request approved',
      'Admin request rejected': 'Admin request rejected',
      'Admin created successfully': 'Admin created successfully',
      'Unknown screen': 'Unknown screen',
      'Q Admin User': 'Q Admin User',
      'No queues yet. Add a new queue to get started.': 'No queues yet. Add a new queue to get started.',
      'Distribution Area': 'Queue Point',
      'Select Distribution Area': 'Select Queue Point',
      'All Areas': 'All Queue Points',
      'No queues found for selected area.': 'No queues found for selected area.',
      'Delete Queue': 'Delete Queue',
      'Enter name or extract from ID': 'Enter name or extract from ID',
      'Enter ID number': 'Enter ID number',
      'Enter custom number of units': 'Enter custom number of units',
      'Custom': 'Custom',
      'Enter queue name': 'Enter queue name',
      'Please enter queue name': 'Please enter queue name',
      'Allow serving without requiring a ticket number': 'Allow serving without requiring a ticket number',
      'Custom Unit Name *': 'Custom Unit Name *',
      'First-Time Setup': 'First-Time Setup',
      'Initializing app features for the first time.\nThis may take 30-40 seconds.': 'Initializing app features for the first time.\nThis may take 30-40 seconds.',
      'Preparing app features...': 'Preparing app features...',
      'Setting up database structure...': 'Setting up database structure...',
      'Finalizing setup...': 'Finalizing setup...',
      'Setup complete!': 'Setup complete!',
      'Please enter name': 'Please enter name',
      'Please enter ID number': 'Please enter ID number',
      'Extract name from ID using OCR': 'Extract name from ID using OCR',
      'Queue not found in Firestore': 'Queue not found in Firestore',
      'Error updating queue:': 'Error updating queue:',
      'Beneficiary found': 'Beneficiary found',
      'No areas available': 'No areas available',
      'Serving:': 'Serving:',
      'Served': 'Served',
      'Attendees': 'Attendees',
      'Available': 'Available',
      'Est. Q Size': 'Est. Q Size',
      'No beneficiaries assigned': 'No beneficiaries assigned',
      'Initializing Firebase connection...': 'Initializing Firebase connection...',
      'Connecting to Firebase servers...': 'Connecting to Firebase servers...',
      'Setting up Firebase services...': 'Setting up Firebase services...',
      'Select Photo Source': 'Select Photo Source',
      'Select ID Copy Source': 'Select ID Copy Source',
      'ID Copy captured successfully': 'ID Copy captured successfully',
      'ID Copy selected successfully': 'ID Copy selected successfully',
      'Camera': 'Camera',
      'Gallery': 'Gallery',
      'Register Beneficiary': 'Register Beneficiary',
      'Current Password': 'Current Password',
      'New Password': 'New Password',
      'Confirm New Password': 'Confirm New Password',
      'Please fill all fields': 'Please fill all fields',
      'New passwords do not match': 'New passwords do not match',
      'User not found': 'User not found',
      'Current password is incorrect': 'Current password is incorrect',
      'Password changed successfully': 'Password changed successfully',
      'Error changing password:': 'Error changing password:',
      'Help & Support': 'Help & Support',
      'ID Scanned': 'ID Scanned',
      'Enter NFC code': 'Enter NFC code',
      'Error loading areas:': 'Error loading areas:',
      'EQMS Dashboard': 'EQMS Dashboard',
      'Reject Request': 'Reject Request',
      'active': 'Active',
      'suspended': 'Suspended',
      'completed': 'Completed',
      'inactive': 'Inactive',
      'Photo taken successfully': 'Photo taken successfully',
      'Photo selected successfully': 'Photo selected successfully',
      'Permission Required': 'Permission Required',
      'Open Settings': 'Open Settings',
      'Camera permission is required. Please enable it in app settings.': 'Camera permission is required. Please enable it in app settings.',
      'Storage permission is required. Please enable it in app settings.': 'Storage permission is required. Please enable it in app settings.',
      'Error completing queue:': 'Error completing queue:',
      'Disability': 'Disability',
      'Welcome to EQMS': 'Welcome to EQMS',
      'This guide will help you understand and use all features of the Electronic Queue Management System.': 'This guide will help you understand and use all features of the Electronic Queue Management System.',
      'Table of Contents': 'Table of Contents',
      '1. Dashboard Overview': '1. Dashboard Overview',
      '2. Creating Queues': '2. Creating Queues',
      '3. Adding Beneficiaries': '3. Adding Beneficiaries',
      '4. Serving Units': '4. Serving Units',
      '5. Admin Management': '5. Admin Management',
      '6. Profile & Settings': '6. Profile & Settings',
      '7. Language Settings': '7. Language Settings',
      '8. Guest Mode': '8. Guest Mode',
      'Dashboard Overview': 'Dashboard Overview',
      'The Dashboard is your main control center.': 'The Dashboard is your main control center.',
      'Step 1: View statistics cards showing Total Queues, Active Queues, Total Beneficiaries, and Served Beneficiaries.': 'Step 1: View statistics cards showing Total Queues, Active Queues, Total Beneficiaries, and Served Beneficiaries.',
      'Step 2: Use the Distribution Area dropdown to filter queues by location.': 'Step 2: Use the Distribution Area dropdown to filter queues by location.',
      'Step 3: Browse all your queues in the list below.': 'Step 3: Browse all your queues in the list below.',
      'Step 4: Tap on any queue card to view details or manage it.': 'Step 4: Tap on any queue card to view details or manage it.',
      'Step 5: Use the action buttons (Edit, Start, Suspend, Complete, Delete) to manage queues.': 'Step 5: Use the action buttons (Edit, Start, Suspend, Complete, Delete) to manage queues.',
      'Navigation: Use the bottom navigation bar to switch between Dashboard, Add Queue, Add Beneficiary, Beneficiaries, and Distribution Areas.': 'Navigation: Use the bottom navigation bar to switch between Dashboard, Add Queue, Add Beneficiary, Beneficiaries, and Distribution Areas.',
      'Creating Queues': 'Creating Queues',
      'Queues help you organize and manage service distribution.': 'Queues help you organize and manage service distribution.',
      'Step 1: Navigate to "Add Queue" from the bottom navigation bar.': 'Step 1: Navigate to "Add Queue" from the bottom navigation bar.',
      'Step 2: Enter a Queue Name (required).': 'Step 2: Enter a Queue Name (required).',
      'Step 3: Select a Distribution Area from the dropdown (required).': 'Step 3: Select a Distribution Area from the dropdown (required).',
      'Step 4: Choose Queue Type: Single Day or Multi Day.': 'Step 4: Choose Queue Type: Single Day or Multi Day.',
      'Step 5: Set the date range using "From Date & Time" and "To Date & Time" buttons.': 'Step 5: Set the date range using "From Date & Time" and "To Date & Time" buttons.',
      'Step 6: Select Unit Name (Meals, Bags, Blankets, or Others). If "Others", enter a custom unit name.': 'Step 6: Select Unit Name (Meals, Bags, Blankets, or Others). If "Others", enter a custom unit name.',
      'Step 7: Enter Number of Available Units (required).': 'Step 7: Enter Number of Available Units (required).',
      'Step 8: Enter Estimated Queue Size (required).': 'Step 8: Enter Estimated Queue Size (required).',
      'Step 9: Optionally enable "Direct Serve Option" to allow serving without tickets.': 'Step 9: Optionally enable "Direct Serve Option" to allow serving without tickets.',
      'Step 10: Select Priority groups if needed (Female, Elderly, Disability).': 'Step 10: Select Priority groups if needed (Female, Elderly, Disability).',
      'Step 11: Tap "Create Queue" to save.': 'Step 11: Tap "Create Queue" to save.',
      'Adding Beneficiaries': 'Adding Beneficiaries',
      'Beneficiaries are the people who will receive services from your queues.': 'Beneficiaries are the people who will receive services from your queues.',
      'Step 1: Navigate to "Add Beneficiary" from the bottom navigation bar.': 'Step 1: Navigate to "Add Beneficiary" from the bottom navigation bar.',
      'Step 2: Select Distribution Area (required).': 'Step 2: Select Distribution Area (required).',
      'Step 3: Scan or upload ID Copy using the "Scan ID" button (required).': 'Step 3: Scan or upload ID Copy using the "Scan ID" button (required).',
      'Step 4: Select Beneficiary Type: Normal, Child, Widowed, Divorced, Sick, Disability, or Elderly.': 'Step 4: Select Beneficiary Type: Normal, Child, Widowed, Divorced, Sick, Disability, or Elderly.',
      'Step 5: Select Gender: Male or Female (required).': 'Step 5: Select Gender: Male or Female (required).',
      'Step 6: Enter Name (required). You can extract name from ID if ID is scanned.': 'Step 6: Enter Name (required). You can extract name from ID if ID is scanned.',
      'Step 7: Enter ID Number (required). The system will check for duplicates.': 'Step 7: Enter ID Number (required). The system will check for duplicates.',
      'Step 8: Enter Mobile Number (required).': 'Step 8: Enter Mobile Number (required).',
      'Step 9: If beneficiary is an Entity, toggle the switch and enter Entity Name.': 'Step 9: If beneficiary is an Entity, toggle the switch and enter Entity Name.',
      'Step 10: Enter Number of Units (required).': 'Step 10: Enter Number of Units (required).',
      'Step 11: Optionally enter NFC Preprinted Code if available.': 'Step 11: Optionally enter NFC Preprinted Code if available.',
      'Step 12: Optionally add a Photo by tapping "Take Photo" or "Select Photo".': 'Step 12: Optionally add a Photo by tapping "Take Photo" or "Select Photo".',
      'Step 13: Tap "Register Beneficiary" to save.': 'Step 13: Tap "Register Beneficiary" to save.',
      'Serving Units': 'Serving Units',
      'The Serving screen allows you to serve units to beneficiaries in a queue.': 'The Serving screen allows you to serve units to beneficiaries in a queue.',
      'Step 1: From Dashboard, tap on a queue card to open Queue Details.': 'Step 1: From Dashboard, tap on a queue card to open Queue Details.',
      'Step 2: Tap the "Start" button to activate the queue for serving.': 'Step 2: Tap the "Start" button to activate the queue for serving.',
      'Step 3: Tap "Serve" or navigate to the Serving screen.': 'Step 3: Tap "Serve" or navigate to the Serving screen.',
      'Step 4: Search for a beneficiary by:': 'Step 4: Search for a beneficiary by:',
      '  - Scanning NFC card': '  - Scanning NFC card',
      '  - Entering Mobile Number': '  - Entering Mobile Number',
      '  - Entering National ID': '  - Entering National ID',
      'Step 5: The system will automatically find and select the beneficiary.': 'Step 5: The system will automatically find and select the beneficiary.',
      'Step 6: Tap the "Serve" button on the beneficiary card.': 'Step 6: Tap the "Serve" button on the beneficiary card.',
      'Step 7: In the popup, the maximum units are selected by default. Use the minus button to decrease if needed.': 'Step 7: In the popup, the maximum units are selected by default. Use the minus button to decrease if needed.',
      'Step 8: Tap "Serve" to confirm and mark the beneficiary as served.': 'Step 8: Tap "Serve" to confirm and mark the beneficiary as served.',
      'Step 9: View statistics: Served count, Attendees, Available units, and Estimated Queue Size.': 'Step 9: View statistics: Served count, Attendees, Available units, and Estimated Queue Size.',
      'Serving Options: Access via Settings icon to enable Grace periods, No Order mode, or Without Tickets mode.': 'Serving Options: Access via Settings icon to enable Grace periods, No Order mode, or Without Tickets mode.',
      'Admin Management is available only for Super Admins.': 'Admin Management is available only for Super Admins.',
      'Step 1: Access Admin Management from the Dashboard menu (gear icon) or AppBar.': 'Step 1: Access Admin Management from the Dashboard menu (gear icon) or AppBar.',
      'Step 2: View three tabs: Create Admin, Admin Requests, and Admins List.': 'Step 2: View three tabs: Create Admin, Admin Requests, and Admins List.',
      'Creating Admin:': 'Creating Admin:',
      '  - Fill in admin details (Country, Governorate, City, Distribution Point)': '  - Fill in admin details (Country, Governorate, City, Distribution Point)',
      '  - Enter Full Name, Mobile Number, Password': '  - Enter Full Name, Mobile Number, Password',
      '  - Select Role: Super Admin, Q Admin, or Admin': '  - Select Role: Super Admin, Q Admin, or Admin',
      '  - Tap "Create Admin"': '  - Tap "Create Admin"',
      'Admin Requests:': 'Admin Requests:',
      '  - View pending admin account requests from guests': '  - View pending admin account requests from guests',
      '  - Review request details': '  - Review request details',
      '  - Approve or Reject requests': '  - Approve or Reject requests',
      'Admins List:': 'Admins List:',
      '  - View all created admins': '  - View all created admins',
      '  - Edit or manage admin accounts': '  - Edit or manage admin accounts',
      'Profile & Settings': 'Profile & Settings',
      'Access your profile and app settings.': 'Access your profile and app settings.',
      'Step 1: Tap the Profile icon in the AppBar or open the drawer menu.': 'Step 1: Tap the Profile icon in the AppBar or open the drawer menu.',
      'Step 2: View your profile information: Name, Role, and Mobile Number.': 'Step 2: View your profile information: Name, Role, and Mobile Number.',
      'Change Password:': 'Change Password:',
      'Step 1: Go to Profile screen.': 'Step 1: Go to Profile screen.',
      'Step 2: Tap on "Language" option.': 'Step 2: Tap on "Language" option.',
      'Step 3: Select your preferred language: English or Arabic.': 'Step 3: Select your preferred language: English or Arabic.',
      'Step 4: The app will immediately switch to the selected language.': 'Step 4: The app will immediately switch to the selected language.',
      'Features:': 'Features:',
      '  - All text, labels, and messages are translated': '  - All text, labels, and messages are translated',
      '  - Layout automatically switches to RTL (Right-to-Left) for Arabic': '  - Layout automatically switches to RTL (Right-to-Left) for Arabic',
      '  - Icons and arrows flip direction for Arabic': '  - Icons and arrows flip direction for Arabic',
      '  - All functionality remains the same in both languages': '  - All functionality remains the same in both languages',
      'Language Settings': 'Language Settings',
      'The app supports both English and Arabic languages.': 'The app supports both English and Arabic languages.',
      'Guest Mode allows visitors to register as beneficiaries without logging in.': 'Guest Mode allows visitors to register as beneficiaries without logging in.',
      'Step 1: From the Login screen, tap "Continue as Guest".': 'Step 1: From the Login screen, tap "Continue as Guest".',
      'Step 2: You will see the Guest Dashboard.': 'Step 2: You will see the Guest Dashboard.',
      'Step 3: Options available:': 'Step 3: Options available:',
      '  - Register as Beneficiary: Fill in your information to register': '  - Register as Beneficiary: Fill in your information to register',
      '  - Request Admin Account: Submit a request to become an admin': '  - Request Admin Account: Submit a request to become an admin',
      'Registering as Beneficiary:': 'Registering as Beneficiary:',
      '  - Follow the same steps as "Adding Beneficiaries"': '  - Follow the same steps as "Adding Beneficiaries"',
      '  - After registration, you can view your queue number': '  - After registration, you can view your queue number',
      'Requesting Admin Account:': 'Requesting Admin Account:',
      '  - Fill in your information': '  - Fill in your information',
      '  - Select Distribution Area': '  - Select Distribution Area',
      '  - Submit the request': '  - Submit the request',
      '  - Wait for Super Admin approval': '  - Wait for Super Admin approval',
      'Note: Guests have limited access and cannot manage queues or serve units.': 'Note: Guests have limited access and cannot manage queues or serve units.',
      'Tips & Best Practices': 'Tips & Best Practices',
      'Always scan beneficiary ID to ensure accurate data entry': 'Always scan beneficiary ID to ensure accurate data entry',
      'Use NFC cards for faster beneficiary lookup during serving': 'Use NFC cards for faster beneficiary lookup during serving',
      'Set appropriate queue sizes to avoid overbooking': 'Set appropriate queue sizes to avoid overbooking',
      'Regularly check queue status and update as needed': 'Regularly check queue status and update as needed',
      'Use priority settings to serve vulnerable groups first': 'Use priority settings to serve vulnerable groups first',
      'Keep beneficiary information up to date': 'Keep beneficiary information up to date',
      'Use the search feature to quickly find beneficiaries': 'Use the search feature to quickly find beneficiaries',
      'Review statistics regularly to track service delivery': 'Review statistics regularly to track service delivery',
      'Need More Help?': 'Need More Help?',
      'If you need additional assistance or encounter any issues, please contact your system administrator or support team.': 'If you need additional assistance or encounter any issues, please contact your system administrator or support team.',
    },
    'Arabic': {
      // Common
      'Settings': 'الإعدادات',
      'Profile': 'الملف الشخصي',
      'Logout': 'تسجيل الخروج',
      'Dashboard': 'لوحة التحكم',
      'Reports': 'التقارير',
      'Admin Management': 'إدارة مسؤولي الطابور',
      'Add Volunteer': 'إضافة مساعد مسؤول الطابور',
      'Preferences': 'التفضيلات',
      'Language': 'اللغة',
      'Enable Notifications': 'تفعيل الإشعارات',
      'Dark Mode': 'الوضع الداكن',
      'About': 'حول',
      'App Version': 'إصدار التطبيق',
      'Terms & Conditions': 'الشروط والأحكام',
      'Privacy Policy': 'سياسة الخصوصية',
      'Select Language': 'اختر اللغة',
      'English': 'الإنجليزية',
      'Arabic': 'العربية',
      'EQMS Dashboard': 'لوحة تحكم نظام إدارة الجودة الإلكتروني',
      'Total Queues': 'إجمالي الطوابير',
      'Active Queues': 'الطوابير النشطة',
      'Total Beneficiaries': 'إجمالي المستفيدين',
      'Served Beneficiaries': 'المستفيدون المخدومون',
      'Statistics Overview': 'نظرة عامة على الإحصائيات',
      'Queue Details': 'تفاصيل الطابور',
      'Status': 'الحالة',
      'units': 'وحدات',
      'Add Queue': 'إضافة طابور',
      'Add Beneficiary': 'إضافة مستفيد',
      'Beneficiaries': 'المستفيدون',
      'No beneficiaries found': 'لم يتم العثور على مستفيدين',
      'Search by name or ID': 'البحث بالاسم أو رقم الهوية',
      'NFC': 'NFC',
      'National ID': 'الهوية الوطنية',
      'Mobile': 'الجوال',
      'Scan NFC Card': 'مسح بطاقة NFC',
      'Scan National ID': 'مسح الهوية الوطنية',
      'Enter Mobile Number': 'أدخل رقم الجوال',
      'Scan NFC, Enter Mobile or National ID': 'امسح NFC، أدخل الجوال أو الهوية الوطنية',
      'NFC Detection': 'كشف NFC',
      'NFC is not available on this device': 'NFC غير متاح على هذا الجهاز',
      'Please enable NFC in your device settings if it is not already enabled, then bring the NFC card close to your device.': 'يرجى تفعيل NFC في إعدادات جهازك إذا لم يكن مفعلاً بالفعل، ثم قرب بطاقة NFC من جهازك.',
      'Waiting for NFC card...': 'في انتظار بطاقة NFC...',
      'NFC Disabled': 'NFC معطل',
      'Please enable NFC in your device settings and try again.': 'يرجى تفعيل NFC في إعدادات جهازك والمحاولة مرة أخرى.',
      'NFC card detected': 'تم اكتشاف بطاقة NFC',
      'NFC card ID': 'معرف بطاقة NFC',
      'NFC scanning is temporarily unavailable. Please enter NFC code manually.': 'مسح NFC غير متاح مؤقتاً. يرجى إدخال رمز NFC يدوياً.',
      'Tap NFC card or enter NFC code': 'اضغط على بطاقة NFC أو أدخل رمز NFC',
      'NFC tag detected but no ID found. The tag may be empty or unformatted.': 'تم اكتشاف بطاقة NFC ولكن لم يتم العثور على معرف. قد تكون البطاقة فارغة أو غير منسقة.',
      'Enter mobile number': 'أدخل رقم الجوال',
      'Enter National ID or scan': 'أدخل الهوية الوطنية أو امسحها',
      'Camera permission is required to scan National ID. Please enable it in app settings.': 'إذن الكاميرا مطلوب لمسح الهوية الوطنية. يرجى تفعيله في إعدادات التطبيق.',
      'Could not extract National ID from image. Please try again or enter manually.': 'تعذر استخراج الهوية الوطنية من الصورة. يرجى المحاولة مرة أخرى أو الإدخال يدوياً.',
      'Beneficiary not found': 'المستفيد غير موجود',
      'Serve Units': 'تقديم الوحدات',
      'Units to serve (max:': 'الوحدات المقدمة (الحد الأقصى:',
      'Add Area': 'إضافة منطقة',
      'Issue Queue Number': 'إصدار رقم الطابور',
      'View Queue Status': 'عرض حالة الطابور',
      'Queue History': 'سجل الطابور',
      'Login': 'تسجيل الدخول',
      'Register': 'تسجيل',
      'Cancel': 'إلغاء',
      'Save': 'حفظ',
      'Delete': 'حذف',
      'Edit': 'تعديل',
      'View': 'عرض',
      'Start': 'بدء',
      'Suspend': 'تعليق',
      'Complete': 'إكمال',
      'Resume': 'استئناف',
      // Login & Auth
      'Sign In': 'تسجيل الدخول',
      'Continue as Guest': 'المتابعة كضيف',
      'Mobile Number': 'رقم الجوال',
      'Password': 'كلمة المرور',
      'Enter mobile number': 'أدخل رقم الجوال',
      'Enter password': 'أدخل كلمة المرور',
      'Please enter your mobile number': 'يرجى إدخال رقم جوالك',
      'Please enter your password': 'يرجى إدخال كلمة المرور',
      'Enter your mobile number': 'أدخل رقم جوالك',
      'Enter your password': 'أدخل كلمة المرور',
      'OR': 'أو',
      // Guest Mode
      'Guest Mode': 'وضع الضيف',
      'Welcome Guest': 'مرحباً بالضيف',
      'Register yourself as a beneficiary': 'سجل نفسك كمستفيد',
      'Register as Beneficiary': 'التسجيل كمستفيد',
      'Live Text Detection (Google Lens-like)': 'اكتشاف النص المباشر (مثل Google Lens)',
      'Request Admin Account': 'طلب حساب مسؤول',
      // Queue Management
      'Queue Name': 'اسم الطابور',
      'Queue Manager': 'مدير الطابور',
      'Queue Type': 'نوع الطابور',
      'Single Day': 'يوم واحد',
      'Multi Day': 'أيام متعددة',
      'From Date': 'من تاريخ',
      'To Date': 'إلى تاريخ',
      'From Time': 'من وقت',
      'To Time': 'إلى وقت',
      'From Date & Time *': 'من التاريخ والوقت *',
      'To Date & Time *': 'إلى التاريخ والوقت *',
      'Select Date': 'اختر التاريخ',
      'Select Time': 'اختر الوقت',
      'Unit Name': 'اسم الوحدة',
      'Meals': 'وجبات',
      'Bags': 'أكياس',
      'Blankets': 'بطانيات',
      'Others': 'أخرى',
      'Custom Unit Name': 'اسم الوحدة المخصص',
      'Number of Available Units': 'عدد الوحدات المتاحة',
      'Estimated Queue Size': 'الحجم المقدر للطابور',
      'Direct Serve Option': 'خيار الخدمة المباشرة',
      'Priority': 'الأولوية',
      'Female': 'أنثى',
      'Elderly': 'مسن',
      'Disability': 'إعاقة',
      'Create Queue': 'إنشاء طابور',
      'Update Queue': 'تحديث الطابور',
      'Queue created successfully': 'تم إنشاء الطابور بنجاح',
      'Queue updated successfully': 'تم تحديث الطابور بنجاح',
      'Queue started successfully': 'تم بدء الطابور بنجاح',
      'Queue suspended successfully': 'تم تعليق الطابور بنجاح',
      'Queue resumed successfully': 'تم استئناف الطابور بنجاح',
      'Queue completed successfully': 'تم إكمال الطابور بنجاح',
      // Beneficiary
      'Beneficiary Registration': 'تسجيل المستفيد',
      'Self Registration': 'التسجيل الذاتي',
      'Initial Assigned Queue Point': 'نقطة الطابور المخصصة الأولية',
      'Type': 'النوع',
      'Normal': 'عادي',
      'Child': 'طفل',
      'Widowed': 'أرمل',
      'Divorced': 'مطلق',
      'Sick': 'مريض',
      'ID Copy': 'نسخة الهوية',
      'Scan ID': 'مسح الهوية',
      'Capture ID': 'التقاط الهوية',
      'Upload ID': 'رفع الهوية',
      'ID Copy saved successfully': 'تم حفظ نسخة الهوية بنجاح',
      'Remove ID Copy': 'إزالة نسخة الهوية',
      'Gender': 'الجنس',
      'Male': 'ذكر',
      'Female': 'أنثى',
      'Name': 'الاسم',
      'ID Number': 'رقم الهوية',
      'Mobile Number': 'رقم الجوال',
      'Entity': 'الكيان',
      'Number of Units': 'عدد الوحدات',
      'NFC Preprinted Code': 'رمز NFC المطبوع مسبقاً',
      'Photo': 'الصورة',
      'Photo (Optional)': 'الصورة (اختياري)',
      'Take Photo': 'التقاط صورة',
      'Select Photo': 'اختر صورة',
      'Take ID Copy': 'التقاط نسخة الهوية',
      'Retake ID Copy': 'إعادة التقاط نسخة الهوية',
      'Register': 'تسجيل',
      'Update': 'تحديث',
      'Beneficiary registered successfully': 'تم تسجيل المستفيد بنجاح',
      'Beneficiary updated successfully': 'تم تحديث المستفيد بنجاح',
      // Queue Point
      'Add Distribution Area': 'إضافة نقطة طابور',
      'Distribution Area Name': 'اسم نقطة الطابور',
      'Enter distribution area name': 'أدخل اسم نقطة الطابور',
      'Create Area': 'إنشاء نقطة طابور',
      'Area created successfully': 'تم إنشاء نقطة الطابور بنجاح',
      // Common Messages
      'Please select a distribution area': 'يرجى اختيار نقطة طابور',
      'Please select an initial assigned queue point': 'يرجى اختيار نقطة طابور مخصصة أولية',
      'Please enter entity name': 'يرجى إدخال اسم الكيان',
      'Please select an entity': 'يرجى اختيار كيان',
      'Please enter number of units': 'يرجى إدخال عدد الوحدات',
      'ID scanned successfully': 'تم مسح الهوية بنجاح',
      'Name extracted from ID': 'تم استخراج الاسم من الهوية',
      'Please scan ID first': 'يرجى مسح الهوية أولاً',
      'This ID is already registered': 'هذه الهوية مسجلة بالفعل',
      'Are you sure you want to delete this queue?': 'هل أنت متأكد من حذف هذا الطابور؟',
      'Yes': 'نعم',
      'No': 'لا',
      'Queue deleted successfully': 'تم حذف الطابور بنجاح',
      'Are you sure you want to logout?': 'هل أنت متأكد من تسجيل الخروج؟',
      'Receive push notifications': 'تلقي الإشعارات',
      'Switch to dark theme': 'التبديل إلى الوضع الداكن',
      'Select': 'اختر',
      'Select previous field first': 'اختر الحقل السابق أولاً',
      'Enter full name': 'أدخل الاسم الكامل',
      'Enter mobile number': 'أدخل رقم الجوال',
      'Enter email (optional)': 'أدخل البريد الإلكتروني (اختياري)',
      'Enter notes (optional)': 'أدخل الملاحظات (اختياري)',
      'Enter notes': 'أدخل الملاحظات',
      'Enter reference': 'أدخل المرجع',
      'Volunteer added successfully': 'تم إضافة المتطوع بنجاح',
      'Full Name': 'الاسم الكامل',
      'Email': 'البريد الإلكتروني',
      'Notes': 'الملاحظات',
      'Reference (Optional)': 'المرجع (اختياري)',
      'Country': 'الدولة',
      'Governorate': 'المحافظة',
      'City': 'المدينة',
      'Distribution Point': 'نقطة التوزيع',
      'Distribution Area': 'منطقة التوزيع',
      'Other': 'أخرى',
      'Enter custom entity name': 'أدخل اسم الكيان المخصص',
      'Select entity': 'اختر الكيان',
      'App Statistics': 'إحصائيات التطبيق',
      'Our Queue List': 'قائمة اليوم',
      'Remember Me': 'تذكرني',
      'Queue Point': 'نقطة الطابور',
      'Date Range': 'نطاق التاريخ',
      'Time Range': 'نطاق الوقت',
      'Available Units': 'الوحدات المتاحة',
      'Estimated Size': 'الحجم المقدر',
      'Serving Options': 'خيارات الخدمة',
      'Grace 5': 'تساهل 5',
      'Grace 10': 'تساهل 10',
      'No Order for serving': 'لا يوجد ترتيب للخدمة',
      'Serving without tickets': 'الخدمة بدون تذاكر',
      'Eligible for': 'مؤهل لـ',
      'meals': 'وجبات',
      'Already taken': 'تم أخذه بالفعل',
      'Mark as Served': 'وضع علامة كمخدوم',
      'Total Attendees': 'إجمالي الحضور',
      'Current Queue Number': 'رقم الطابور الحالي',
      'Ticket Number': 'رقم التذكرة',
      'Verify Beneficiary': 'التحقق من المستفيد',
      'Search by': 'البحث عن طريق',
      'Enter ID number': 'أدخل رقم الهوية',
      'Enter mobile number': 'أدخل رقم الجوال',
      'Scan NFC': 'مسح NFC',
      'Verify': 'التحقق',
      'Send OTP': 'إرسال رمز التحقق',
      'Verified': 'تم التحقق',
      'Enter OTP': 'أدخل رمز التحقق',
      'Mobile number verified': 'تم التحقق من رقم الجوال',
      'Please verify mobile number with OTP first': 'يرجى التحقق من رقم الجوال برمز التحقق أولاً',
      'Please enter a valid Egyptian mobile number': 'يرجى إدخال رقم جوال مصري صحيح',
      'OTP sent to': 'تم إرسال رمز التحقق إلى',
      'OTP verified successfully': 'تم التحقق من رمز التحقق بنجاح',
      'Invalid OTP. Please try again': 'رمز تحقق غير صحيح. يرجى المحاولة مرة أخرى',
      'OTP Verification': 'التحقق من رمز OTP',
      'Your OTP code is': 'رمز التحقق الخاص بك هو',
      'Fill OTP': 'ملء رمز التحقق',
      'Please enter mobile number first': 'يرجى إدخال رقم الجوال أولاً',
      'Please enter mobile number': 'يرجى إدخال رقم الجوال',
      'Tap "Fill OTP" to automatically fill and verify': 'اضغط على "ملء رمز التحقق" لملء والتحقق تلقائياً',
      'Admin request submitted successfully. Waiting for approval.': 'تم إرسال طلب مسؤول الطابور بنجاح. في انتظار الموافقة.',
      'Registration successful! You can now login to access your queue number.': 'تم التسجيل بنجاح! يمكنك الآن تسجيل الدخول للوصول إلى رقم الطابور الخاص بك.',
      'Required': 'مطلوب',
      'Invalid Egyptian mobile number': 'رقم جوال مصري غير صحيح',
      'Please select governorate and city': 'يرجى اختيار المحافظة والمدينة',
      'Please select or create a queue point': 'يرجى اختيار أو إنشاء نقطة طابور',
      'Please enter queue point name': 'يرجى إدخال اسم نقطة الطابور',
      'Please select date and time ranges': 'يرجى اختيار نطاقات التاريخ والوقت',
      'Please enter unit name': 'يرجى إدخال اسم الوحدة',
      'Queue Point Name': 'اسم نقطة الطابور',
      'Queue Point Description': 'وصف نقطة الطابور',
      'Q Point (Distribution Point)': 'نقطة الطابور (نقطة التوزيع)',
      'Create Admin': 'إنشاء مسؤول طابور',
      'Admin Requests': 'طلبات مسؤولي الطابور',
      'Approve': 'موافقة',
      'Reject': 'رفض',
      'Request Admin Account': 'طلب حساب مسؤول طابور',
      'Fill in your information to request admin access': 'املأ معلوماتك لطلب وصول مسؤول الطابور',
      'Admin request approved': 'تمت الموافقة على طلب مسؤول الطابور',
      'Admin request rejected': 'تم رفض طلب مسؤول الطابور',
      'Admin created successfully': 'تم إنشاء مسؤول الطابور بنجاح',
      'Volunteer added successfully': 'تم إضافة مساعد مسؤول الطابور بنجاح',
      'Submit Request': 'إرسال الطلب',
      'Register New Volunteer': 'تسجيل مساعد مسؤول طابور جديد',
      'Unknown screen': 'شاشة غير معروفة',
      'Q Admin User': 'مسؤول الطابور',
      'No queues yet. Add a new queue to get started.': 'لا توجد طوابير بعد. أضف طابوراً جديداً للبدء.',
      'Distribution Area': 'نقطة الطابور',
      'Select Distribution Area': 'اختر نقطة الطابور',
      'All Areas': 'جميع نقاط الطابور',
      'No queues found for selected area.': 'لا توجد طوابير لنقطة الطابور المحددة.',
      'Delete Queue': 'حذف الطابور',
      'Enter name or extract from ID': 'أدخل الاسم أو استخرجه من الهوية',
      'Enter ID number': 'أدخل رقم الهوية',
      'Enter custom number of units': 'أدخل عدد الوحدات المخصص',
      'Custom': 'مخصص',
      'Enter queue name': 'أدخل اسم الطابور',
      'Please enter queue name': 'يرجى إدخال اسم الطابور',
      'Distribution Area *': 'نقطة الطابور *',
      'Initial Assigned Queue Point *': 'نقطة الطابور المخصصة الأولية *',
      'ID Copy *': 'نسخة الهوية *',
      'Type *': 'النوع *',
      'Gender *': 'الجنس *',
      'Name *': 'الاسم *',
      'ID Number *': 'رقم الهوية *',
      'Mobile Number *': 'رقم الجوال *',
      'Number of Units *': 'عدد الوحدات *',
      'Queue Name *': 'اسم الطابور *',
      'Queue Type *': 'نوع الطابور *',
      'From Date *': 'من تاريخ *',
      'To Date *': 'إلى تاريخ *',
      'From Time *': 'من وقت *',
      'To Time *': 'إلى وقت *',
      'Unit Name *': 'اسم الوحدة *',
      'Number of Available Units *': 'عدد الوحدات المتاحة *',
      'Estimated Queue Size *': 'الحجم المقدر للطابور *',
      'Please enter queue name': 'يرجى إدخال اسم الطابور',
      'First-Time Setup': 'الإعداد الأولي',
      'Initializing app features for the first time.\nThis may take 30-40 seconds.': 'تهيئة ميزات التطبيق لأول مرة.\nقد يستغرق هذا 30-40 ثانية.',
      'Preparing app features...': 'تحضير ميزات التطبيق...',
      'Setting up database structure...': 'إعداد هيكل قاعدة البيانات...',
      'Finalizing setup...': 'إنهاء الإعداد...',
      'Setup complete!': 'اكتمل الإعداد!',
      'Please enter name': 'يرجى إدخال الاسم',
      'Please enter ID number': 'يرجى إدخال رقم الهوية',
      'Extract name from ID using OCR': 'استخراج الاسم من الهوية باستخدام OCR',
      'Queue not found in Firestore': 'الطابور غير موجود في Firestore',
      'Error updating queue:': 'خطأ في تحديث الطابور:',
      'Beneficiary found': 'تم العثور على المستفيد',
      'No areas available': 'لا توجد مناطق متاحة',
      'Serving:': 'تقديم:',
      'Served': 'مخدوم',
      'Attendees': 'الحضور',
      'Available': 'متاح',
      'Est. Q Size': 'الحجم المقدر للطابور',
      'No beneficiaries assigned': 'لا يوجد مستفيدون معينون',
      'Initializing Firebase connection...': 'تهيئة اتصال Firebase...',
      'Connecting to Firebase servers...': 'الاتصال بخوادم Firebase...',
      'Setting up Firebase services...': 'إعداد خدمات Firebase...',
      'Select Photo Source': 'اختر مصدر الصورة',
      'Select ID Copy Source': 'اختر مصدر نسخة الهوية',
      'ID Copy captured successfully': 'تم التقاط نسخة الهوية بنجاح',
      'ID Copy selected successfully': 'تم اختيار نسخة الهوية بنجاح',
      'Camera': 'الكاميرا',
      'Gallery': 'المعرض',
      'Register Beneficiary': 'تسجيل مستفيد',
      'Current Password': 'كلمة المرور الحالية',
      'New Password': 'كلمة المرور الجديدة',
      'Confirm New Password': 'تأكيد كلمة المرور الجديدة',
      'Please fill all fields': 'يرجى ملء جميع الحقول',
      'New passwords do not match': 'كلمات المرور الجديدة غير متطابقة',
      'User not found': 'المستخدم غير موجود',
      'Current password is incorrect': 'كلمة المرور الحالية غير صحيحة',
      'Password changed successfully': 'تم تغيير كلمة المرور بنجاح',
      'Error changing password:': 'خطأ في تغيير كلمة المرور:',
      'Help & Support': 'المساعدة والدعم',
      'ID Scanned': 'تم مسح الهوية',
      'Enter NFC code': 'أدخل رمز NFC',
      'Error loading areas:': 'خطأ في تحميل المناطق:',
      'EQMS Dashboard': 'لوحة تحكم نظام إدارة الجودة الإلكتروني',
      'Reject Request': 'رفض الطلب',
      'active': 'نشط',
      'suspended': 'معلق',
      'completed': 'مكتمل',
      'inactive': 'غير نشط',
      'Photo taken successfully': 'تم التقاط الصورة بنجاح',
      'Photo selected successfully': 'تم اختيار الصورة بنجاح',
      'Permission Required': 'إذن مطلوب',
      'Open Settings': 'فتح الإعدادات',
      'Camera permission is required. Please enable it in app settings.': 'إذن الكاميرا مطلوب. يرجى تفعيله في إعدادات التطبيق.',
      'Storage permission is required. Please enable it in app settings.': 'إذن التخزين مطلوب. يرجى تفعيله في إعدادات التطبيق.',
      'Error completing queue:': 'خطأ في إكمال الطابور:',
      'Disability': 'إعاقة',
    },
  };
  
  static String translate(String key) {
    return translations[currentLanguage]?[key] ?? key;
  }
  
  static bool get isArabic => currentLanguage == 'Arabic';
  
  static TextDirection get textDirection => isArabic ? TextDirection.rtl : TextDirection.ltr;
  
  static void setLanguage(String language) {
    currentLanguage = language;
    languageNotifier.value = language;
  }
}

// Image Quality Validator for OCR preprocessing
/// Document Scanner Helper (Google Lens-like automatic document detection)
class DocumentScannerHelper {
  static const MethodChannel _channel = MethodChannel('com.et3amapp.eqmsapp/document_scanner');
  
  /// Scan document using ML Kit Document Scanner (Google Lens-like)
  /// Features:
  /// - Automatic edge detection
  /// - Perspective correction
  /// - Built-in cropping UI
  /// - Works offline
  static Future<String?> scanDocument() async {
    try {
      final result = await _channel.invokeMethod<String>('scanDocument');
      if (result != null && File(result).existsSync()) {
        print('✅ Document Scanner: Scanned document saved: $result');
        return result;
      } else {
        print('⚠️ Document Scanner: User cancelled or no document detected');
        return null;
      }
    } catch (e, stackTrace) {
      print('❌ Document Scanner Error: $e');
      print('Stack trace: $stackTrace');
      // If Document Scanner fails, return null to fall back to manual cropping
      return null;
    }
  }
}

/// Egyptian ID Parser Helper - Using egyptian_id_parser 1.1.0 for card detection
/// This replaces OpenCV with direct ID number parsing and data extraction
class EgyptianIDCardDetector {
  /// Extract and validate Egyptian National ID number from text
  /// Uses egyptian_id_parser package for accurate data extraction
  static Future<Map<String, dynamic>?> detectAndExtractIDData(String? idNumber) async {
    if (idNumber == null || idNumber.length != 14) {
      return null;
    }
    
    try {
      // Use egyptian_id_parser to extract data from ID number
      final idParser = EgyptianIdParser(idNumber);
      
      print('✅ Egyptian ID Parser: Extracting data from ID: $idNumber');
      print('   Birth Date: ${idParser.birthDate}');
      print('   Gender: ${idParser.gender}');
      print('   Governorate: ${idParser.governorate}');
      print('   Age: ${idParser.age}');
      
      return {
        'idNumber': idNumber,
        'birthDate': idParser.birthDate,
        'gender': idParser.gender,
        'governorate': idParser.governorate,
        'age': idParser.age,
        'isValid': true,
      };
    } catch (e, stackTrace) {
      print('❌ Egyptian ID Parser Error: $e');
      print('Stack trace: $stackTrace');
      return null;
    }
  }
  
  /// Validate ID number format (14 digits, starts with 2 or 3)
  static bool isValidIDFormat(String? idNumber) {
    if (idNumber == null || idNumber.length != 14) {
      return false;
    }
    
    // Check if all characters are digits
    if (!RegExp(r'^\d{14}$').hasMatch(idNumber)) {
      return false;
    }
    
    // Check first digit (should be 2 for 1900-1999 or 3 for 2000-2099)
    final firstDigit = int.tryParse(idNumber.substring(0, 1));
    return firstDigit == 2 || firstDigit == 3;
  }
}

class ImageQualityValidator {
  /// Check if image has sufficient quality for OCR
  /// Returns a quality score (0.0 to 1.0) and recommendations
  static Future<Map<String, dynamic>> validateImageQuality(String imagePath) async {
    try {
      final file = File(imagePath);
      if (!await file.exists()) {
        return {
          'isValid': false,
          'score': 0.0,
          'issues': ['Image file not found'],
          'recommendations': ['Please take a new photo'],
        };
      }

      final bytes = await file.readAsBytes();
      final image = img.decodeImage(bytes);
      
      if (image == null) {
        return {
          'isValid': false,
          'score': 0.0,
          'issues': ['Could not decode image'],
          'recommendations': ['Please take a new photo'],
        };
      }

      final issues = <String>[];
      final recommendations = <String>[];
      double score = 1.0;

      // Check image dimensions (minimum recommended: 800x600)
      final minWidth = 800;
      final minHeight = 600;
      if (image.width < minWidth || image.height < minHeight) {
        issues.add('Image resolution is low (${image.width}x${image.height})');
        recommendations.add('Use higher resolution camera settings');
        score -= 0.2;
      }

      // Check brightness (simple average)
      final brightness = _calculateBrightness(image);
      if (brightness < 0.3) {
        issues.add('Image is too dark (brightness: ${(brightness * 100).toStringAsFixed(0)}%)');
        recommendations.add('Ensure good lighting when taking photo');
        score -= 0.3;
      } else if (brightness > 0.85) {
        issues.add('Image is too bright (brightness: ${(brightness * 100).toStringAsFixed(0)}%)');
        recommendations.add('Avoid direct light or flash reflection');
        score -= 0.2;
      }

      // Check contrast (simple variance-based)
      final contrast = _calculateContrast(image);
      if (contrast < 0.2) {
        issues.add('Image has low contrast');
        recommendations.add('Ensure clear contrast between text and background');
        score -= 0.25;
      }

      // Check if image is too blurry (using edge detection)
      // Note: Lower threshold to avoid false positives - only flag severely blurry images
      final blurScore = _estimateBlur(image);
      if (blurScore < 0.1) {
        // Only flag as blurry if score is very low (severely blurry)
        issues.add('Image appears blurry');
        recommendations.add('Hold camera steady and ensure ID card is in focus');
        score -= 0.3;
      } else if (blurScore < 0.2) {
        // Mild blur - just a warning, don't block OCR
        recommendations.add('Image may be slightly blurry - ensure card is in focus');
        score -= 0.1;
      }

      score = score.clamp(0.0, 1.0);

      // Be more lenient with validation - only block if score is very low
      // This prevents false positives from blocking valid OCR attempts
      final isValid = score >= 0.3; // Lower threshold from 0.5 to 0.3

      return {
        'isValid': isValid,
        'score': score,
        'issues': issues,
        'recommendations': recommendations,
        'width': image.width,
        'height': image.height,
        'brightness': brightness,
        'contrast': contrast,
        'blurScore': blurScore,
      };
    } catch (e) {
      return {
        'isValid': false,
        'score': 0.0,
        'issues': ['Error validating image: $e'],
        'recommendations': ['Please try again'],
      };
    }
  }

  /// Calculate average brightness of image (0.0 to 1.0)
  static double _calculateBrightness(img.Image image) {
    int totalBrightness = 0;
    int pixelCount = 0;
    
    // Sample pixels (every 10th pixel for performance)
    for (int y = 0; y < image.height; y += 10) {
      for (int x = 0; x < image.width; x += 10) {
        final pixel = image.getPixel(x, y);
        // Extract RGB values from pixel object
        final r = pixel.r;
        final g = pixel.g;
        final b = pixel.b;
        // Calculate luminance
        final brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255.0;
        totalBrightness += (brightness * 255).round();
        pixelCount++;
      }
    }
    
    return pixelCount > 0 ? (totalBrightness / pixelCount) / 255.0 : 0.5;
  }

  /// Calculate contrast (variance-based, 0.0 to 1.0)
  static double _calculateContrast(img.Image image) {
    final brightnessValues = <int>[];
    
    // Sample pixels
    for (int y = 0; y < image.height; y += 10) {
      for (int x = 0; x < image.width; x += 10) {
        final pixel = image.getPixel(x, y);
        final r = pixel.r;
        final g = pixel.g;
        final b = pixel.b;
        final brightness = (0.299 * r + 0.587 * g + 0.114 * b).round();
        brightnessValues.add(brightness);
      }
    }
    
    if (brightnessValues.isEmpty) return 0.5;
    
    final mean = brightnessValues.reduce((a, b) => a + b) / brightnessValues.length;
    final variance = brightnessValues.map((v) => (v - mean) * (v - mean)).reduce((a, b) => a + b) / brightnessValues.length;
    final stdDev = math.sqrt(variance);
    
    // Normalize to 0-1 range (assuming max stdDev of 100)
    return (stdDev / 100.0).clamp(0.0, 1.0);
  }

  /// Estimate blur using edge detection (higher = sharper, 0.0 to 1.0)
  static double _estimateBlur(img.Image image) {
    int edgeCount = 0;
    int totalPixels = 0;
    
    // Simple edge detection using Sobel-like operator (simplified)
    for (int y = 1; y < image.height - 1; y += 5) {
      for (int x = 1; x < image.width - 1; x += 5) {
        final center = image.getPixel(x, y);
        final right = image.getPixel(x + 1, y);
        final bottom = image.getPixel(x, y + 1);
        
        // Extract RGB and calculate brightness from Pixel objects
        final centerBrightness = (center.r + center.g + center.b) / 3;
        final rightBrightness = (right.r + right.g + right.b) / 3;
        final bottomBrightness = (bottom.r + bottom.g + bottom.b) / 3;
        
        final edgeStrength = ((centerBrightness - rightBrightness).abs() + 
                              (centerBrightness - bottomBrightness).abs()) / 2;
        
        // Lower threshold to detect more edges (more sensitive to sharpness)
        // This helps avoid false positives for clear images
        if (edgeStrength > 15) { // Lower threshold for edge detection
          edgeCount++;
        }
        totalPixels++;
      }
    }
    
    // More edges = sharper image
    // Normalize: typically 10-30% of pixels are edges in a sharp image
    // Adjust the calculation to be more lenient
    final edgeRatio = totalPixels > 0 ? (edgeCount / totalPixels) : 0.0;
    // Scale the result to be more forgiving (multiply by 2-3 to account for sampling)
    return (edgeRatio * 2.5).clamp(0.0, 1.0);
  }

  /// Preprocess image for better OCR results
  /// Preprocess image using multiple strategies (inspired by OCR_Egyptian_ID Python solution)
  /// Based on: https://github.com/NASO7Y/OCR_Egyptian_ID
  /// The Python solution uses YOLO for detection and EasyOCR with multiple preprocessing strategies
  /// Now uses egyptian_id_parser 1.1.0 for ID number validation and data extraction
  static Future<String?> preprocessImage(String imagePath, {bool useThresholding = false, int threshold = 95}) async {
    try {
      // Use original image - egyptian_id_parser will validate and extract data from ID number
      String processedImagePath = imagePath;
      
      // Continue with existing preprocessing
      final file = File(processedImagePath!);
      final bytes = await file.readAsBytes();
      var image = img.decodeImage(bytes);
      
      if (image == null) return null;

      // Resize to standard size (1000x630 like Python solution) for consistent region extraction
      // But keep aspect ratio if image is larger
      if (image.width != 1000 || image.height != 630) {
        // Calculate scale to fit 1000 width while maintaining aspect ratio
        final scale = 1000.0 / image.width;
        final newHeight = (image.height * scale).round();
        image = img.copyResize(
          image,
          width: 1000,
          height: newHeight,
          interpolation: img.Interpolation.linear,
        );
        print('📐 Resized image to ${image.width}x${image.height} (Python solution standard: 1000x630)');
      }

      // Convert to grayscale (like Python solution: cv2.cvtColor(image, cv2.COLOR_BGR2GRAY))
      image = img.grayscale(image);
      
      // Apply thresholding like Python solution (thresh = 95 for front, 145 for back)
      if (useThresholding) {
        image = _applyFixedThreshold(image, threshold);
      } else {
        // Enhance contrast without thresholding (for Arabic text preservation)
        image = img.adjustColor(image, contrast: 1.3, brightness: 0.02);
      }
      
      // Sharpen image (moderate sharpening to preserve Arabic character details)
      image = img.convolution(image, filter: [
        0, -1, 0,
        -1, 5, -1,  // Moderate sharpening
        0, -1, 0,
      ]);
      
      // Final contrast adjustment if not thresholded
      if (!useThresholding) {
        image = img.adjustColor(image, contrast: 1.2);
      }
      
      // Save processed image
      final suffix = useThresholding ? '_processed_threshold_$threshold.jpg' : '_processed.jpg';
      final processedPath = '$imagePath$suffix';
      final processedBytes = img.encodeJpg(image, quality: 100); // Maximum quality
      await File(processedPath).writeAsBytes(processedBytes);
      
      print('✅ Image preprocessing completed: ${image.width}x${image.height} (thresholding: $useThresholding, threshold: $threshold)');
      return processedPath;
    } catch (e, stackTrace) {
      print('❌ Error preprocessing image: $e');
      print('Stack trace: $stackTrace');
    return null;
    }
  }
  
  /// Apply fixed threshold (like Python solution: cv2.threshold(im_gray, thresh, 255, cv2.THRESH_BINARY))
  static img.Image _applyFixedThreshold(img.Image image, int threshold) {
    for (int y = 0; y < image.height; y++) {
      for (int x = 0; x < image.width; x++) {
        final pixel = image.getPixel(x, y);
        final brightness = ((pixel.r + pixel.g + pixel.b) / 3).round();
        
        // Convert to black or white based on fixed threshold (like Python solution)
        final newValue = brightness > threshold ? 255 : 0;
        image.setPixelRgba(x, y, newValue, newValue, newValue, 255);
      }
    }
    return image;
  }
  
  /// Extract specific regions from ID card image (based on OCR_Egyptian_ID Python solution)
  /// Python solution uses: Name[150:310, 400:1000], Address[300:450, 400:1000], ID[500:560,400:1000]
  /// Inspired by: https://github.com/NASO7Y/OCR_Egyptian_ID
  static Future<Map<String, String>> extractRegionsFromImage(String imagePath) async {
    final results = <String, String>{};
    
    try {
      final file = File(imagePath);
      final bytes = await file.readAsBytes();
      var image = img.decodeImage(bytes);
      
      if (image == null) return results;
      
      // Store original dimensions before any resizing
      final originalWidth = image.width;
      final originalHeight = image.height;
      
      // Resize to standard size (1000x630) if needed for consistent region extraction
      // But calculate scale factors for adaptive coordinates
      double scaleX = 1.0;
      double scaleY = 1.0;
      
      // Calculate target dimensions maintaining aspect ratio
      final targetWidth = 1000;
      final targetHeight = 630;
      
      if (image.width != targetWidth || image.height != targetHeight) {
        // Calculate scale to fit width, then adjust height
        scaleX = targetWidth / image.width;
        scaleY = targetHeight / image.height;
        
        // Use the smaller scale to maintain aspect ratio
        final scale = scaleX < scaleY ? scaleX : scaleY;
        final newWidth = (image.width * scale).round();
        final newHeight = (image.height * scale).round();
        
        image = img.copyResize(
          image,
          width: newWidth,
          height: newHeight,
          interpolation: img.Interpolation.linear,
        );
        print('📐 Resized image from ${originalWidth}x${originalHeight} to ${image.width}x${image.height} for region extraction');
        
        // Recalculate scales based on actual resize
        scaleX = image.width / originalWidth;
        scaleY = image.height / originalHeight;
      }
      
      // Try multiple preprocessing strategies (like Python solution)
      // Strategy 1: Threshold at 95 (like Python solution for front)
      var thresholdedImage = img.grayscale(image);
      thresholdedImage = _applyFixedThreshold(thresholdedImage, 95);
      
      // Strategy 2: Adaptive threshold for better text extraction
      var adaptiveImage = img.grayscale(image);
      adaptiveImage = _applyAdaptiveThreshold(adaptiveImage);
      
      // Extract regions with adaptive coordinates based on image size
      // Use percentage-based coordinates for better adaptability
      // Name region: typically in top-right area (40-100% width, 24-49% height for 630px height)
      final nameX = (image.width * 0.4).round();
      final nameY = (image.height * 0.24).round();
      final nameWidth = (image.width * 0.6).round();
      final nameHeight = (image.height * 0.25).round();
      
      print('🔍 Name region coordinates: x=$nameX, y=$nameY, w=$nameWidth, h=$nameHeight (image: ${image.width}x${image.height})');
      
      if (image.height >= nameY + nameHeight && image.width >= nameX + nameWidth && 
          nameX >= 0 && nameY >= 0 && nameWidth > 0 && nameHeight > 0) {
        // Try thresholded version first
        try {
          final nameRegion = img.copyCrop(thresholdedImage, x: nameX, y: nameY, width: nameWidth, height: nameHeight);
          final namePath = '${imagePath}_name_region_thresh.jpg';
          await File(namePath).writeAsBytes(img.encodeJpg(nameRegion, quality: 100));
          results['nameRegion'] = namePath;
        } catch (e) {
          print('⚠️ Error extracting name region (thresholded): $e');
        }
        
        // Also try adaptive threshold version
        try {
          final nameRegionAdaptive = img.copyCrop(adaptiveImage, x: nameX, y: nameY, width: nameWidth, height: nameHeight);
          final namePathAdaptive = '${imagePath}_name_region_adaptive.jpg';
          await File(namePathAdaptive).writeAsBytes(img.encodeJpg(nameRegionAdaptive, quality: 100));
          if (!results.containsKey('nameRegion')) {
            results['nameRegion'] = namePathAdaptive;
          }
        } catch (e) {
          print('⚠️ Error extracting name region (adaptive): $e');
        }
      }
      
      // Address region: typically in middle-right area (40-100% width, 48-72% height)
      final addressX = (image.width * 0.4).round();
      final addressY = (image.height * 0.48).round();
      final addressWidth = (image.width * 0.6).round();
      final addressHeight = (image.height * 0.24).round();
      
      print('🔍 Address region coordinates: x=$addressX, y=$addressY, w=$addressWidth, h=$addressHeight');
      
      if (image.height >= addressY + addressHeight && image.width >= addressX + addressWidth &&
          addressX >= 0 && addressY >= 0 && addressWidth > 0 && addressHeight > 0) {
        try {
          final addressRegion = img.copyCrop(thresholdedImage, x: addressX, y: addressY, width: addressWidth, height: addressHeight);
          final addressPath = '${imagePath}_address_region_thresh.jpg';
          await File(addressPath).writeAsBytes(img.encodeJpg(addressRegion, quality: 100));
          results['addressRegion'] = addressPath;
        } catch (e) {
          print('⚠️ Error extracting address region: $e');
        }
      }
      
      // ID region: typically in bottom-right area (40-100% width, 79-88% height)
      // This is the most critical region for ID number extraction
      final idX = (image.width * 0.4).round();
      final idY = (image.height * 0.79).round();
      final idWidth = (image.width * 0.6).round();
      final idHeight = (image.height * 0.09).round().clamp(30, 100); // Ensure minimum height for OCR
      
      print('🔍 ID region coordinates: x=$idX, y=$idY, w=$idWidth, h=$idHeight');
      
      if (image.height >= idY + idHeight && image.width >= idX + idWidth &&
          idX >= 0 && idY >= 0 && idWidth > 0 && idHeight > 0) {
        // Try thresholded version
        try {
          final idRegion = img.copyCrop(thresholdedImage, x: idX, y: idY, width: idWidth, height: idHeight);
          final idPath = '${imagePath}_id_region_thresh.jpg';
          await File(idPath).writeAsBytes(img.encodeJpg(idRegion, quality: 100));
          results['idRegion'] = idPath;
        } catch (e) {
          print('⚠️ Error extracting ID region (thresholded): $e');
        }
        
        // Also try adaptive threshold version for ID (numbers are critical)
        try {
          final idRegionAdaptive = img.copyCrop(adaptiveImage, x: idX, y: idY, width: idWidth, height: idHeight);
          final idPathAdaptive = '${imagePath}_id_region_adaptive.jpg';
          await File(idPathAdaptive).writeAsBytes(img.encodeJpg(idRegionAdaptive, quality: 100));
          // Store both versions if thresholded worked
          if (results.containsKey('idRegion')) {
            results['idRegionAdaptive'] = idPathAdaptive;
          } else {
            results['idRegion'] = idPathAdaptive;
          }
        } catch (e) {
          print('⚠️ Error extracting ID region (adaptive): $e');
        }
      }
      
      print('✅ Extracted ${results.length} regions from ID card image');
      print('  Extracted regions: ${results.keys.join(", ")}');
    } catch (e, stackTrace) {
      print('❌ Error extracting regions: $e');
      print('Stack trace: $stackTrace');
    }
    
    return results;
  }
  
  /// Apply adaptive thresholding (binarization) to improve text recognition
  /// This converts the image to pure black and white, which is critical for Arabic OCR
  static img.Image _applyAdaptiveThreshold(img.Image image) {
    // Calculate average brightness
    int totalBrightness = 0;
    int pixelCount = 0;
    
    for (int y = 0; y < image.height; y++) {
      for (int x = 0; x < image.width; x++) {
        final pixel = image.getPixel(x, y);
        final brightness = ((pixel.r + pixel.g + pixel.b) / 3).round();
        totalBrightness += brightness;
        pixelCount++;
      }
    }
    
    final avgBrightness = totalBrightness / pixelCount;
    // Use adaptive threshold (slightly below average for better text extraction)
    final threshold = (avgBrightness * 0.85).round();
    
    // Apply threshold
    for (int y = 0; y < image.height; y++) {
      for (int x = 0; x < image.width; x++) {
        final pixel = image.getPixel(x, y);
        final brightness = ((pixel.r + pixel.g + pixel.b) / 3).round();
        
        // Convert to black or white based on threshold
        final newValue = brightness > threshold ? 255 : 0;
        image.setPixelRgba(x, y, newValue, newValue, newValue, 255); // 255 = fully opaque
      }
    }
    
    return image;
  }
}

// ID Parser Utility for extracting information from OCR text
class IDParser {
  /// Convert Arabic-Indic digits (Eastern Arabic numerals) to Western digits
  /// Arabic-Indic: ۰۱۲۳۴۵۶۷۸۹ → Western: 0123456789
  /// Also handles: ٠١٢٣٤٥٦٧٨٩ (Arabic-Indic variant)
  static String convertArabicIndicToWestern(String text) {
    final arabicIndicMap = {
      '۰': '0', '۱': '1', '۲': '2', '۳': '3', '۴': '4',
      '۵': '5', '۶': '6', '۷': '7', '۸': '8', '۹': '9',
      // Also handle Arabic-Indic variant
      '٠': '0', '١': '1', '٢': '2', '٣': '3', '٤': '4',
      '٥': '5', '٦': '6', '٧': '7', '٨': '8', '٩': '9',
    };
    
    String result = text;
    arabicIndicMap.forEach((arabic, western) {
      result = result.replaceAll(arabic, western);
    });
    return result;
  }
  
  /// Extract text blocks by position (for structured card layout)
  /// Returns: topSection, middleSection, bottomSection
  static Map<String, List<String>> extractTextBlocksByPosition(String text) {
    final lines = text.split('\n').where((l) => l.trim().isNotEmpty).toList();
    
    if (lines.isEmpty) {
      return {'top': [], 'middle': [], 'bottom': []};
    }
    
    // Divide text into sections based on position
    final totalLines = lines.length;
    final topEnd = (totalLines * 0.3).round(); // Top 30%
    final middleEnd = (totalLines * 0.7).round(); // Middle 40%
    
    return {
      'top': lines.sublist(0, topEnd.clamp(0, lines.length)),
      'middle': lines.sublist(topEnd, middleEnd.clamp(0, lines.length)),
      'bottom': lines.sublist(middleEnd, lines.length),
    };
  }
  /// Extract birth date from Egyptian National ID number
  /// Format according to Wikipedia: https://arz.wikipedia.org/wiki/بطاقة_الرقم_القومى_المصريه
  /// Format: C1 Z1 Z Z X DD MM YY C
  /// - C1 (1st digit): Check digit for validation
  /// - Z1 (digits 2-5): 4-digit unique number for births on same day in same governorate
  /// - Z (digits 6-7): Governorate code
  /// - X (digit 8): Century code (2 = 1900-1999, 3 = 2000-2099)
  /// - DD (digits 9-10): Day (2 digits)
  /// - MM (digits 11-12): Month (2 digits)
  /// - YY (digits 13-14): Year (last 2 digits)
  /// - C (15th digit): Gender (odd = male, even = female) - but ID is 14 digits, so gender is in digit 8
  /// 
  /// Actually, based on standard Egyptian ID format:
  /// Format: C YYMMDD SS NNNN C
  /// - C (1st digit): Century (2 = 1900-1999, 3 = 2000-2099)
  /// - YYMMDD (digits 2-7): Year (last 2 digits), Month, Day
  /// - SS (digits 8-9): Governorate code
  /// - NNNN (digits 10-13): Serial number
  /// - C (14th digit): Check digit (also indicates gender: odd = male, even = female)
  static DateTime? extractBirthDateFromIDNumber(String idNumber) {
    if (idNumber.length != 14) return null;
    
    try {
      // Extract century from first digit
      final centuryDigit = int.parse(idNumber.substring(0, 1));
      int centuryBase;
      if (centuryDigit == 2) {
        centuryBase = 1900; // 1900-1999
      } else if (centuryDigit == 3) {
        centuryBase = 2000; // 2000-2099
      } else {
        return null; // Invalid century digit
      }
      
      // Extract YY, MM, DD from digits 2-7 (positions 1-6 in 0-indexed)
      final year2Digits = int.parse(idNumber.substring(1, 3));
      final month = int.parse(idNumber.substring(3, 5));
      final day = int.parse(idNumber.substring(5, 7));
      
      // Validate month and day
      if (month < 1 || month > 12 || day < 1 || day > 31) {
        return null;
      }
      
      // Calculate full year
      final year = centuryBase + year2Digits;
      
      // Validate the date
      if (year >= 1900 && year <= DateTime.now().year) {
        try {
          final date = DateTime(year, month, day);
          // Check if date is valid (handles invalid dates like Feb 30)
          if (date.year == year && date.month == month && date.day == day) {
            return date;
          }
        } catch (e) {
          return null;
        }
      }
    } catch (e) {
      return null;
    }
    
    return null;
  }
  
  /// Extract birth date from OCR text (fallback method)
  static DateTime? extractBirthDate(String text) {
    // Look for date patterns: DD/MM/YYYY or DD-MM-YYYY
    final datePatterns = [
      RegExp(r'\b(\d{2})[/-](\d{2})[/-](\d{4})\b'),
      RegExp(r'\b(\d{1,2})[/-](\d{1,2})[/-](\d{4})\b'),
    ];
    
    for (final pattern in datePatterns) {
      final match = pattern.firstMatch(text);
      if (match != null) {
        try {
          final day = int.parse(match.group(1)!);
          final month = int.parse(match.group(2)!);
          final year = int.parse(match.group(3)!);
          
          // Validate date
          if (year >= 1900 && year <= DateTime.now().year &&
              month >= 1 && month <= 12 &&
              day >= 1 && day <= 31) {
            return DateTime(year, month, day);
          }
        } catch (e) {
          continue;
        }
      }
    }
    
    return null;
  }
  
  /// Extract gender from OCR text or ID number
  /// For Egyptian IDs: 14th digit (check digit) indicates gender: even = female, odd = male
  /// Also check 8th digit as fallback (some sources indicate this)
  static String? extractGender(String text, String? idNumber) {
    // First, try to extract from ID number (most accurate)
    if (idNumber != null && idNumber.length == 14) {
      try {
        // Primary: 14th digit (check digit) - even = female, odd = male
        final checkDigit = int.parse(idNumber.substring(13, 14)); // 14th digit (0-indexed: position 13)
        if (checkDigit % 2 == 0) {
          return 'Female';
        } else {
          return 'Male';
        }
      } catch (e) {
        // Fall through to text extraction
      }
    }
    
    // Fallback: extract from text
    final lowerText = text.toLowerCase();
    // Arabic terms: ذكر (male), أنثى (female), النوع (gender)
    if (lowerText.contains('ذكر') || lowerText.contains('male') || lowerText.contains('m')) {
      return 'Male';
    } else if (lowerText.contains('أنثى') || lowerText.contains('female') || lowerText.contains('f')) {
      return 'Female';
    }
    return null;
  }
  
  /// Extract religion from OCR text
  /// According to Wikipedia: مسلم (Muslim), مسيحى (Christian), يهودى (Jewish), or "-" for others
  static String? extractReligion(String text) {
    final lowerText = text.toLowerCase();
    // Arabic terms
    if (lowerText.contains('مسلم') || lowerText.contains('muslim') || lowerText.contains('islam')) {
      return 'Muslim';
    } else if (lowerText.contains('مسيحى') || lowerText.contains('christian') || lowerText.contains('مسيحي')) {
      return 'Christian';
    } else if (lowerText.contains('يهودى') || lowerText.contains('jewish') || lowerText.contains('يهودي')) {
      return 'Jewish';
    } else if (lowerText.contains('-') && (lowerText.contains('ديان') || lowerText.contains('religion'))) {
      return '-'; // Other religions
    }
    return null;
  }
  
  /// Extract marital status from OCR text
  /// According to Wikipedia: أعزب (Single), متجوز (Married), مطلّق (Divorced), أرمل (Widowed)
  static String? extractMaritalStatus(String text) {
    final lowerText = text.toLowerCase();
    // Arabic terms
    if (lowerText.contains('أعزب') || lowerText.contains('single') || lowerText.contains('unmarried')) {
      return 'Single';
    } else if (lowerText.contains('متجوز') || lowerText.contains('married') || lowerText.contains('متزوج')) {
      return 'Married';
    } else if (lowerText.contains('مطلّق') || lowerText.contains('divorced') || lowerText.contains('مطلق')) {
      return 'Divorced';
    } else if (lowerText.contains('أرمل') || lowerText.contains('widowed') || lowerText.contains('widow')) {
      return 'Widowed';
    }
    return null;
  }
  
  /// Extract address (عنوان محلّ الإقامه) from OCR text
  /// Address is typically in the middle section of the card
  static String? extractAddress(String text) {
    // Use the existing extractBirthLocation method but rename it conceptually
    // Address and birth location might be the same or different fields
    return extractBirthLocation(text);
  }
  
  /// Extract issuing office (مكتب الإصدار) from OCR text
  static String? extractIssuingOffice(String text) {
    final lowerText = text.toLowerCase();
    // Look for patterns like "مكتب الإصدار" or "issuing office"
    final officePatterns = [
      RegExp(r'مكتب[:\s]+([أ-ي\s]+)', caseSensitive: false),
      RegExp(r'issuing[:\s]+office[:\s]+([a-zA-Z\s]+)', caseSensitive: false),
      RegExp(r'مكتب[:\s]+([أ-ي\s]+)', caseSensitive: false),
    ];
    
    for (final pattern in officePatterns) {
      final match = pattern.firstMatch(text);
      if (match != null && match.groupCount >= 1) {
        final office = match.group(1)?.trim();
        if (office != null && office.length >= 3) {
          return office;
        }
      }
    }
    return null;
  }
  
  /// Extract profession (المهنه) from OCR text
  static String? extractProfession(String text) {
    final lowerText = text.toLowerCase();
    // Look for patterns like "المهنة" or "profession"
    final professionPatterns = [
      RegExp(r'المهنة[:\s]+([أ-ي\s]+)', caseSensitive: false),
      RegExp(r'profession[:\s]+([a-zA-Z\s]+)', caseSensitive: false),
      RegExp(r'المهنه[:\s]+([أ-ي\s]+)', caseSensitive: false),
    ];
    
    for (final pattern in professionPatterns) {
      final match = pattern.firstMatch(text);
      if (match != null && match.groupCount >= 1) {
        final profession = match.group(1)?.trim();
        if (profession != null && profession.length >= 2) {
          return profession;
        }
      }
    }
    return null;
  }
  
  /// Extract husband's name (اسم الزوج) from OCR text (for women)
  static String? extractHusbandName(String text) {
    final lowerText = text.toLowerCase();
    // Look for patterns like "اسم الزوج" or "husband's name"
    final husbandPatterns = [
      RegExp(r'اسم[:\s]+الزوج[:\s]+([أ-ي\s]+)', caseSensitive: false),
      RegExp(r'husband[:\s]+name[:\s]+([a-zA-Z\s]+)', caseSensitive: false),
      RegExp(r'زوج[:\s]+([أ-ي\s]+)', caseSensitive: false),
    ];
    
    for (final pattern in husbandPatterns) {
      final match = pattern.firstMatch(text);
      if (match != null && match.groupCount >= 1) {
        final husbandName = match.group(1)?.trim();
        if (husbandName != null && husbandName.length >= 3) {
          return husbandName;
        }
      }
    }
    return null;
  }
  
  /// Extract issue date (تاريخ إصدار البطاقه) from OCR text
  static DateTime? extractIssueDate(String text) {
    // Look for date patterns near "إصدار" or "issue"
    final issueDatePatterns = [
      RegExp(r'إصدار[:\s]+(\d{2})[/-](\d{2})[/-](\d{4})', caseSensitive: false),
      RegExp(r'issue[:\s]+date[:\s]+(\d{2})[/-](\d{2})[/-](\d{4})', caseSensitive: false),
      RegExp(r'تاريخ[:\s]+إصدار[:\s]+(\d{2})[/-](\d{2})[/-](\d{4})', caseSensitive: false),
    ];
    
    for (final pattern in issueDatePatterns) {
      final match = pattern.firstMatch(text);
      if (match != null && match.groupCount >= 3) {
        try {
          final day = int.parse(match.group(1)!);
          final month = int.parse(match.group(2)!);
          final year = int.parse(match.group(3)!);
          
          if (year >= 1900 && year <= DateTime.now().year &&
              month >= 1 && month <= 12 &&
              day >= 1 && day <= 31) {
            return DateTime(year, month, day);
          }
        } catch (e) {
          continue;
        }
      }
    }
    return null;
  }
  
  /// Extract expiry date (تاريخ انتهاء صلاحيه البطاقه) from OCR text
  static DateTime? extractExpiryDate(String text) {
    // Look for date patterns near "انتهاء" or "expiry"
    final expiryDatePatterns = [
      RegExp(r'انتهاء[:\s]+(\d{2})[/-](\d{2})[/-](\d{4})', caseSensitive: false),
      RegExp(r'expiry[:\s]+date[:\s]+(\d{2})[/-](\d{2})[/-](\d{4})', caseSensitive: false),
      RegExp(r'تاريخ[:\s]+انتهاء[:\s]+(\d{2})[/-](\d{2})[/-](\d{4})', caseSensitive: false),
    ];
    
    for (final pattern in expiryDatePatterns) {
      final match = pattern.firstMatch(text);
      if (match != null && match.groupCount >= 3) {
        try {
          final day = int.parse(match.group(1)!);
          final month = int.parse(match.group(2)!);
          final year = int.parse(match.group(3)!);
          
          if (year >= 1900 && year <= 2100 &&
              month >= 1 && month <= 12 &&
              day >= 1 && day <= 31) {
            return DateTime(year, month, day);
          }
        } catch (e) {
          continue;
        }
      }
    }
    return null;
  }
  
  /// Parse all information from OCR text for Egyptian National ID with confidence scores
  /// Based on Wikipedia: https://arz.wikipedia.org/wiki/بطاقة_الرقم_القومى_المصريه
  /// Uses egyptian_id_parser package 1.1.0: https://pub.dev/packages/egyptian_id_parser
  /// Extracts: Name, Birth Date, Gender, Religion, Marital Status, Address, ID Number, Governorate, etc.
  /// 
  /// Card detection is now handled by egyptian_id_parser directly (replaces OpenCV)
  /// The package validates ID numbers and extracts: birth date, gender, governorate, and age
  static Map<String, dynamic> parseIDText(String text) {
    final idNumber = extractIDNumber(text);
    DateTime? birthDate;
    String? gender;
    String? governorate;
    double idNumberConfidence = 0.0;
    double nameConfidence = 0.0;
    double birthDateConfidence = 0.0;
    double genderConfidence = 0.0;
    double addressConfidence = 0.0;
    double religionConfidence = 0.0;
    double maritalStatusConfidence = 0.0;
    double governorateConfidence = 0.0;
    
    // Use egyptian_id_parser package for ID number validation and data extraction
    EgyptianIdParser? idParser;
    if (idNumber != null && idNumber.length == 14) {
      try {
        // Validate ID format first
        if (EgyptianIDCardDetector.isValidIDFormat(idNumber)) {
          idParser = EgyptianIdParser(idNumber);
          print('✅ Using egyptian_id_parser for ID: $idNumber');
          print('   Birth Date: ${idParser.birthDate}');
          print('   Gender: ${idParser.gender}');
          print('   Governorate: ${idParser.governorate}');
          print('   Age: ${idParser.age}');
        } else {
          print('⚠️ Invalid ID number format: $idNumber');
        }
      } catch (e) {
        print('⚠️ Error using egyptian_id_parser: $e');
        idParser = null;
      }
    }
    
    // Calculate confidence for ID number
    if (idNumber != null) {
      // High confidence if exact 14 digits found
      if (idNumber.length == 14) {
        idNumberConfidence = 0.95;
        // Validate ID number format (first digit should be 2 or 3)
        final firstDigit = int.tryParse(idNumber.substring(0, 1));
        if (firstDigit == 2 || firstDigit == 3) {
          idNumberConfidence = 1.0;
        }
      } else {
        idNumberConfidence = 0.5; // Partial match
      }
    }
    
    // Extract birth date using egyptian_id_parser (most accurate)
    if (idParser != null) {
      try {
        final birthDateString = idParser.birthDate;
        if (birthDateString != null && birthDateString.isNotEmpty) {
          birthDate = DateTime.tryParse(birthDateString);
          if (birthDate != null) {
            birthDateConfidence = 0.98; // Very high confidence from egyptian_id_parser
          }
        }
      } catch (e) {
        print('⚠️ Error extracting birth date from egyptian_id_parser: $e');
      }
    }
    
    // Fallback: try custom extraction if egyptian_id_parser didn't work
    if (birthDate == null && idNumber != null && idNumber.length == 14) {
      birthDate = extractBirthDateFromIDNumber(idNumber);
      if (birthDate != null) {
        birthDateConfidence = 0.95; // High confidence from custom extraction
      }
    }
    
    // Fallback: try to extract from text
    if (birthDate == null) {
      birthDate = extractBirthDate(text);
      if (birthDate != null) {
        birthDateConfidence = 0.7; // Medium confidence from text
      }
    }
    
    // Extract gender using egyptian_id_parser (most accurate)
    if (idParser != null) {
      try {
        final parserGender = idParser.gender;
        if (parserGender != null && parserGender.isNotEmpty) {
          // Convert to our format (Male/Female)
          gender = parserGender.toLowerCase() == 'male' ? 'Male' : 
                   parserGender.toLowerCase() == 'female' ? 'Female' : parserGender;
          genderConfidence = 0.98; // Very high confidence from egyptian_id_parser
        }
      } catch (e) {
        print('⚠️ Error extracting gender from egyptian_id_parser: $e');
      }
    }
    
    // Fallback: try custom extraction if egyptian_id_parser didn't work
    if (gender == null) {
      gender = extractGender(text, idNumber);
      if (gender != null) {
        // Higher confidence if extracted from ID number
        if (idNumber != null && idNumber.length == 14) {
          genderConfidence = 0.95; // High confidence from custom extraction
        } else {
          genderConfidence = 0.7; // Medium confidence from text
        }
      }
    }
    
    // Extract governorate using egyptian_id_parser
    if (idParser != null) {
      try {
        final parserGovernorate = idParser.governorate;
        if (parserGovernorate != null && parserGovernorate.isNotEmpty) {
          governorate = parserGovernorate;
          governorateConfidence = 0.95; // High confidence from egyptian_id_parser
        }
      } catch (e) {
        print('⚠️ Error extracting governorate from egyptian_id_parser: $e');
      }
    }
    
    // Extract name with confidence (from center-right top section)
    final name = extractName(text);
    if (name != null) {
      // Higher confidence for longer names and Arabic names
      if (name.length >= 5) {
        nameConfidence = 0.85;
        if (RegExp(r'[أ-ي]').hasMatch(name)) {
          nameConfidence = 0.95; // Arabic names are more reliable
        }
      } else {
        nameConfidence = 0.65;
      }
    }
    
    // Extract address (عنوان محلّ الإقامه) with confidence
    final address = extractAddress(text);
    if (address != null) {
      addressConfidence = 0.8;
      if (RegExp(r'[أ-ي]').hasMatch(address)) {
        addressConfidence = 0.9; // Arabic addresses are more reliable
      }
    }
    
    // Extract birth location with confidence (from center-right middle section)
    double birthLocationConfidence = 0.0;
    final birthLocation = extractBirthLocation(text);
    if (birthLocation != null) {
      birthLocationConfidence = 0.8;
      if (RegExp(r'[أ-ي]').hasMatch(birthLocation)) {
        birthLocationConfidence = 0.9; // Arabic locations are more reliable
      }
    }
    
    // Extract religion (الديانه)
    final religion = extractReligion(text);
    if (religion != null) {
      religionConfidence = 0.85; // High confidence if found
    }
    
    // Extract marital status (الحاله الاجتماعيه)
    final maritalStatus = extractMaritalStatus(text);
    if (maritalStatus != null) {
      maritalStatusConfidence = 0.85; // High confidence if found
    }
    
    // Extract optional fields
    final issuingOffice = extractIssuingOffice(text);
    final profession = extractProfession(text);
    final husbandName = extractHusbandName(text);
    final issueDate = extractIssueDate(text);
    final expiryDate = extractExpiryDate(text);
    
    // Calculate overall confidence (weighted average)
    final overallConfidence = (idNumberConfidence * 0.3 + 
                               nameConfidence * 0.25 + 
                               birthDateConfidence * 0.15 + 
                               addressConfidence * 0.1 +
                               birthLocationConfidence * 0.05 +
                               genderConfidence * 0.08 +
                               religionConfidence * 0.04 +
                               maritalStatusConfidence * 0.03);
    
    return {
      // Core required fields
      'idNumber': idNumber,
      'name': name,
      'birthDate': birthDate,
      'gender': gender,
      
      // Location fields
      'address': address, // عنوان محلّ الإقامه (Address of residence)
      'birthLocation': birthLocation, // مكان الميلاد (Place of birth)
      'governorate': governorate, // المحافظة (Governorate from ID number via egyptian_id_parser)
      
      // Additional fields from Wikipedia article
      'religion': religion, // الديانه (Religion: مسلم/مسيحى/يهودى/-)
      'maritalStatus': maritalStatus, // الحاله الاجتماعيه (Marital Status: أعزب/متجوز/مطلّق/أرمل)
      'issuingOffice': issuingOffice, // مكتب الإصدار (Issuing Office)
      'profession': profession, // المهنه (Profession)
      'husbandName': husbandName, // اسم الزوج (Husband's Name - for women)
      'issueDate': issueDate, // تاريخ إصدار البطاقه (Issue Date)
      'expiryDate': expiryDate, // تاريخ انتهاء صلاحيه البطاقه (Expiry Date)
      
      // Confidence scores
      'confidence': {
        'overall': overallConfidence,
        'idNumber': idNumberConfidence,
        'name': nameConfidence,
        'birthDate': birthDateConfidence,
        'address': addressConfidence,
        'birthLocation': birthLocationConfidence,
        'gender': genderConfidence,
        'religion': religionConfidence,
        'maritalStatus': maritalStatusConfidence,
        'governorate': governorateConfidence,
      },
    };
  }
  
  /// Enhanced ID number extraction targeting bottom-right section with Arabic-Indic digits
  /// National ID number is located at bottom-right of the card using Arabic-Indic numerals (۰۱۲۳۴۵۶۷۸۹)
  /// Example: "۲۸۹۰۹۰۹۱۳۰۰۵۹۰" should be converted to "28909091300590"
  static String? extractIDNumber(String text) {
    print('🔍 extractIDNumber called with text length: ${text.length}');
    print('🔍 Full input text (first 500 chars): ${text.substring(0, text.length > 500 ? 500 : text.length)}');
    
    // Extract text blocks to prioritize bottom section (where ID number is located)
    final blocks = extractTextBlocksByPosition(text);
    final bottomSection = blocks['bottom']!.join(' ');
    print('🔍 Bottom section text: $bottomSection');
    
    // Convert Arabic-Indic digits to Western digits in bottom section first
    String bottomCleaned = convertArabicIndicToWestern(bottomSection);
    
    // Remove common OCR errors (O -> 0, I -> 1, S -> 5, etc.)
    bottomCleaned = bottomCleaned
        .replaceAll(RegExp(r'[Oo]'), '0')
        .replaceAll(RegExp(r'[Ii]'), '1')
        .replaceAll(RegExp(r'[Ss]'), '5')
        .replaceAll(RegExp(r'[Zz]'), '2');
    
    print('🔍 Bottom section cleaned: $bottomCleaned');
    
    // Try to find ID in bottom section first (most likely location - bottom-right)
    String? idFromBottom = _extractIDFromText(bottomCleaned);
    if (idFromBottom != null) {
      print('✅ ID Number found in bottom section: $idFromBottom');
      return idFromBottom;
    }
    
    // Fallback: convert entire text and search
    String cleanedText = convertArabicIndicToWestern(text);
    cleanedText = cleanedText
        .replaceAll(RegExp(r'[Oo]'), '0')
        .replaceAll(RegExp(r'[Ii]'), '1')
        .replaceAll(RegExp(r'[Ss]'), '5')
        .replaceAll(RegExp(r'[Zz]'), '2');
    
    print('🔍 Full text cleaned (first 500 chars): ${cleanedText.substring(0, cleanedText.length > 500 ? 500 : cleanedText.length)}');
    
    String? idFromFull = _extractIDFromText(cleanedText);
    if (idFromFull != null) {
      print('✅ ID Number found in full text: $idFromFull');
    } else {
      print('❌ ID Number not found.');
      print('❌ Bottom section text: ${bottomCleaned.substring(0, bottomCleaned.length > 200 ? 200 : bottomCleaned.length)}');
      print('❌ Full cleaned text length: ${cleanedText.length}');
      print('❌ All numbers found in text: ${RegExp(r'\d+').allMatches(cleanedText).map((m) => m.group(0)).toList()}');
    }
    return idFromFull;
  }
  
  /// Helper method to extract 14-digit ID from text
  static String? _extractIDFromText(String text) {
    print('🔍 _extractIDFromText called with text: ${text.substring(0, text.length > 200 ? 200 : text.length)}');
    
    // Try multiple patterns with different spacing
    final patterns = [
      // Exact 14 digits
      RegExp(r'\b\d{14}\b'),
      // With spaces: XX XX XX XX XX XX XX
      RegExp(r'\d{2}\s+\d{2}\s+\d{2}\s+\d{2}\s+\d{2}\s+\d{2}\s+\d{2}'),
      // With dashes: XX-XX-XX-XX-XX-XX-XX
      RegExp(r'\d{2}[-]\d{2}[-]\d{2}[-]\d{2}[-]\d{2}[-]\d{2}[-]\d{2}'),
      // Any 14 consecutive digits
      RegExp(r'\d{14}'),
      // Pattern with optional separators
      RegExp(r'\d{2}[\s-]?\d{2}[\s-]?\d{2}[\s-]?\d{2}[\s-]?\d{2}[\s-]?\d{2}[\s-]?\d{2}'),
    ];
    
    for (final pattern in patterns) {
      final match = pattern.firstMatch(text);
      if (match != null) {
        final id = match.group(0)!.replaceAll(RegExp(r'[^\d]'), '');
        if (id.length == 14) {
          // Validate first digit (should be 2 or 3 for Egyptian IDs)
          final firstDigit = int.tryParse(id.substring(0, 1));
          if (firstDigit == 2 || firstDigit == 3) {
            print('✅ Found 14-digit ID with pattern: $id');
            return id;
          }
        }
      }
    }
    
    // Fallback: find longest number sequence (8-14 digits)
    final longNumberPattern = RegExp(r'\b\d{8,14}\b');
    final matches = longNumberPattern.allMatches(text);
    String? bestMatch;
    int maxLength = 0;
    
    for (final match in matches) {
      final number = match.group(0)!.replaceAll(RegExp(r'[^\d]'), '');
      if (number.length > maxLength && number.length <= 14) {
        maxLength = number.length;
        bestMatch = number;
      }
    }
    
    print('🔍 Found longest number sequence: $bestMatch (length: ${bestMatch?.length ?? 0})');
    
    // If we found a 14-digit number, return it
    if (bestMatch != null && bestMatch.length == 14) {
      final firstDigit = int.tryParse(bestMatch.substring(0, 1));
      if (firstDigit == 2 || firstDigit == 3) {
        print('✅ Found valid 14-digit ID: $bestMatch');
        return bestMatch;
      }
    }
    
    // If we found a number that's close to 14 digits (10-13), log it for debugging
    if (bestMatch != null && bestMatch.length >= 10 && bestMatch.length < 14) {
      print('⚠️ Found partial ID (${bestMatch.length} digits): $bestMatch - might be incomplete OCR');
    }
    
    return bestMatch;
  }
  
  /// Enhanced name extraction targeting center-right top section
  /// Name is typically in the center-right area, top section of the card
  /// Example: "محمود عصام عبد العزيز قطب محمد"
  static String? extractName(String text) {
    // Extract text blocks by position
    final blocks = extractTextBlocksByPosition(text);
    
    // Prioritize top and middle sections (where name is located on the card)
    final topSection = blocks['top']!;
    final middleSection = blocks['middle']!;
    
    // Combine top and middle sections, prioritizing top
    final candidateLines = [...topSection, ...middleSection];
    
    final List<Map<String, dynamic>> potentialNames = [];
    
    // First, try to find multi-line names (names can span multiple lines)
    String? multiLineName = _extractMultiLineName(candidateLines);
    if (multiLineName != null) {
      return multiLineName;
    }
    
    // Enhanced exclude words list
    final excludeWords = [
      'رقم', 'number', 'الرقم', 'the number', 'رقم القومي', 'national number',
      'تاريخ', 'date', 'التاريخ', 'the date', 'تاريخ الميلاد', 'birth date',
      'مكان', 'place', 'المكان', 'the place', 'مكان الميلاد', 'place of birth',
      'عنوان', 'address', 'العنوان', 'the address',
      'اسم', 'name', 'الاسم', 'the name',
      'جنس', 'gender', 'الجنس', 'the gender',
      'ذكر', 'male', 'أنثى', 'female', 'm', 'f',
      'مصري', 'egyptian', 'مصر', 'egypt', 'egyptian arab republic',
      'جمهورية', 'republic', 'الجمهورية', 'the republic',
      'وزارة', 'ministry', 'الوزارة', 'the ministry',
      'الداخلية', 'interior', 'الهوية', 'identity',
      'بطاقة', 'card', 'البطاقة', 'the card',
      'وطنية', 'national', 'الوطنية', 'the national',
      'مدنية', 'civil', 'المدنية', 'the civil',
      'سجل', 'registry', 'السجل', 'the registry',
      'سلطة', 'authority', 'السلطة', 'the authority',
      'بطاقة تحقيق', 'personal identification', 'تحقيق الشخصية',
      'id', 'card', 'identity', 'national id',
    ];
    
    for (int i = 0; i < candidateLines.length; i++) {
      final line = candidateLines[i].trim();
      
      // Skip if it's just numbers, dates, or too short
      if (RegExp(r'^[\d\s]+$').hasMatch(line)) continue; // Only digits and spaces
      if (RegExp(r'\d{2}[/-]\d{2}[/-]\d{4}').hasMatch(line)) continue;
      if (RegExp(r'^\d{14}$').hasMatch(line)) continue;
      if (line.length < 3) continue;
      
      // Skip alphanumeric codes (like card serial numbers: GS6787688, etc.)
      final trimmedLine = line.trim();
      if (RegExp(r'^[A-Z]{1,3}\d{4,}$').hasMatch(trimmedLine)) continue; // Pattern: 1-3 letters followed by 4+ digits (e.g., GS6787688)
      if (RegExp(r'^[A-Z]{2,}\d+$').hasMatch(trimmedLine)) continue; // Pattern: 2+ letters followed by digits
      // Skip patterns like "144.J.4.4" or "1Z3237017" (numbers with dots or mixed alphanumeric)
      if (RegExp(r'^\d+[A-Z]\d+$').hasMatch(trimmedLine)) continue; // Pattern: digits + letter + digits (e.g., 1Z3237017)
      if (RegExp(r'^\d+\.\w+\.\d+\.\d+$').hasMatch(trimmedLine)) continue; // Pattern: number.number.number.number (e.g., 144.J.4.4)
      if (RegExp(r'^\d+[\.\-\s][A-Za-z][\.\-\s]\d+[\.\-\s]\d+$').hasMatch(trimmedLine)) continue; // Pattern with separators
      // Skip lines that are mostly alphanumeric codes (more than 70% alphanumeric pattern for short lines)
      final alphanumericPattern = RegExp(r'[A-Z0-9]');
      final alphanumericCount = alphanumericPattern.allMatches(trimmedLine).length;
      if (alphanumericCount > trimmedLine.length * 0.7 && trimmedLine.length < 15) continue; // Skip short alphanumeric codes
      
      // Skip if line starts with common card serial prefixes
      final upperLine = trimmedLine.toUpperCase();
      if (RegExp(r'^(GS|SN|SER|REF|ID|NO)[\dA-Z]+$').hasMatch(upperLine)) continue; // Skip serial number patterns
      
      // Skip if line contains mostly numbers with single letters (like "1Z3237017")
      if (RegExp(r'^\d+[A-Z]\d+$').hasMatch(trimmedLine)) continue;
      
      // Check if it contains Arabic or English characters
      final hasArabic = RegExp(r'[أ-ي]').hasMatch(line);
      final hasEnglish = RegExp(r'[a-zA-Z]').hasMatch(line);
      
      if (hasArabic || hasEnglish) {
        // Check if it contains excluded words
        bool shouldExclude = false;
        final lowerLine = line.toLowerCase();
        for (final word in excludeWords) {
          if (lowerLine.contains(word.toLowerCase())) {
            shouldExclude = true;
            break;
          }
        }
        
        // Additional validation: reject patterns that look like codes, not names
        final isInvalidPattern = RegExp(r'^\d+[A-Z]\d+$').hasMatch(trimmedLine) || // 1Z3237017
            RegExp(r'^\d+\.\w+\.\d+\.\d+$').hasMatch(trimmedLine) || // 144.J.4.4
            RegExp(r'^[A-Z]{1,3}\d{4,}$').hasMatch(trimmedLine) || // GS6787688
            RegExp(r'^\d+[\.\-\s][A-Za-z][\.\-\s]\d+[\.\-\s]\d+$').hasMatch(trimmedLine); // patterns with separators
        
        // Allow longer names (Arabic names can be quite long with multiple parts)
        if (!shouldExclude && !isInvalidPattern && line.length <= 100 && line.length >= 3) {
          // Require Arabic characters for names (Egyptian ID cards have Arabic names)
          if (!hasArabic && line.length < 10) {
            continue; // Skip non-Arabic short lines (likely not names)
          }
          
          // Calculate confidence score
          double confidence = 0.5;
          if (hasArabic) confidence += 0.4; // Arabic names are more reliable
          // Boost confidence for names with multiple words (spaces indicate full name)
          final wordCount = line.split(RegExp(r'\s+')).length;
          if (wordCount >= 2 && wordCount <= 6) confidence += 0.2; // Full names typically have 2-6 words
          if (line.length >= 5 && line.length <= 80) confidence += 0.15;
          if (i < 3) confidence += 0.2; // Names usually appear in first few lines of top section
          if (i < topSection.length) confidence += 0.15; // Extra boost for top section
          
          potentialNames.add({
            'name': line,
            'confidence': confidence,
            'isArabic': hasArabic,
            'length': line.length,
            'position': i,
            'isTopSection': i < topSection.length,
          });
        }
      }
    }
    
    if (potentialNames.isEmpty) return null;
    
    // Sort by confidence (Arabic first, top section first, then by confidence, then by position)
    potentialNames.sort((a, b) {
      // Prioritize Arabic
      if (a['isArabic'] as bool && !(b['isArabic'] as bool)) return -1;
      if (!(a['isArabic'] as bool) && b['isArabic'] as bool) return 1;
      // Prioritize top section
      if (a['isTopSection'] as bool && !(b['isTopSection'] as bool)) return -1;
      if (!(a['isTopSection'] as bool) && b['isTopSection'] as bool) return 1;
      // Then by confidence
      final confDiff = (b['confidence'] as double).compareTo(a['confidence'] as double);
      if (confDiff != 0) return confDiff;
      // Finally by position
      return (a['position'] as int).compareTo(b['position'] as int);
    });
    
    return potentialNames.first['name'] as String;
  }
  
  /// Extract multi-line name (Arabic names can span multiple lines)
  /// Example: "محمود" on one line, "عصام عبد العزيز قطب محمد" on next line
  static String? _extractMultiLineName(List<String> lines) {
    // Look for consecutive lines with Arabic text that form a name
    for (int i = 0; i < lines.length - 1; i++) {
      final line1 = lines[i].trim();
      final line2 = lines[i + 1].trim();
      
      // Both lines should contain Arabic characters
      final hasArabic1 = RegExp(r'[أ-ي]').hasMatch(line1);
      final hasArabic2 = RegExp(r'[أ-ي]').hasMatch(line2);
      
      if (hasArabic1 && hasArabic2) {
        // Check if they look like name parts (not too long, not numbers, not excluded words)
        if (line1.length >= 3 && line1.length <= 30 &&
            line2.length >= 3 && line2.length <= 50 &&
            !RegExp(r'^\d+$').hasMatch(line1) &&
            !RegExp(r'^\d+$').hasMatch(line2) &&
            !RegExp(r'^[A-Z]{1,3}\d{4,}$').hasMatch(line1) &&
            !RegExp(r'^[A-Z]{1,3}\d{4,}$').hasMatch(line2)) {
          // Combine them
          final combinedName = '$line1 $line2';
          // Validate it looks like a name (contains Arabic, reasonable length)
          if (combinedName.length >= 5 && combinedName.length <= 80) {
            return combinedName;
          }
        }
      }
    }
    return null;
  }
  
  /// Extract multi-line address (addresses can span multiple lines)
  /// Example: "٩ ش عبد القادر - الحكماء" on one line, "الزقازيق ثان - الشرقية" on next
  static String? _extractMultiLineAddress(List<String> lines) {
    // Look for consecutive lines with Arabic text that form an address
    for (int i = 0; i < lines.length - 1; i++) {
      final line1 = lines[i].trim();
      final line2 = lines[i + 1].trim();
      
      // Both lines should contain Arabic characters
      final hasArabic1 = RegExp(r'[أ-ي]').hasMatch(line1);
      final hasArabic2 = RegExp(r'[أ-ي]').hasMatch(line2);
      
      if (hasArabic1 && hasArabic2) {
        // Check if they look like address parts (contain location indicators, reasonable length)
        final combined = '$line1 $line2';
        final hasLocationIndicator = RegExp(r'(ش|شارع|طريق|محافظة|مدينة|قرية|حي|منطقة|ثان)').hasMatch(combined);
        
        if (hasLocationIndicator &&
            combined.length >= 10 && combined.length <= 150 &&
            !RegExp(r'^\d{14}$').hasMatch(line1) &&
            !RegExp(r'^\d{14}$').hasMatch(line2) &&
            !RegExp(r'^[A-Z]{1,3}\d{4,}$').hasMatch(line1) &&
            !RegExp(r'^[A-Z]{1,3}\d{4,}$').hasMatch(line2)) {
          return combined;
        }
      }
    }
    return null;
  }
  
  /// Extract birth location/address from center-right second section
  /// Birth location is typically in the middle section, below the name
  /// Example: "٩ ش عبد القادر - الحكماء الزقازيق ثان - الشرقية"
  static String? extractBirthLocation(String text) {
    // First convert Arabic-Indic digits to Western (for addresses like "٩ ش")
    String textWithWesternDigits = convertArabicIndicToWestern(text);
    
    // Extract text blocks by position
    final blocks = extractTextBlocksByPosition(textWithWesternDigits);
    
    // Birth location is in the middle section (center-right, second part)
    final middleSection = blocks['middle']!;
    
    // Also check top section (address might be near the name)
    final topSection = blocks['top']!;
    final allCandidateLines = [...topSection, ...middleSection];
    
    // Common location indicators to look for
    final locationIndicators = [
      'ش', 'شارع', 'street', 'st', 'طريق', 'road', 'rd',
      'محافظة', 'governorate', 'محافظ', 'governor',
      'مدينة', 'city', 'قرية', 'village', 'مركز', 'center',
      'حي', 'district', 'منطقة', 'area', 'zone',
      'ثان', 'than', 'first', 'second', 'اول', 'ثاني',
    ];
    
    final List<Map<String, dynamic>> potentialLocations = [];
    
    // Exclude words that are not locations
    final excludeWords = [
      'اسم', 'name', 'الاسم', 'the name',
      'رقم', 'number', 'الرقم', 'the number',
      'تاريخ', 'date', 'التاريخ', 'the date',
      'جنس', 'gender', 'الجنس', 'the gender',
      'ذكر', 'male', 'أنثى', 'female',
    ];
    
    // Try to find multi-line addresses first
    String? multiLineAddress = _extractMultiLineAddress(allCandidateLines);
    if (multiLineAddress != null) {
      return multiLineAddress;
    }
    
    for (int i = 0; i < allCandidateLines.length; i++) {
      final line = allCandidateLines[i].trim();
      
      // Skip if it's just numbers, dates, or too short
      if (RegExp(r'^[\d\s]+$').hasMatch(line)) continue;
      if (RegExp(r'\d{2}[/-]\d{2}[/-]\d{4}').hasMatch(line)) continue;
      if (RegExp(r'^\d{14}$').hasMatch(line)) continue;
      if (line.length < 5) continue; // Locations are usually longer
      
      // Check if it contains Arabic or English characters
      final hasArabic = RegExp(r'[أ-ي]').hasMatch(line);
      final hasEnglish = RegExp(r'[a-zA-Z]').hasMatch(line);
      
      if (hasArabic || hasEnglish) {
        // Check if it contains excluded words
        bool shouldExclude = false;
        final lowerLine = line.toLowerCase();
        for (final word in excludeWords) {
          if (lowerLine.contains(word.toLowerCase())) {
            shouldExclude = true;
            break;
          }
        }
        
        if (!shouldExclude) {
          // Check if it contains location indicators
          bool hasLocationIndicator = false;
          for (final indicator in locationIndicators) {
            if (lowerLine.contains(indicator.toLowerCase())) {
              hasLocationIndicator = true;
              break;
            }
          }
          
          // Calculate confidence score
          double confidence = 0.4;
          if (hasArabic) confidence += 0.3; // Arabic locations are more reliable
          if (hasLocationIndicator) confidence += 0.3; // Boost if contains location words
          // Boost for addresses with multiple parts (street, city, governorate)
          final wordCount = line.split(RegExp(r'[\s-]+')).length;
          if (wordCount >= 3 && wordCount <= 10) confidence += 0.15; // Full addresses typically have 3-10 parts
          if (line.length >= 10 && line.length <= 150) confidence += 0.1;
          
          potentialLocations.add({
            'location': line,
            'confidence': confidence,
            'isArabic': hasArabic,
            'hasIndicator': hasLocationIndicator,
            'length': line.length,
            'position': i,
          });
        }
      }
    }
    
    if (potentialLocations.isEmpty) return null;
    
    // Sort by confidence (with location indicator first, then Arabic, then by confidence)
    potentialLocations.sort((a, b) {
      // Prioritize lines with location indicators
      if (a['hasIndicator'] as bool && !(b['hasIndicator'] as bool)) return -1;
      if (!(a['hasIndicator'] as bool) && b['hasIndicator'] as bool) return 1;
      // Prioritize Arabic
      if (a['isArabic'] as bool && !(b['isArabic'] as bool)) return -1;
      if (!(a['isArabic'] as bool) && b['isArabic'] as bool) return 1;
      // Then by confidence
      final confDiff = (b['confidence'] as double).compareTo(a['confidence'] as double);
      if (confDiff != 0) return confDiff;
      // Finally by position
      return (a['position'] as int).compareTo(b['position'] as int);
    });
    
    return potentialLocations.first['location'] as String;
  }
}

// Enum for image source (in real app, use image_picker package)
enum ImageSource { camera, gallery }

// Permission helper functions
class PermissionHelper {
  /// Request camera permission and return true if granted
  static Future<bool> requestCameraPermission() async {
    if (kIsWeb) return true; // Web doesn't need runtime permissions
    
    final status = await Permission.camera.request();
    if (status.isGranted) {
      return true;
    } else if (status.isPermanentlyDenied) {
      // Show dialog to open app settings
      return false;
    }
    return false;
  }
  
  /// Request storage/photos permission and return true if granted
  static Future<bool> requestStoragePermission() async {
    if (kIsWeb) return true; // Web doesn't need runtime permissions
    
    // For Android 13+ (API 33+), use photos permission
    if (Platform.isAndroid) {
      final androidInfo = await Permission.photos.status;
      if (androidInfo.isGranted) {
        return true;
      }
      
      // Request photos permission for Android 13+
      final photosStatus = await Permission.photos.request();
      if (photosStatus.isGranted) {
        return true;
      }
      
      // Fallback to storage permission for older Android versions
      final storageStatus = await Permission.storage.request();
      return storageStatus.isGranted;
    } else if (Platform.isIOS) {
      final status = await Permission.photos.request();
      return status.isGranted;
    }
    
    return false;
  }
  
  /// Show dialog to open app settings if permission is permanently denied
  static Future<void> showPermissionDeniedDialog(BuildContext context, String message) async {
    if (!context.mounted) return;
    
    await showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(AppLanguage.translate('Permission Required')),
        content: Text(message),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(AppLanguage.translate('Cancel')),
          ),
          TextButton(
            onPressed: () {
              Navigator.pop(context);
              openAppSettings();
            },
            child: Text(AppLanguage.translate('Open Settings')),
          ),
        ],
      ),
    );
  }
}

// NFC Helper for detecting and reading NFC cards
// Uses flutter_nfc_reader for NFC tag detection and reading
class NFCHelper {
  /// Check if NFC is available on the device
  static Future<bool> isNFCAvailable() async {
    if (kIsWeb) return false;
    
    try {
      final availability = await FlutterNfcReader.checkNFCAvailability();
      return availability == NFCAvailability.available;
    } catch (e) {
      print('Error checking NFC availability: $e');
      return false;
    }
  }
  
  /// Check if NFC is enabled on the device
  static Future<bool> isNFCEnabled() async {
    if (kIsWeb) return false;
    
    try {
      final availability = await FlutterNfcReader.checkNFCAvailability();
      return availability == NFCAvailability.available;
    } catch (e) {
      return false;
    }
  }
  
  /// Helper method to extract tag ID from tag data
  static String? _extractTagId(Map<String, dynamic> data) {
    // Try to find identifier in various places
    for (var key in ['id', 'identifier', 'serial', 'uid']) {
      if (data.containsKey(key)) {
        final value = data[key];
        if (value is List<int> && value.isNotEmpty) {
          return value.map((e) => e.toRadixString(16).padLeft(2, '0')).join(':').toUpperCase();
        } else if (value is String && value.isNotEmpty) {
          return value.toUpperCase();
        }
      }
    }
    // Recursively search in nested maps
    for (var value in data.values) {
      if (value is Map) {
        final result = _extractTagId(value as Map<String, dynamic>);
        if (result != null) return result;
      }
    }
    return null;
  }
  
  /// Helper method to build tag detail row
  static Widget _buildTagDetailRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 100,
            child: Text(
              '$label:',
              style: TextStyle(
                fontWeight: FontWeight.bold,
                fontSize: 12,
                color: Colors.grey[700],
              ),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: const TextStyle(
                fontSize: 12,
                fontFamily: 'monospace',
              ),
            ),
          ),
        ],
      ),
    );
  }
  
  /// Start NFC tag reading session
  /// Returns the NFC tag ID when detected
  static StreamSubscription<NfcData>? _nfcSubscription;
  static String? _lastStreamTagId; // Track last tag ID at stream level to prevent duplicates
  static DateTime? _lastStreamTagTime; // Track last tag detection time at stream level
  static const Duration _streamTagCooldown = Duration(milliseconds: 2000); // Cooldown at stream level
  
  /// Mask NFC tag ID for display (shows only last 4 characters)
  /// Example: "NFC_1234567890" -> "NFC_****7890"
  static String maskNfcTagId(String tagId) {
    if (tagId.isEmpty) return tagId;
    
    // If tag ID has "NFC_" prefix, mask the part after it
    if (tagId.toUpperCase().startsWith('NFC_')) {
      final prefix = tagId.substring(0, 4); // "NFC_"
      final rest = tagId.substring(4);
      if (rest.length <= 4) {
        return tagId; // Too short to mask
      }
      // Show last 4 characters, mask the rest
      final visiblePart = rest.substring(rest.length - 4);
      return '$prefix${'*' * (rest.length - 4)}$visiblePart';
    } else {
      // No prefix, just mask all but last 4 characters
      if (tagId.length <= 4) {
        return tagId; // Too short to mask
      }
      final visiblePart = tagId.substring(tagId.length - 4);
      return '${'*' * (tagId.length - 4)}$visiblePart';
    }
  }
  
  static Future<String?> startNFCSession({
    required BuildContext context,
    Function(String)? onTagDetected,
    Function(String)? onError,
    ValueNotifier<Map<String, dynamic>?>? tagDetailsNotifier,
  }) async {
    if (kIsWeb) {
      if (onError != null) onError('NFC is not supported on web');
      return null;
    }
    
    try {
      // Check if NFC is available
      final availability = await FlutterNfcReader.checkNFCAvailability();
      if (availability != NFCAvailability.available) {
        final message = availability == NFCAvailability.disabled
            ? AppLanguage.translate('NFC is disabled. Please enable it in your device settings.')
            : AppLanguage.translate('NFC is not available on this device');
        if (onError != null) {
          onError(message);
        } else if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(message),
              backgroundColor: Colors.orange,
            ),
          );
        }
        return null;
      }
      
      print('NFC: Starting NFC session (direct mode - no dialog)...');
      
      // Cancel any existing subscription first
      await _nfcSubscription?.cancel();
      
      // Enable reader mode in background (non-blocking)
      print('NFC: Enabling reader mode (non-blocking)...');
      FlutterNfcReader.enableReaderMode().then((result) {
        print('NFC: Reader mode enabled successfully, status: ${result.status}');
      }).catchError((e) {
        print('NFC: ⚠️ enableReaderMode() error (non-critical): $e');
        // Continue anyway - the stream might still work
      });
      
      // Give reader mode a moment to initialize, then set up stream listener
      await Future.delayed(const Duration(milliseconds: 500));
      
      // Set up stream listener - directly fill text field when tag detected
      print('NFC: Setting up stream listener (direct to text field, continuous mode)...');
      _nfcSubscription = FlutterNfcReader.onTagDiscovered().listen(
        (NfcData nfcData) {
          print('NFC: ✅ Tag discovered! ID: ${nfcData.id}');
          
          // Check if we have a valid tag ID
          if (nfcData.id != null && nfcData.id!.isNotEmpty) {
            final tagId = nfcData.id!;
            final now = DateTime.now();
            
            // Duplicate detection at stream level - prevent processing same tag multiple times
            if (_lastStreamTagId == tagId) {
              if (_lastStreamTagTime != null && 
                  now.difference(_lastStreamTagTime!) < _streamTagCooldown) {
                print('NFC: ⏭️ Stream: Same tag ID detected within cooldown, ignoring: $tagId');
                return; // Ignore duplicate at stream level
              }
            }
            
            // Update stream-level tracking
            _lastStreamTagId = tagId;
            _lastStreamTagTime = now;
            
            print('NFC: ✅ Tag ID detected: $tagId');
            
            // Directly call onTagDetected callback on main thread to fill text field
            if (onTagDetected != null) {
              // Use SchedulerBinding to ensure this runs on the main thread
              WidgetsBinding.instance.addPostFrameCallback((_) {
                onTagDetected(tagId);
                print('NFC: ✅ Tag ID set in text field: $tagId');
              });
            }
            
            // Stop current session and restart to listen for next card
            // Don't cancel subscription here - let it restart
            FlutterNfcReader.stop();
            FlutterNfcReader.disableReaderMode();
            
            // Restart NFC detection after a longer delay to prevent re-detection of same tag
            Future.delayed(const Duration(milliseconds: 1500), () async {
              try {
                // Reset stream-level tracking before restarting
                _lastStreamTagId = null;
                _lastStreamTagTime = null;
                await FlutterNfcReader.enableReaderMode();
                print('NFC: ✅ Restarted reader mode for next card detection');
              } catch (e) {
                print('NFC: ⚠️ Error restarting reader mode: $e');
              }
            });
          } else if (nfcData.status == NFCStatus.error) {
            print('NFC: Error reading tag: ${nfcData.error}');
                
                if (onError != null && context.mounted) {
              WidgetsBinding.instance.addPostFrameCallback((_) {
                onError(nfcData.error ?? 'Error reading NFC tag');
              });
            }
            
            // Restart NFC detection after error
            Future.delayed(const Duration(milliseconds: 300), () async {
              try {
                await FlutterNfcReader.enableReaderMode();
                print('NFC: ✅ Restarted reader mode after error');
              } catch (e) {
                print('NFC: ⚠️ Error restarting reader mode: $e');
              }
            });
          }
        },
        onError: (error) {
          print('NFC: Stream error: $error');
          // Don't cancel subscription - restart reader mode instead
          FlutterNfcReader.stop();
          FlutterNfcReader.disableReaderMode();
              
              if (onError != null && context.mounted) {
            WidgetsBinding.instance.addPostFrameCallback((_) {
              onError('Error: ${error.toString()}');
            });
          }
          
          // Restart NFC detection after error
          Future.delayed(const Duration(milliseconds: 300), () async {
            try {
              await FlutterNfcReader.enableReaderMode();
              print('NFC: ✅ Restarted reader mode after stream error');
            } catch (e) {
              print('NFC: ⚠️ Error restarting reader mode: $e');
            }
          });
        },
        cancelOnError: false,
      );
      
      print('NFC: Stream listener active - waiting for tags (continuous mode, no dialog, direct to text field)...');
      
      // Return null immediately - the callback will handle filling the text field
      // The stream will continue listening for new tags
      return null;
    } catch (e, stackTrace) {
      print('NFC: Error reading NFC tag: $e');
      print('NFC: Stack trace: $stackTrace');
      
      // Clean up
      await _nfcSubscription?.cancel();
      await FlutterNfcReader.stop();
      await FlutterNfcReader.disableReaderMode();
      
      final errorMessage = e.toString();
          if (onError != null && context.mounted) {
        onError('Error: $errorMessage');
          } else if (context.mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('NFC Error: $errorMessage'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 3),
          ),
        );
      }
      return null;
    }
  }
  
  /// Stop NFC session
  static Future<void> stopNFCSession() async {
    if (kIsWeb) return;
    
    try {
      await _nfcSubscription?.cancel();
      await FlutterNfcReader.stop();
      await FlutterNfcReader.disableReaderMode();
      _nfcSubscription = null;
      _lastStreamTagId = null; // Reset stream-level tracking
      _lastStreamTagTime = null;
    } catch (e) {
      print('Error stopping NFC session: $e');
    }
  }
}

// Shared admin requests storage (in real app, this would be a database)
class AdminRequestStorage {
  static final List<Admin> _adminRequests = [];
  
  static List<Admin> get adminRequests => List.unmodifiable(_adminRequests);
  
  static void addRequest(Admin admin) {
    _adminRequests.add(admin);
  }
  
  static void removeRequest(String adminId) {
    _adminRequests.removeWhere((a) => a.id == adminId);
  }
  
  static void clear() {
    _adminRequests.clear();
  }
}

// Queue Point Model
class DistributionArea {
  final String id;
  final String country;
  final String governorate;
  final String city;
  final String areaName;

  DistributionArea({
    required this.id,
    required this.country,
    required this.governorate,
    required this.city,
    required this.areaName,
  });

  String get fullName => '$country > $governorate > $city > $areaName';
}

// Admin Model
class Admin {
  final String id;
  final String country;
  final String governorate;
  final String city;
  final String distributionPoint;
  final String? distributionPointDescription;
  final String fullName;
  final String mobile;
  final String? password;
  final String? role; // 'Super_Admin', 'Admin', 'Q_Admin', or null
  final String notes;
  final String? reference;
  final String status; // pending, active, banned
  final bool isRequestedByGuest;
  final DateTime createdAt;

  Admin({
    required this.id,
    required this.country,
    required this.governorate,
    required this.city,
    required this.distributionPoint,
    this.distributionPointDescription,
    required this.fullName,
    required this.mobile,
    this.password,
    this.role,
    required this.notes,
    this.reference,
    required this.status,
    required this.isRequestedByGuest,
    required this.createdAt,
  });
  
  bool get isSuperAdmin => role == 'Super_Admin';
  bool get isAdmin => role == 'Admin';
  bool get isQAdmin => role == 'Q_Admin';

  Admin copyWith({
    String? id,
    String? country,
    String? governorate,
    String? city,
    String? distributionPoint,
    String? distributionPointDescription,
    String? fullName,
    String? mobile,
    String? password,
    String? role,
    String? notes,
    String? reference,
    String? status,
    bool? isRequestedByGuest,
    DateTime? createdAt,
  }) {
    return Admin(
      id: id ?? this.id,
      country: country ?? this.country,
      governorate: governorate ?? this.governorate,
      city: city ?? this.city,
      distributionPoint: distributionPoint ?? this.distributionPoint,
      distributionPointDescription: distributionPointDescription ?? this.distributionPointDescription,
      fullName: fullName ?? this.fullName,
      mobile: mobile ?? this.mobile,
      password: password ?? this.password,
      role: role ?? this.role,
      notes: notes ?? this.notes,
      reference: reference ?? this.reference,
      status: status ?? this.status,
      isRequestedByGuest: isRequestedByGuest ?? this.isRequestedByGuest,
      createdAt: createdAt ?? this.createdAt,
    );
  }
}

// Queue Model
class Queue {
  final String name;
  final String queueManager;
  final String country;
  final String governorate;
  final String city;
  final String queuePointName;
  final String distributionArea;
  final String queueType;
  final DateTime fromDate;
  final DateTime toDate;
  final TimeOfDay fromTime;
  final TimeOfDay toTime;
  final String unitName;
  final int numberOfAvailableUnits;
  final int estimatedQueueSize;
  final bool directServe;
  final List<String> priority;
  final String status;
  final String? subtitle;
  final bool isStarted;
  final bool isCompleted;
  final bool isSuspended;

  Queue({
    required this.name,
    required this.queueManager,
    required this.country,
    required this.governorate,
    required this.city,
    required this.queuePointName,
    required this.distributionArea,
    required this.queueType,
    required this.fromDate,
    required this.toDate,
    required this.fromTime,
    required this.toTime,
    required this.unitName,
    required this.numberOfAvailableUnits,
    required this.estimatedQueueSize,
    required this.directServe,
    required this.priority,
    required this.status,
    this.subtitle,
    this.isStarted = false,
    this.isCompleted = false,
    this.isSuspended = false,
  });

  Queue copyWith({
    String? name,
    String? queueManager,
    String? country,
    String? governorate,
    String? city,
    String? queuePointName,
    String? distributionArea,
    String? queueType,
    DateTime? fromDate,
    DateTime? toDate,
    TimeOfDay? fromTime,
    TimeOfDay? toTime,
    String? unitName,
    int? numberOfAvailableUnits,
    int? estimatedQueueSize,
    bool? directServe,
    List<String>? priority,
    String? status,
    String? subtitle,
    bool? isStarted,
    bool? isCompleted,
    bool? isSuspended,
  }) {
    return Queue(
      name: name ?? this.name,
      queueManager: queueManager ?? this.queueManager,
      country: country ?? this.country,
      governorate: governorate ?? this.governorate,
      city: city ?? this.city,
      queuePointName: queuePointName ?? this.queuePointName,
      distributionArea: distributionArea ?? this.distributionArea,
      queueType: queueType ?? this.queueType,
      fromDate: fromDate ?? this.fromDate,
      toDate: toDate ?? this.toDate,
      fromTime: fromTime ?? this.fromTime,
      toTime: toTime ?? this.toTime,
      unitName: unitName ?? this.unitName,
      numberOfAvailableUnits: numberOfAvailableUnits ?? this.numberOfAvailableUnits,
      estimatedQueueSize: estimatedQueueSize ?? this.estimatedQueueSize,
      directServe: directServe ?? this.directServe,
      priority: priority ?? this.priority,
      status: status ?? this.status,
      subtitle: subtitle ?? this.subtitle,
      isStarted: isStarted ?? this.isStarted,
      isCompleted: isCompleted ?? this.isCompleted,
      isSuspended: isSuspended ?? this.isSuspended,
    );
  }

  String get queuePoint {
    return '$country > $governorate > $city > $queuePointName';
  }

  String get displayDateRange {
    return '${fromDate.day}/${fromDate.month}/${fromDate.year} - ${toDate.day}/${toDate.month}/${toDate.year}';
  }

  String get displayTimeRange {
    // Format time in 12-hour format with AM/PM
    String formatTime(TimeOfDay time) {
      final hour = time.hour == 0 ? 12 : (time.hour > 12 ? time.hour - 12 : time.hour);
      final minute = time.minute.toString().padLeft(2, '0');
      final period = time.hour < 12 ? 'AM' : 'PM';
      return '$hour:$minute $period';
    }
    return '${formatTime(fromTime)} - ${formatTime(toTime)}';
  }

  // Helper methods for Multi Day Queue
  bool get isMultiDay => queueType == 'Multi Day';
  bool get isSingleDay => queueType == 'Single Day';

  String? validateDateRange() {
    if (toDate.isBefore(fromDate)) {
      return 'To date must be greater than or equal to from date';
    }
    return null;
  }

  String? validateTimeRange() {
    final fromMinutes = fromTime.hour * 60 + fromTime.minute;
    final toMinutes = toTime.hour * 60 + toTime.minute;
    if (toMinutes <= fromMinutes) {
      return 'To time must be greater than from time';
    }
    return null;
  }

  String? validate() {
    // Validate queue type
    if (queueType != 'Single Day' && queueType != 'Multi Day') {
      return 'Queue type must be either "Single Day" or "Multi Day"';
    }

    // Validate date range
    final dateError = validateDateRange();
    if (dateError != null) return dateError;

    // Validate time range
    final timeError = validateTimeRange();
    if (timeError != null) return timeError;

    // Validate Multi Day specific rules
    if (isMultiDay) {
      if (numberOfAvailableUnits <= 1) {
        return 'Number of available units must be greater than 1';
      }
    }

    return null;
  }

  bool isCurrentlyActive() {
    final now = DateTime.now();
    final currentDate = DateTime(now.year, now.month, now.day);
    final from = DateTime(fromDate.year, fromDate.month, fromDate.day);
    final to = DateTime(toDate.year, toDate.month, toDate.day);
    
    if (currentDate.isBefore(from) || currentDate.isAfter(to)) {
      return false;
    }

    final currentTime = TimeOfDay.fromDateTime(now);
    final fromMinutes = fromTime.hour * 60 + fromTime.minute;
    final toMinutes = toTime.hour * 60 + toTime.minute;
    final currentMinutes = currentTime.hour * 60 + currentTime.minute;

    return currentMinutes >= fromMinutes && currentMinutes <= toMinutes;
  }

  int get durationInDays {
    return toDate.difference(fromDate).inDays + 1;
  }
}

// Beneficiary Model
class Beneficiary {
  final String id;
  final String distributionArea;
  final String initialAssignedQueuePoint;
  final String type;
  final String? idCopyPath;
  final String gender;
  final String name;
  final String idNumber;
  final String? mobileNumber;
  final bool isEntity;
  final String? entityName;
  final String numberOfUnits;
  final String? nfcPreprintedCode;
  final String? photoPath;
  final String status;
  final DateTime? birthDate;
  final int? queueNumber;
  final bool isServed;
  final int unitsTaken;
  final String? createdBy;

  Beneficiary({
    required this.id,
    required this.distributionArea,
    required this.initialAssignedQueuePoint,
    required this.type,
    this.idCopyPath,
    required this.gender,
    required this.name,
    required this.idNumber,
    this.mobileNumber,
    required this.isEntity,
    this.entityName,
    required this.numberOfUnits,
    this.nfcPreprintedCode,
    this.photoPath,
    required this.status,
    this.birthDate,
    this.queueNumber,
    this.isServed = false,
    this.unitsTaken = 0,
    this.createdBy,
  });

  Beneficiary copyWith({
    String? id,
    String? distributionArea,
    String? initialAssignedQueuePoint,
    String? type,
    String? idCopyPath,
    String? gender,
    String? name,
    String? idNumber,
    String? mobileNumber,
    bool? isEntity,
    String? entityName,
    String? numberOfUnits,
    String? nfcPreprintedCode,
    String? photoPath,
    String? status,
    DateTime? birthDate,
    int? queueNumber,
    bool? isServed,
    int? unitsTaken,
    String? createdBy,
  }) {
    return Beneficiary(
      id: id ?? this.id,
      distributionArea: distributionArea ?? this.distributionArea,
      initialAssignedQueuePoint: initialAssignedQueuePoint ?? this.initialAssignedQueuePoint,
      type: type ?? this.type,
      idCopyPath: idCopyPath ?? this.idCopyPath,
      gender: gender ?? this.gender,
      name: name ?? this.name,
      idNumber: idNumber ?? this.idNumber,
      mobileNumber: mobileNumber ?? this.mobileNumber,
      isEntity: isEntity ?? this.isEntity,
      entityName: entityName ?? this.entityName,
      numberOfUnits: numberOfUnits ?? this.numberOfUnits,
      nfcPreprintedCode: nfcPreprintedCode ?? this.nfcPreprintedCode,
      photoPath: photoPath ?? this.photoPath,
      status: status ?? this.status,
      birthDate: birthDate ?? this.birthDate,
      queueNumber: queueNumber ?? this.queueNumber,
      isServed: isServed ?? this.isServed,
      unitsTaken: unitsTaken ?? this.unitsTaken,
      createdBy: createdBy ?? this.createdBy,
    );
  }
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // Run app immediately - don't wait for anything
  runApp(const MyApp());
  
  // Initialize Firebase in background (completely non-blocking)
  // This allows the app to start immediately
  _initializeFirebaseInBackground();
}

/// Initialize Firebase completely in background - doesn't block app startup
Future<void> _initializeFirebaseInBackground() async {
  try {
    print('🔥 Starting Firebase initialization in background...');
    
    // Initialize Firebase core (this can take time on first load)
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    ).timeout(
      const Duration(seconds: 30),
      onTimeout: () {
        print('⚠️ Firebase.initializeApp timed out (non-critical)');
        throw TimeoutException('Firebase initialization timed out');
      },
    );
    print('✅ Firebase.initializeApp completed');
    
    // Initialize Firebase services (fast - just assigns instances)
    await FirebaseService.initialize();
    print('✅ FirebaseService.initialize completed - Firebase is ready!');
    
    // Now initialize collections in background (after Firebase is ready)
    _initializeFirestoreCollectionsInBackground();
      } catch (e, stackTrace) {
    print('⚠️ Firebase initialization error (non-critical, app continues): $e');
        print('Stack trace: $stackTrace');
    // Continue anyway - app can still run, Firebase will retry on first use
  }
}

/// Initialize Firestore collections in background without blocking the app
/// This runs after Firebase is ready and doesn't block anything
Future<void> _initializeFirestoreCollectionsInBackground() async {
  // Small delay to ensure Firebase is fully ready
  await Future.delayed(const Duration(milliseconds: 200));
  
  if (!FirebaseService.isInitialized) {
      print('⚠️ Firebase not initialized, skipping collections setup');
    return;
  }
  
  // Run collections setup completely in background - don't await
  // This ensures it never blocks the app
  Future(() async {
      try {
        print('🚀 Starting Firestore collections setup in background...');
        
        // Run collections setup and roles initialization in parallel with timeout
        await Future.wait([
          FirebaseCollectionsSetup.setupAllCollections()
              .timeout(const Duration(seconds: 20))
              .catchError((e) {
            print('⚠️ Collections setup error (non-critical): $e');
            return null;
          }),
          RoleService.initializeDefaultRoles()
              .timeout(const Duration(seconds: 20))
              .catchError((e) {
            print('⚠️ Roles initialization error (non-critical): $e');
            return null;
          }),
        ], eagerError: false);
        
        print('✅ Firebase collections and roles initialized in background!');
  } catch (e, stackTrace) {
        print('⚠️ Background collections setup error (non-critical): $e');
        // Continue anyway - collections might already exist
      }
    });
  // Don't await - let it run in background
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return ValueListenableBuilder<String>(
      valueListenable: AppLanguage.languageNotifier,
      builder: (context, language, child) {
    return MaterialApp(
          title: 'EQMS App',
          debugShowCheckedModeBanner: false,
          locale: AppLanguage.isArabic ? const Locale('ar', 'SA') : const Locale('en', 'US'),
          builder: (context, child) {
            return Directionality(
              textDirection: AppLanguage.textDirection,
              child: child!,
            );
          },
      theme: ThemeData(
            primarySwatch: Colors.teal,
            primaryColor: const Color(0xFF81CF01),
            scaffoldBackgroundColor: Colors.white,
            appBarTheme: const AppBarTheme(
              backgroundColor: Color(0xFF81CF01),
              foregroundColor: Colors.white,
            ),
          ),
          home: const OnboardingScreen(),
        );
      },
    );
  }
}

// Onboarding Screen - Shows logo before login
class OnboardingScreen extends StatefulWidget {
  const OnboardingScreen({super.key});

  @override
  State<OnboardingScreen> createState() => _OnboardingScreenState();
}

class _OnboardingScreenState extends State<OnboardingScreen> with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _fadeAnimation;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 1500),
      vsync: this,
    );

    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _animationController, curve: Curves.easeIn),
    );

    _scaleAnimation = Tween<double>(begin: 0.5, end: 1.0).animate(
      CurvedAnimation(parent: _animationController, curve: Curves.easeOut),
    );

    _animationController.forward();

    // Navigate to login screen after 3 seconds
    Future.delayed(const Duration(seconds: 3), () {
      if (mounted) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(builder: (context) => const LoginScreen()),
        );
      }
    });
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [
              Color(0xFF00695C), // Dark teal/blue-green at top
              Color(0xFF00897B), // Medium teal
              Color(0xFF00ACC1), // Lighter teal/cyan
              Color(0xFF26A69A), // Light teal
              Color(0xFF66BB6A), // Light green
              Color(0xFF81CF01), // Bright lime green at bottom
            ],
            stops: [0.0, 0.2, 0.4, 0.6, 0.8, 1.0],
          ),
        ),
        child: Center(
        child: FadeTransition(
          opacity: _fadeAnimation,
          child: ScaleTransition(
            scale: _scaleAnimation,
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                  // Logo with circle shape and shadow for better visibility
                Container(
                  width: 200,
                  height: 200,
                  decoration: BoxDecoration(
                      color: Colors.white,
                      shape: BoxShape.circle,
                      boxShadow: [
                        BoxShadow(
                          color: Colors.black.withOpacity(0.3),
                          blurRadius: 20,
                          spreadRadius: 5,
                          offset: const Offset(0, 10),
                        ),
                      ],
                    ),
                    padding: const EdgeInsets.all(20),
                  child: Image.asset(
                    'assets/images/et3am_app_logo.jpeg',
                    fit: BoxFit.contain,
                    errorBuilder: (context, error, stackTrace) {
                      // Fallback if logo image is not found - show text logo
                        return Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            // Arabic text "إطعام" with Wi-Fi icon representation
                            Row(
                              mainAxisAlignment: MainAxisAlignment.center,
                              textDirection: TextDirection.rtl,
                              children: [
                                // إ
                                Text(
                                  'إ',
                                  style: TextStyle(
                                    fontSize: 48,
                                    fontWeight: FontWeight.bold,
                                          color: const Color(0xFF00695C),
                                          shadows: [
                                            Shadow(
                                              color: Colors.black.withOpacity(0.2),
                                              offset: const Offset(1, 1),
                                              blurRadius: 2,
                                            ),
                                          ],
                                  ),
                                ),
                                // ط
                                Text(
                                  'ط',
                                  style: TextStyle(
                                    fontSize: 48,
                                    fontWeight: FontWeight.bold,
                                          color: const Color(0xFF00695C),
                                          shadows: [
                                            Shadow(
                                              color: Colors.black.withOpacity(0.2),
                                              offset: const Offset(1, 1),
                                              blurRadius: 2,
                                            ),
                                          ],
                                  ),
                                ),
                                // ع (replaced with Wi-Fi icon)
                                Container(
                                  width: 40,
                                  height: 40,
                                  decoration: BoxDecoration(
                                    color: const Color(0xFF81CF01),
                                    borderRadius: BorderRadius.circular(8),
                                          boxShadow: [
                                            BoxShadow(
                                              color: Colors.black.withOpacity(0.2),
                                              blurRadius: 5,
                                              offset: const Offset(0, 2),
                                            ),
                                          ],
                                  ),
                                  child: const Icon(
                                    Icons.wifi,
                                    color: Colors.white,
                                    size: 24,
                                  ),
                                ),
                                // م
                                Text(
                                  'م',
                                  style: TextStyle(
                                    fontSize: 48,
                                    fontWeight: FontWeight.bold,
                                          color: const Color(0xFF00695C),
                                          shadows: [
                                            Shadow(
                                              color: Colors.black.withOpacity(0.2),
                                              offset: const Offset(1, 1),
                                              blurRadius: 2,
                                            ),
                                          ],
                                  ),
                                ),
                              ],
                            ),
                            const SizedBox(height: 8),
                            Text(
                              'Et\'am',
                              style: TextStyle(
                                fontSize: 24,
                                fontWeight: FontWeight.bold,
                                color: const Color(0xFF81CF01),
                                      shadows: [
                                        Shadow(
                                          color: Colors.black.withOpacity(0.2),
                                          offset: const Offset(1, 1),
                                          blurRadius: 2,
                            ),
                          ],
                        ),
                                  ),
                          ],
                      );
                    },
                  ),
                ),
                const SizedBox(height: 40),
                  // App name with better visibility
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                    decoration: BoxDecoration(
                      color: Colors.white.withOpacity(0.2),
                      borderRadius: BorderRadius.circular(30),
                      boxShadow: [
                        BoxShadow(
                          color: Colors.black.withOpacity(0.2),
                          blurRadius: 15,
                          spreadRadius: 2,
                          offset: const Offset(0, 5),
                        ),
                      ],
                    ),
                    child: Text(
                  'Et\'am',
                  style: TextStyle(
                        fontSize: 36,
                    fontWeight: FontWeight.bold,
                        color: Colors.white,
                        shadows: [
                          Shadow(
                            color: Colors.black.withOpacity(0.5),
                            offset: const Offset(2, 2),
                            blurRadius: 4,
                          ),
                          Shadow(
                            color: Colors.black.withOpacity(0.3),
                            offset: const Offset(0, 0),
                            blurRadius: 8,
                          ),
                        ],
                      ),
                    ),
                  ),
                  const SizedBox(height: 16),
                  // Subtitle with better visibility
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 8),
                    decoration: BoxDecoration(
                      color: Colors.white.withOpacity(0.15),
                      borderRadius: BorderRadius.circular(20),
                    ),
                    child: Text(
                      'Queue Management System',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.w600,
                        color: Colors.white,
                        shadows: [
                          Shadow(
                            color: Colors.black.withOpacity(0.5),
                            offset: const Offset(1, 1),
                            blurRadius: 3,
                          ),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

/// Initialization Progress Dialog with real-time updates
class _InitializationProgressDialog extends StatefulWidget {
  final ValueNotifier<int> progressNotifier;
  final ValueNotifier<String> messageNotifier;
  
  const _InitializationProgressDialog({
    required this.progressNotifier,
    required this.messageNotifier,
  });

  @override
  State<_InitializationProgressDialog> createState() => _InitializationProgressDialogState();
}

class _InitializationProgressDialogState extends State<_InitializationProgressDialog> {
  @override
  Widget build(BuildContext context) {
    return PopScope(
      canPop: false, // Prevent closing
      child: Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Icon(
                Icons.cloud_download,
                size: 48,
                color: Color(0xFF81CF01),
              ),
              const SizedBox(height: 16),
              Text(
                AppLanguage.translate('First-Time Setup'),
                style: const TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                  color: Color(0xFF1A237E),
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                AppLanguage.translate('Initializing app features for the first time.\nThis may take 30-40 seconds.'),
                textAlign: TextAlign.center,
                  style: TextStyle(
                  fontSize: 14,
                    color: Colors.grey[600],
                ),
              ),
              const SizedBox(height: 24),
              ValueListenableBuilder<String>(
                valueListenable: widget.messageNotifier,
                builder: (context, message, _) {
                  return Text(
                    message,
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      fontSize: 14,
                      fontWeight: FontWeight.w500,
                      color: Colors.grey[700],
                    ),
                  );
                },
              ),
              const SizedBox(height: 16),
              ValueListenableBuilder<int>(
                valueListenable: widget.progressNotifier,
                builder: (context, progress, _) {
                  return Column(
                    children: [
                      LinearProgressIndicator(
                        value: progress / 100,
                        backgroundColor: Colors.grey[200],
                        valueColor: const AlwaysStoppedAnimation<Color>(Color(0xFF81CF01)),
                        minHeight: 8,
                        borderRadius: BorderRadius.circular(4),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        '$progress%',
                        style: const TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                          color: Color(0xFF81CF01),
                  ),
                ),
              ],
                  );
                },
            ),
            ],
          ),
        ),
      ),
    );
  }
}

class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key});

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _mobileController = TextEditingController();
  final _passwordController = TextEditingController();
  final _formKey = GlobalKey<FormState>();
  
  // Teal green color constant
  static const Color tealGreen = Color(0xFF81CF01);

  bool _isLoading = false;
  bool _passwordVisible = false;
  bool _isFirstTimeInit = false;
  bool _rememberMe = false;
  ValueNotifier<int>? _progressNotifier;
  ValueNotifier<String>? _messageNotifier;
  BuildContext? _dialogContext;

  @override
  void initState() {
    super.initState();
    _loadSavedCredentials();
  }

  @override
  void dispose() {
    _mobileController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  /// Load saved login credentials if "Remember Me" was checked
  Future<void> _loadSavedCredentials() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final savedMobile = prefs.getString('saved_mobile');
      final savedPassword = prefs.getString('saved_password');
      final rememberMe = prefs.getBool('remember_me') ?? false;
      
      if (rememberMe && savedMobile != null && savedPassword != null) {
        if (mounted) {
          setState(() {
            _mobileController.text = savedMobile;
            _passwordController.text = savedPassword;
            _rememberMe = true;
          });
        }
      }
    } catch (e) {
      print('Error loading saved credentials: $e');
    }
  }

  /// Save login credentials if "Remember Me" is checked
  Future<void> _saveCredentials(String mobile, String password) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      if (_rememberMe) {
        await prefs.setString('saved_mobile', mobile);
        await prefs.setString('saved_password', password);
        await prefs.setBool('remember_me', true);
      } else {
        await prefs.remove('saved_mobile');
        await prefs.remove('saved_password');
        await prefs.setBool('remember_me', false);
      }
    } catch (e) {
      print('Error saving credentials: $e');
    }
  }

  /// Show initialization progress dialog
  void _showInitializationProgress() {
    if (!mounted) return;
    
    _progressNotifier = ValueNotifier<int>(0);
    _messageNotifier = ValueNotifier<String>('Initializing...');
    
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (dialogContext) {
        _dialogContext = dialogContext;
        return _InitializationProgressDialog(
          progressNotifier: _progressNotifier!,
          messageNotifier: _messageNotifier!,
        );
      },
    );
  }

  /// Hide initialization progress dialog
  void _hideInitializationProgress() {
    if (!mounted) {
      // Clean up even if not mounted
      _progressNotifier?.dispose();
      _messageNotifier?.dispose();
      _progressNotifier = null;
      _messageNotifier = null;
      _dialogContext = null;
      return;
    }
    
    // Try multiple methods to ensure dialog closes
    bool dialogClosed = false;
    
    // Method 1: Try using stored dialog context first (most reliable)
    if (_dialogContext != null) {
      try {
        Navigator.of(_dialogContext!, rootNavigator: true).pop();
        _dialogContext = null;
        dialogClosed = true;
        print('✅ Dialog closed using stored context');
      } catch (e) {
        print('⚠️ Error closing with dialog context: $e');
      }
    }
    
    // Method 2: Use rootNavigator for mobile Safari compatibility
    if (!dialogClosed) {
      try {
        final navigator = Navigator.of(context, rootNavigator: true);
        if (navigator.canPop()) {
          navigator.pop();
          dialogClosed = true;
          print('✅ Dialog closed using rootNavigator');
        }
      } catch (e) {
        print('⚠️ Error closing with rootNavigator: $e');
      }
    }
    
    // Method 3: Try regular navigator
    if (!dialogClosed) {
      try {
        if (Navigator.of(context).canPop()) {
          Navigator.of(context).pop();
          dialogClosed = true;
          print('✅ Dialog closed using regular navigator');
        }
      } catch (e) {
        print('⚠️ Error closing with regular navigator: $e');
      }
    }
    
    // Clean up notifiers
    _progressNotifier?.dispose();
    _messageNotifier?.dispose();
    _progressNotifier = null;
    _messageNotifier = null;
    _dialogContext = null;
    
    if (!dialogClosed) {
      print('⚠️ Warning: Could not confirm dialog closure');
    }
  }

  /// Initialize Firebase with progress updates
  Future<void> _initializeFirebaseWithProgress() async {
    // Update progress: 10% - Starting initialization
    _updateProgress(10, AppLanguage.translate('Initializing Firebase connection...'));
    await Future.delayed(const Duration(milliseconds: 300));

    // Initialize Firebase core
    if (Firebase.apps.isEmpty) {
      _updateProgress(20, AppLanguage.translate('Connecting to Firebase servers...'));
      await Firebase.initializeApp(
        options: DefaultFirebaseOptions.currentPlatform,
      ).timeout(
        const Duration(seconds: 30),
        onTimeout: () {
          throw TimeoutException('Firebase initialization timed out');
        },
      );
    }
    
    _updateProgress(40, AppLanguage.translate('Setting up Firebase services...'));
    await Future.delayed(const Duration(milliseconds: 200));
    
    await FirebaseService.initialize().timeout(const Duration(seconds: 5));
    
    _updateProgress(60, AppLanguage.translate('Preparing app features...'));
    await Future.delayed(const Duration(milliseconds: 300));
    
    // Initialize collections in background (non-blocking)
    _updateProgress(75, AppLanguage.translate('Setting up database structure...'));
    _initializeFirestoreCollectionsInBackgroundForLogin();
    
    _updateProgress(90, AppLanguage.translate('Finalizing setup...'));
    await Future.delayed(const Duration(milliseconds: 300));
    
    _updateProgress(100, AppLanguage.translate('Setup complete!'));
    await Future.delayed(const Duration(milliseconds: 300));
    
    // Note: Dialog will be closed by caller to ensure proper timing
    print('✅ Initialization progress completed');
  }

  /// Update progress in dialog
  void _updateProgress(int percentage, String message) {
    if (_progressNotifier != null && _messageNotifier != null && mounted) {
      _progressNotifier!.value = percentage;
      _messageNotifier!.value = message;
    }
  }

  /// Initialize collections for login (lightweight version)
  void _initializeFirestoreCollectionsInBackgroundForLogin() {
    // Don't await - let it run in background
    Future(() async {
      try {
        // Only initialize critical collections for login
        await RoleService.initializeDefaultRoles()
            .timeout(const Duration(seconds: 15))
            .catchError((e) {
          print('⚠️ Roles initialization error (non-critical): $e');
          return null;
        });
      } catch (e) {
        print('⚠️ Background initialization error (non-critical): $e');
      }
    });
  }

  Future<void> _handleLogin() async {
    // Prevent multiple simultaneous login attempts
    if (_isLoading) {
      return;
    }

    if (!_formKey.currentState!.validate()) {
      return;
    }

    setState(() {
      _isLoading = true;
    });

    // Check if this is first-time initialization
    final needsInitialization = !FirebaseService.isInitialized;
    if (needsInitialization) {
      setState(() {
        _isFirstTimeInit = true;
      });
    }

    try {
      // Check if Firebase is initialized - if not, initialize with progress
      if (!FirebaseService.isInitialized) {
        print('⚠️ Firebase not initialized, starting first-time initialization...');
        
        // Show progress dialog for first-time initialization
        if (mounted && _isFirstTimeInit) {
          _showInitializationProgress();
        }
        
        try {
          // Initialize Firebase with progress updates - with maximum timeout
          await _initializeFirebaseWithProgress().timeout(
            const Duration(seconds: 60), // Maximum 60 seconds for initialization
            onTimeout: () {
              print('⚠️ Initialization timeout - forcing close and proceeding with login');
              // Force close dialog and proceed
              if (mounted) {
                _hideInitializationProgress();
              }
              throw TimeoutException('Initialization took too long, proceeding anyway');
            },
          );
          print('✅ Firebase initialized on-demand');
        } catch (e) {
          print('⚠️ On-demand Firebase initialization issue: $e');
          // Close dialog but continue with login attempt
          if (mounted) {
            _hideInitializationProgress();
          }
          
          // If it's a timeout, proceed with login anyway (Firebase might be partially initialized)
          if (e is TimeoutException) {
            print('⚠️ Proceeding with login despite initialization timeout');
            // Continue to login attempt
          } else {
            // For other errors, show message but still try to proceed
            if (mounted) {
              ScaffoldMessenger.of(context).clearSnackBars();
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('Connection issue: ${e.toString().length > 50 ? e.toString().substring(0, 50) + "..." : e.toString()}. Attempting login anyway...'),
                  backgroundColor: Colors.orange,
                  duration: const Duration(seconds: 3),
                ),
              );
            }
          }
        }
        
        // Ensure dialog is closed before proceeding
        if (_isFirstTimeInit && mounted) {
          _hideInitializationProgress();
          await Future.delayed(const Duration(milliseconds: 300));
        }
      }

      final mobile = _mobileController.text.trim();
      final password = _passwordController.text.trim();

      // Authenticate against Firestore admins collection with timeout handling
      print('🔐 Starting authentication process...');
      Admin? admin;
      try {
        admin = await AdminService.authenticateAdmin(mobile, password);
        print('🔐 Authentication result: ${admin != null ? "SUCCESS" : "FAILED"}');
      } on TimeoutException catch (e) {
        print('❌ Login timeout: $e');
        if (mounted) {
          ScaffoldMessenger.of(context).clearSnackBars();
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Connection timeout. Please check your internet connection and try again.'),
              backgroundColor: Colors.orange,
              duration: Duration(seconds: 4),
            ),
          );
        }
        setState(() {
          _isLoading = false;
        });
        return;
      } catch (e) {
        print('❌ Login error during authentication: $e');
        // Don't show error here, let it fall through to check admin == null
      }

      if (admin == null) {
        // Admin not found or invalid credentials
        print('⚠️ Authentication failed: admin is null');
        if (mounted) {
          // Clear any existing snackbars before showing a new one
          ScaffoldMessenger.of(context).clearSnackBars();
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Invalid mobile number or password'),
              backgroundColor: Colors.red,
              duration: Duration(seconds: 3),
            ),
          );
        }
        setState(() {
          _isLoading = false;
        });
        return;
      }
      
      print('✅ Authentication successful, proceeding with login...');

      // Save credentials if "Remember Me" is checked
      await _saveCredentials(_mobileController.text.trim(), _passwordController.text.trim());

      // Store current admin for use in creating queues, etc.
      AdminService.setCurrentAdmin(admin.id, admin);
      
      // If Super Admin, ensure distributionPoint is set to "All"
      // Also check by mobile number for test user
      final isTestSuperAdmin = admin.mobile == '01010646279';
      if ((admin.isSuperAdmin || isTestSuperAdmin) && admin.distributionPoint.toLowerCase() != 'all') {
        print('⚠️ Super Admin found but distributionPoint is not "All" - updating...');
        print('⚠️ Admin mobile: ${admin.mobile}, isSuperAdmin: ${admin.isSuperAdmin}, role: ${admin.role}');
        try {
          await AdminService.updateAdmin(admin.id, admin.copyWith(distributionPoint: 'All'));
          // Reload admin with updated data
          final updatedAdmin = await AdminService.getAdminById(admin.id);
          if (updatedAdmin != null) {
            AdminService.setCurrentAdmin(admin.id, updatedAdmin);
            print('✅ Updated Super Admin distributionPoint to "All"');
          }
        } catch (e) {
          print('⚠️ Could not update Super Admin distributionPoint: $e');
        }
      }

      // Ensure progress dialog is closed before navigation (mobile Safari fix)
      if (_isFirstTimeInit) {
        _hideInitializationProgress();
        await Future.delayed(const Duration(milliseconds: 100));
      }
      
      // Ensure progress dialog is closed before navigation (force close)
      if (_isFirstTimeInit) {
        _hideInitializationProgress();
        // Multiple attempts to ensure dialog closes on mobile Safari
        await Future.delayed(const Duration(milliseconds: 200));
        _hideInitializationProgress(); // Try again
        await Future.delayed(const Duration(milliseconds: 200));
        setState(() {
          _isFirstTimeInit = false;
        });
      }

      // Login successful - navigate to dashboard
      if (mounted) {
        // Final check: Close any remaining dialogs before navigation
        try {
          if (Navigator.of(context, rootNavigator: true).canPop()) {
            Navigator.of(context, rootNavigator: true).pop();
          }
        } catch (e) {
          print('⚠️ Could not close dialog before navigation: $e');
        }
        
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(
            builder: (context) => const DashboardScreen(),
          ),
        );
      }
    } catch (e) {
      print('Login error: $e');
      if (mounted) {
        // Clear any existing snackbars before showing a new one
        ScaffoldMessenger.of(context).clearSnackBars();
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Login failed: $e'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 3),
          ),
        );
      }
      setState(() {
        _isLoading = false;
        _isFirstTimeInit = false;
      });
      // Hide progress dialog if still showing
      _hideInitializationProgress();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        child: Container(
          decoration: const BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
              colors: [Color(0xFFE8F5E9), Colors.white],
            ),
          ),
          child: Center(
            child: SingleChildScrollView(
              padding: const EdgeInsets.all(24.0),
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Text(
                      'Welcome Back',
                      style: TextStyle(
                        fontSize: 32,
                        fontWeight: FontWeight.bold,
                        color: Color(0xFF1A237E),
                      ),
                    ),
                    const SizedBox(height: 8),
                    const Text(
                      'Sign in to continue',
                      style: TextStyle(
                        fontSize: 16,
                        color: Colors.grey,
                      ),
                    ),
                    const SizedBox(height: 48),
                    TextFormField(
                      controller: _mobileController,
                      keyboardType: TextInputType.number,
                      maxLength: 11,
                      inputFormatters: [
                        FilteringTextInputFormatter.digitsOnly,
                      ],
                      decoration: InputDecoration(
                        labelText: AppLanguage.translate('Mobile Number'),
                        hintText: AppLanguage.translate('Enter mobile number'),
                        counterText: '', // Hide character counter
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                          borderSide: const BorderSide(color: Color(0xFFE0E0E0)),
                        ),
                        enabledBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                          borderSide: const BorderSide(color: Color(0xFFE0E0E0)),
                        ),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                          borderSide: const BorderSide(color: tealGreen, width: 2),
                        ),
                        filled: true,
                        fillColor: Colors.white,
                        prefixIcon: const Icon(Icons.phone, color: tealGreen),
                        contentPadding: const EdgeInsets.symmetric(
                          horizontal: 16,
                          vertical: 16,
                        ),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return AppLanguage.translate('Please enter your mobile number');
                        }
                        if (value.length != 11) {
                          return 'Mobile number must be exactly 11 digits';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 24),
                    TextFormField(
                      controller: _passwordController,
                      obscureText: !_passwordVisible,
                      maxLength: 12,
                      decoration: InputDecoration(
                        labelText: AppLanguage.translate('Password'),
                        hintText: AppLanguage.translate('Enter password'),
                        counterText: '', // Hide character counter
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                          borderSide: const BorderSide(color: Color(0xFFE0E0E0)),
                        ),
                        enabledBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                          borderSide: const BorderSide(color: Color(0xFFE0E0E0)),
                        ),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                          borderSide: const BorderSide(color: tealGreen, width: 2),
                        ),
                        filled: true,
                        fillColor: Colors.white,
                        prefixIcon: const Icon(Icons.lock, color: tealGreen),
                        suffixIcon: IconButton(
                          icon: Icon(
                            _passwordVisible ? Icons.visibility : Icons.visibility_off,
                            color: Colors.grey,
                          ),
                          onPressed: () {
                            setState(() {
                              _passwordVisible = !_passwordVisible;
                            });
                          },
                        ),
                        contentPadding: const EdgeInsets.symmetric(
                          horizontal: 16,
                          vertical: 16,
                        ),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return AppLanguage.translate('Please enter your password');
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),
                    Row(
                      children: [
                        Checkbox(
                          value: _rememberMe,
                          onChanged: (value) {
                            setState(() {
                              _rememberMe = value ?? false;
                            });
                            // If unchecked, clear saved credentials
                            if (value == false) {
                              _saveCredentials('', '');
                            }
                          },
                          activeColor: tealGreen,
                        ),
                        Text(
                          AppLanguage.translate('Remember Me'),
                          style: const TextStyle(
                            fontSize: 14,
                            color: Colors.grey,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    SizedBox(
                      width: double.infinity,
                      child: ElevatedButton(
                        onPressed: _isLoading ? null : _handleLogin,
                        style: ElevatedButton.styleFrom(
                          backgroundColor: tealGreen,
                          foregroundColor: Colors.white,
                          padding: const EdgeInsets.symmetric(vertical: 16),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(12),
                          ),
                          elevation: 0,
                          disabledBackgroundColor: Colors.grey,
                        ),
                        child: _isLoading
                            ? const SizedBox(
                                width: 20,
                                height: 20,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                  valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                ),
                              )
                            : Text(
                                AppLanguage.translate('Sign In'),
                                style: const TextStyle(
                                  fontSize: 16,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                      ),
                    ),
                    const SizedBox(height: 16),
                    Row(
                      children: [
                        Expanded(
                          child: Divider(
                            color: Colors.grey[300],
                            thickness: 1,
                          ),
                        ),
                        Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 16),
                          child: Text(
                            AppLanguage.translate('OR'),
                            style: TextStyle(
                              color: Colors.grey[600],
                              fontSize: 14,
                            ),
                          ),
                        ),
                        Expanded(
                          child: Divider(
                            color: Colors.grey[300],
                            thickness: 1,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    SizedBox(
                      width: double.infinity,
                      child: OutlinedButton(
                        onPressed: () {
                          Navigator.of(context).pushReplacement(
                            MaterialPageRoute(
                              builder: (context) => const GuestDashboardScreen(),
                            ),
                          );
                        },
                        style: OutlinedButton.styleFrom(
                          foregroundColor: tealGreen,
                          side: const BorderSide(color: tealGreen, width: 2),
                          padding: const EdgeInsets.symmetric(vertical: 16),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(12),
                          ),
                        ),
                        child: Text(
                          AppLanguage.translate('Continue as Guest'),
                          style: const TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

// Guest Dashboard Screen
class GuestDashboardScreen extends StatefulWidget {
  const GuestDashboardScreen({super.key});

  @override
  State<GuestDashboardScreen> createState() => _GuestDashboardScreenState();
}

class _GuestDashboardScreenState extends State<GuestDashboardScreen> {
  final List<Beneficiary> _beneficiaries = [];
  final List<Queue> _queues = []; // Initialize to empty list - will be populated from Firestore
  late final List<DistributionArea> _distributionAreas;
  final List<String> _entities = [
    'Red Crescent',
    'Ministry of Social Solidarity',
    'Local Charity Organization',
    'Community Center',
  ];

  @override
  void initState() {
    super.initState();
    _loadInitialData();
  }

  void _loadInitialData() {
    // Load the same predefined data as main dashboard
    _distributionAreas = [
      DistributionArea(
        id: '1',
        country: 'Egypt',
        governorate: 'Cairo',
        city: 'Nasr City',
        areaName: 'Nasr City distribution area',
      ),
      DistributionArea(
        id: '2',
        country: 'Egypt',
        governorate: 'Alexandria',
        city: 'Alexandria',
        areaName: 'Alexandria Queue Point',
      ),
      DistributionArea(
        id: '3',
        country: 'Egypt',
        governorate: 'Giza',
        city: 'Giza',
        areaName: 'Giza Queue Point',
      ),
      DistributionArea(
        id: '4',
        country: 'Egypt',
        governorate: 'Cairo',
        city: 'Heliopolis',
        areaName: 'Heliopolis Queue Point',
      ),
      DistributionArea(
        id: '5',
        country: 'Egypt',
        governorate: 'Cairo',
        city: 'Maadi',
        areaName: 'Maadi Queue Point',
      ),
    ];

    // Queues are now loaded from Firestore via StreamBuilder
    // No sample data - all data comes from Firestore
  }

  void _addBeneficiary(Beneficiary beneficiary) {
    setState(() {
      _beneficiaries.add(beneficiary);
    });
  }

  void _addEntity(String entity) {
    setState(() {
      if (!_entities.contains(entity)) {
        _entities.add(entity);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return PopScope(
      canPop: false,
      onPopInvoked: (didPop) async {
        if (didPop) return;
        final shouldExit = await showDialog<bool>(
          context: context,
          builder: (context) => AlertDialog(
            title: Text(AppLanguage.translate('Exit App')),
            content: Text(AppLanguage.translate('Are you sure you want to exit the app?')),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context, false),
                child: Text(AppLanguage.translate('Cancel')),
              ),
              TextButton(
                onPressed: () => Navigator.pop(context, true),
                child: Text(AppLanguage.translate('Exit'), style: const TextStyle(color: Colors.red)),
              ),
            ],
          ),
        );
        if (shouldExit == true && context.mounted) {
          // Exit the app
          SystemNavigator.pop();
        }
      },
      child: Scaffold(
        appBar: AppBar(
          title: Text(AppLanguage.translate('Guest Mode')),
          backgroundColor: const Color(0xFF81CF01),
          foregroundColor: Colors.white,
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pushReplacement(
                  MaterialPageRoute(
                    builder: (context) => const LoginScreen(),
                  ),
                );
              },
              child: Text(
                AppLanguage.translate('Login'),
                style: const TextStyle(color: Colors.white),
              ),
            ),
          ],
        ),
        body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Color(0xFFE8F5E9), Colors.white],
          ),
        ),
        child: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24.0),
        child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
          children: [
                const Icon(
                  Icons.person_outline,
                  size: 80,
                  color: Color(0xFF81CF01),
                ),
                const SizedBox(height: 24),
                const Text(
                  'Welcome Guest',
                  style: TextStyle(
                    fontSize: 28,
                    fontWeight: FontWeight.bold,
                    color: Color(0xFF1A237E),
                  ),
                ),
                const SizedBox(height: 8),
                const Text(
                  'Register yourself as a beneficiary',
                  style: TextStyle(
                    fontSize: 16,
                    color: Colors.grey,
                  ),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 48),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton.icon(
                    onPressed: () {
                      Navigator.of(context).push(
                        MaterialPageRoute(
                          builder: (context) => GuestBeneficiaryRegistrationScreen(
                            queues: _queues,
                            beneficiaries: _beneficiaries,
                            distributionAreas: _distributionAreas,
                            entities: _entities,
                            onBeneficiaryCreated: (beneficiary) {
                              _addBeneficiary(beneficiary);
                              Navigator.of(context).pop();
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(content: Text(AppLanguage.translate('Registration successful! You can now login to access your queue number.'))),
                              );
                            },
                            onEntityAdded: _addEntity,
                          ),
                        ),
                      );
                    },
                    icon: const Icon(Icons.person_add),
                    label: const Text('Register as Beneficiary'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF81CF01),
                      foregroundColor: Colors.white,
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  width: double.infinity,
                  child: OutlinedButton.icon(
                    onPressed: () {
                      Navigator.of(context).push(
                        MaterialPageRoute(
                          builder: (context) => RequestAdminAccountScreen(
                            distributionAreas: _distributionAreas,
                            onRequestSubmitted: (admin) {
                              // Save the admin request to shared storage
                              AdminRequestStorage.addRequest(admin);
                            },
                          ),
                        ),
                      );
                    },
                    icon: const Icon(Icons.admin_panel_settings),
                    label: Text(AppLanguage.translate('Request Admin Account')),
                    style: OutlinedButton.styleFrom(
                      foregroundColor: const Color(0xFF81CF01),
                      side: const BorderSide(color: Color(0xFF81CF01), width: 2),
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
      ),
    );
  }
}

// Guest Beneficiary Registration Screen (without NFC requirement)
class GuestBeneficiaryRegistrationScreen extends StatefulWidget {
  final List<Queue> queues;
  final List<Beneficiary> beneficiaries;
  final List<DistributionArea> distributionAreas;
  final List<String> entities;
  final Function(Beneficiary) onBeneficiaryCreated;
  final Function(String) onEntityAdded;

  const GuestBeneficiaryRegistrationScreen({
    super.key,
    required this.queues,
    required this.beneficiaries,
    required this.distributionAreas,
    required this.entities,
    required this.onBeneficiaryCreated,
    required this.onEntityAdded,
  });

  @override
  State<GuestBeneficiaryRegistrationScreen> createState() => _GuestBeneficiaryRegistrationScreenState();
}

class _GuestBeneficiaryRegistrationScreenState extends State<GuestBeneficiaryRegistrationScreen> with WidgetsBindingObserver {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _idNumberController = TextEditingController();
  final _mobileNumberController = TextEditingController();
  final _nfcCodeController = TextEditingController();
  final _customEntityController = TextEditingController();
  final _customUnitsController = TextEditingController();

  String? _selectedDistributionArea;
  String _type = 'Normal';
  String _gender = 'Male';
  String _status = 'Active';
  String _numberOfUnits = '1';
  bool _isEntity = false;
  String? _selectedEntity;
  bool _useCustomUnits = false;
  bool _useCustomEntity = false;
  String? _idCopyPath;
  String? _photoPath;
  bool _waitingForGoogleLens = false;
  bool _isGoogleLensAvailable = true; // Default to true, will be checked on init
  static const MethodChannel _googleLensChannel = MethodChannel('com.et3amapp.eqmsapp/google_lens');
  
  
  /// Callback when text is detected from Google Lens
  void _onGoogleLensTextDetected(String text) {
    // Only process text if we're actively waiting for Google Lens results
    // This prevents popups when opening the screen with clipboard content
    if (_waitingForGoogleLens && mounted) {
      print('🔍 Google Lens text detected: ${text.substring(0, text.length > 200 ? 200 : text.length)}');
      setState(() {
        _waitingForGoogleLens = false;
      });
      _parseAndFillGoogleLensData(text);
    }
    // Removed the else clause that showed popup when not waiting for Google Lens
  }
  
  /// Show dialog to confirm using detected Google Lens text
  void _showGoogleLensResultDialog(String text) {
    if (!mounted) return;
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Row(
          children: [
            Icon(Icons.text_fields, color: Colors.blue),
            SizedBox(width: 8),
            Text('Text Detected from Google Lens'),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Detected text:',
              style: TextStyle(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.grey[100],
                borderRadius: BorderRadius.circular(8),
              ),
              child: SelectableText(
                text.length > 500 ? '${text.substring(0, 500)}...' : text,
                style: const TextStyle(fontSize: 12),
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              'Would you like to extract ID card data from this text?',
              style: TextStyle(fontSize: 14),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
              _parseAndFillGoogleLensData(text);
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF81CF01),
              foregroundColor: Colors.white,
            ),
            child: const Text('Extract Data'),
          ),
        ],
      ),
    );
  }
  
  /// Parse Google Lens text and fill form fields
  void _parseAndFillGoogleLensData(String text) {
    try {
      print('🔍 Parsing Google Lens text (length: ${text.length})');
      print('🔍 Full text: ${text.substring(0, text.length > 1000 ? 1000 : text.length)}');
      
      // Clean the text - Google Lens sometimes adds extra formatting
      String cleanedText = text
          .replaceAll(RegExp(r'\s+'), ' ') // Normalize whitespace
          .replaceAll(RegExp(r'[^\w\sأ-ي\d\-/]'), '') // Remove special chars except Arabic, numbers, dashes, slashes
          .trim();
      
      // Use existing IDParser to extract data
      final parsedData = IDParser.parseIDText(cleanedText);
      
      print('🔍 Google Lens Extracted Data:');
      print('  ID Number: ${parsedData['idNumber']}');
      print('  Name: ${parsedData['name']}');
      print('  Birth Date: ${parsedData['birthDate']}');
      print('  Gender: ${parsedData['gender']}');
      print('  Birth Location: ${parsedData['birthLocation']}');
      
      if (mounted) {
        bool dataExtracted = false;
        
        setState(() {
          // Fill ID Number
          if (parsedData['idNumber'] != null) {
            final idNum = parsedData['idNumber'] as String;
            if (idNum.length == 14) {
              _idNumberController.text = idNum;
              _checkDuplicateID(idNum);
              dataExtracted = true;
              print('✅ ID Number extracted: $idNum');
            }
          }
          
          // Fill Name
          if (parsedData['name'] != null) {
            final name = parsedData['name'] as String;
            // Validate name - should not be just numbers or codes
            if (!RegExp(r'^[A-Z]{1,3}\d{4,}$').hasMatch(name.trim()) && 
                !RegExp(r'^[A-Z]{2,}\d+$').hasMatch(name.trim()) &&
                name.length >= 3 &&
                RegExp(r'[أ-يA-Za-z]').hasMatch(name)) {
              _nameController.text = name;
              dataExtracted = true;
              print('✅ Name extracted: $name');
            }
          }
          
          // Fill Gender
          if (parsedData['gender'] != null) {
            final gender = parsedData['gender'] as String;
            if (gender.isNotEmpty) {
              _gender = gender;
              dataExtracted = true;
              print('✅ Gender extracted: $gender');
            }
          }
          
          // Fill Birth Location
          if (parsedData['birthLocation'] != null) {
            final location = parsedData['birthLocation'] as String;
            if (location.isNotEmpty && RegExp(r'[أ-يA-Za-z]').hasMatch(location)) {
              // You can add a birth location field if needed
              print('✅ Birth Location extracted: $location');
            }
          }
          
          // Fill Type based on birth date
          if (parsedData['birthDate'] != null) {
            final birthDate = parsedData['birthDate'] as DateTime;
            final elderlyThreshold = DateTime(1965, 1, 1);
            if (birthDate.isBefore(elderlyThreshold)) {
              _type = 'Elderly';
            }
            dataExtracted = true;
            print('✅ Birth Date extracted: $birthDate');
          }
        });
        
        if (dataExtracted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('✅ Data extracted from Google Lens and filled automatically'),
              backgroundColor: Colors.green,
              duration: Duration(seconds: 3),
            ),
          );
        } else {
          // Show dialog with extracted text for manual review
          _showManualReviewDialog(cleanedText, parsedData);
        }
      }
    } catch (e, stackTrace) {
      print('❌ Error parsing Google Lens data: $e');
      print('Stack trace: $stackTrace');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Text('⚠️ Could not parse data from Google Lens. Please enter manually.'),
            backgroundColor: Colors.orange,
            duration: const Duration(seconds: 4),
            action: SnackBarAction(
              label: 'Review Text',
              textColor: Colors.white,
              onPressed: () => _showManualReviewDialog(text, {}),
            ),
          ),
        );
      }
    }
  }
  
  /// Show dialog for manual review of extracted data
  void _showManualReviewDialog(String text, Map<String, dynamic> parsedData) {
    if (!mounted) return;
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Review Extracted Data'),
        content: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              if (parsedData['idNumber'] != null)
                _buildDataRow('ID Number', parsedData['idNumber'].toString()),
              if (parsedData['name'] != null)
                _buildDataRow('Name', parsedData['name'].toString()),
              if (parsedData['birthDate'] != null)
                _buildDataRow('Birth Date', parsedData['birthDate'].toString()),
              if (parsedData['gender'] != null)
                _buildDataRow('Gender', parsedData['gender'].toString()),
              const Divider(),
              const Text(
                'Full Text:',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: Colors.grey[100],
                  borderRadius: BorderRadius.circular(4),
                ),
                child: SelectableText(
                  text,
                  style: const TextStyle(fontSize: 12),
                ),
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
              // Try to extract ID number manually from text
              final idMatch = RegExp(r'\d{14}').firstMatch(text);
              if (idMatch != null) {
                _idNumberController.text = idMatch.group(0)!;
                _checkDuplicateID(idMatch.group(0)!);
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('✅ ID Number extracted'),
                    backgroundColor: Colors.green,
                  ),
                );
              }
            },
            child: const Text('Use ID Number'),
          ),
        ],
      ),
    );
  }
  
  Widget _buildDataRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 100,
            child: Text(
              '$label:',
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          ),
          Expanded(
            child: SelectableText(value),
          ),
        ],
      ),
    );
  }
  
  /// Launch Google Lens for text detection
  Future<void> _launchGoogleLens() async {
    try {
      if (Platform.isAndroid) {
        setState(() {
          _waitingForGoogleLens = true;
        });
        
        try {
          final result = await _googleLensChannel.invokeMethod('launchGoogleLensCamera');
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(result?.toString() ?? 'Google Lens opened. Copy the detected text and return to app.'),
                backgroundColor: Colors.green,
                duration: const Duration(seconds: 4),
                action: SnackBarAction(
                  label: 'Got it',
                  textColor: Colors.white,
                  onPressed: () {},
                ),
              ),
            );
          }
        } on PlatformException catch (e) {
          setState(() {
            _waitingForGoogleLens = false;
          });
          
          if (mounted) {
            // Show user-friendly error with alternative option
            showDialog(
              context: context,
              builder: (context) => AlertDialog(
                title: const Row(
                  children: [
                    Icon(Icons.info_outline, color: Colors.orange),
                    SizedBox(width: 8),
                    Text('Google Lens Not Available'),
                  ],
                ),
                content: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      e.message ?? 'Google Lens is not available on this device.',
                      style: const TextStyle(fontSize: 16),
                    ),
                    const SizedBox(height: 16),
                    const Text(
                      'Alternative options:',
                      style: TextStyle(fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(height: 8),
                    const Text('1. Install Google app from Play Store'),
                    const Text('2. Use "Scan ID" button for OCR detection'),
                    const Text('3. Enter data manually'),
                  ],
                ),
                actions: [
                  TextButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: const Text('OK'),
                  ),
                  ElevatedButton(
                    onPressed: () {
                      Navigator.of(context).pop();
                      // Optionally open Play Store to install Google app
                      // You can add url_launcher package for this
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF81CF01),
                      foregroundColor: Colors.white,
                    ),
                    child: const Text('Use Scan ID Instead'),
                  ),
                ],
              ),
            );
          }
        } catch (e) {
          setState(() {
            _waitingForGoogleLens = false;
          });
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Error: ${e.toString()}'),
                backgroundColor: Colors.red,
                duration: const Duration(seconds: 4),
              ),
            );
          }
        }
      } else {
        setState(() {
          _waitingForGoogleLens = false;
        });
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Google Lens is only available on Android. Please use "Scan ID" button instead.'),
              backgroundColor: Colors.orange,
            ),
          );
        }
      }
    } catch (e) {
      setState(() {
        _waitingForGoogleLens = false;
      });
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
  
  /// Process scanned image (from auto scan or manual crop)
  Future<void> _processScannedImage(String imagePath) async {
    try {
      // Save the image path
      setState(() {
        _idCopyPath = imagePath;
      });

      // Validate image quality first
      final qualityResult = await ImageQualityValidator.validateImageQuality(imagePath);
      print('📸 Image Quality Check:');
      print('  Valid: ${qualityResult['isValid']}');
      print('  Score: ${qualityResult['score']}');
      print('  Issues: ${qualityResult['issues']}');
      
      // Only block if quality is very poor (score < 0.3)
      // Otherwise, just show a warning but continue with OCR
      final qualityScore = qualityResult['score'] as double;
      if (qualityScore < 0.3) {
        if (context.mounted) {
          Navigator.of(context).pop(); // Close loading dialog
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('⚠️ ${AppLanguage.translate("Image quality is very low. Please ensure good lighting and focus.")}\n${(qualityResult['recommendations'] as List).join(", ")}'),
              backgroundColor: Colors.orange,
              duration: const Duration(seconds: 5),
            ),
          );
        }
        return;
      } else if (qualityScore < 0.6 && qualityResult['issues'] != null && (qualityResult['issues'] as List).isNotEmpty) {
        // Show warning but continue - don't block OCR for moderate quality issues
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('ℹ️ ${AppLanguage.translate("Image quality could be better, but proceeding with OCR.")}\n${(qualityResult['recommendations'] as List).take(2).join(", ")}'),
              backgroundColor: Colors.blue,
              duration: const Duration(seconds: 3),
            ),
          );
        }
      }

      // Preprocess image using Python solution approach (threshold at 95 like front.py)
      // Based on: https://github.com/OlaHamdy3/National-ID-card-reader
      String? processedImagePath = await ImageQualityValidator.preprocessImage(
        imagePath, 
        useThresholding: true, 
        threshold: 95  // Python solution uses thresh = 95 for front
      );
      
      // Also try region-based extraction (like Python solution)
      final regions = await ImageQualityValidator.extractRegionsFromImage(imagePath);
      print('🖼️ Extracted ${regions.length} regions: ${regions.keys.join(", ")}');

      // Perform OCR using region-based approach (like Python solution)
      String combinedText = '';
      Map<String, String> ocrResults = {}; // Store results from different approaches
      
      // Strategy 1: Region-based OCR (like Python solution - most accurate)
      if (regions.isNotEmpty) {
        print('🔍 Strategy 1: Starting region-based OCR with ${regions.length} regions');
        try {
          final ocr = FlutterNativeOcr();
          
          // Extract name from name region (like Python: image_to_string(Name, lang="ara"))
          if (regions.containsKey('nameRegion')) {
            print('🔍 Processing name region: ${regions['nameRegion']}');
            try {
              final nameText = await ocr.recognizeText(regions['nameRegion']!);
              if (nameText.isNotEmpty) {
                ocrResults['name'] = nameText;
                combinedText = '${combinedText}${nameText}\n';
                print('📝 Name Region OCR: $nameText (${nameText.length} chars)');
              } else {
                print('⚠️ Name Region OCR returned empty text');
              }
            } catch (e) {
              print('❌ Error processing name region: $e');
            }
          }
          
          // Extract address from address region (like Python: image_to_string(address, lang="ara"))
          if (regions.containsKey('addressRegion')) {
            print('🔍 Processing address region: ${regions['addressRegion']}');
            try {
              final addressText = await ocr.recognizeText(regions['addressRegion']!);
              if (addressText.isNotEmpty) {
                ocrResults['address'] = addressText;
                combinedText = '${combinedText}${addressText}\n';
                print('📝 Address Region OCR: $addressText (${addressText.length} chars)');
              } else {
                print('⚠️ Address Region OCR returned empty text');
              }
            } catch (e) {
              print('❌ Error processing address region: $e');
            }
          }
          
          // Extract ID from ID region (like Python: image_to_string(ID, lang="hin"))
          // Try both thresholded and adaptive threshold versions for better results
          if (regions.containsKey('idRegion')) {
            print('🔍 Processing ID region (thresholded): ${regions['idRegion']}');
            try {
              final idText = await ocr.recognizeText(regions['idRegion']!);
              if (idText.isNotEmpty) {
                ocrResults['id'] = idText;
                combinedText = '${combinedText}${idText}\n';
                print('📝 ID Region OCR (thresholded): $idText (${idText.length} chars)');
              } else {
                print('⚠️ ID Region OCR (thresholded) returned empty text');
              }
            } catch (e) {
              print('❌ Error processing ID region (thresholded): $e');
            }
          }
          
          // Also try adaptive threshold version if available (often better for numbers)
          if (regions.containsKey('idRegionAdaptive')) {
            print('🔍 Processing ID region (adaptive): ${regions['idRegionAdaptive']}');
            try {
              final idTextAdaptive = await ocr.recognizeText(regions['idRegionAdaptive']!);
              if (idTextAdaptive.isNotEmpty) {
                // Prefer adaptive if it has more digits or is longer
                final currentId = ocrResults['id'] ?? '';
                print('🔍 Comparing ID results: thresholded="$currentId" (${currentId.length} chars, ${RegExp(r'\d').allMatches(currentId).length} digits) vs adaptive="$idTextAdaptive" (${idTextAdaptive.length} chars, ${RegExp(r'\d').allMatches(idTextAdaptive).length} digits)');
                if (idTextAdaptive.length > currentId.length || 
                    RegExp(r'\d').allMatches(idTextAdaptive).length > RegExp(r'\d').allMatches(currentId).length) {
                  ocrResults['id'] = idTextAdaptive;
                  // Update combined text if this is better
                  if (currentId.isNotEmpty) {
                    combinedText = combinedText.replaceAll(currentId, idTextAdaptive);
                  } else {
                    combinedText = '${combinedText}${idTextAdaptive}\n';
                  }
                  print('📝 ID Region OCR (adaptive, better): $idTextAdaptive');
                } else {
                  print('📝 ID Region OCR (adaptive): $idTextAdaptive (keeping thresholded version)');
                }
              } else {
                print('⚠️ ID Region OCR (adaptive) returned empty text');
              }
            } catch (e) {
              print('❌ Error processing ID region (adaptive): $e');
            }
          }
          
          print('🔍 Strategy 1 complete. Combined text length: ${combinedText.length}');
        } catch (e, stackTrace) {
          print('❌ Region-based OCR Error: $e');
          print('Stack trace: $stackTrace');
        }
      } else {
        print('⚠️ No regions extracted - skipping region-based OCR');
      }
      
      // Strategy 2: Full image OCR with thresholded image (Python solution approach)
      // CRITICAL: Always try this even if region extraction worked, as it may catch more text
      if (processedImagePath != null) {
        print('🔍 Strategy 2: Full image OCR with preprocessed image');
        try {
          final ocr = FlutterNativeOcr();
          final fullText = await ocr.recognizeText(processedImagePath);
          if (fullText.isNotEmpty) {
            ocrResults['full'] = fullText;
            print('📝 Full image OCR extracted ${fullText.length} characters');
            // Combine with region results - prefer longer/more complete text
            if (combinedText.isEmpty || fullText.length > combinedText.length * 1.5) {
              combinedText = fullText;
              print('📝 Using full image OCR as primary result (${fullText.length} chars)');
            } else {
              // Merge unique content from full image
              final fullLines = fullText.split('\n');
              int mergedCount = 0;
              for (final line in fullLines) {
                if (line.trim().isNotEmpty && !combinedText.contains(line.trim())) {
                  combinedText = '$combinedText\n${line.trim()}';
                  mergedCount++;
                }
              }
              if (mergedCount > 0) {
                print('📝 Merged $mergedCount additional lines from full image OCR');
              }
            }
          } else {
            print('⚠️ Full image OCR returned empty text');
          }
        } catch (e) {
          print('❌ Full Image OCR Error: $e');
        }
      } else {
        print('⚠️ No processed image path available for full image OCR');
      }
      
      // Strategy 3: Try OCR on original image with different preprocessing (like Python solution)
      // Python solution tries multiple preprocessing strategies for better results
      // Only try if we haven't found enough text yet
      if (combinedText.isEmpty || combinedText.length < 20 || !RegExp(r'[أ-ي]').hasMatch(combinedText)) {
        print('🔍 Strategy 3: Trying original image OCR (current text length: ${combinedText.length})');
        // Try original image first
        try {
          final ocr = FlutterNativeOcr();
          final originalText = await ocr.recognizeText(imagePath);
          if (originalText.isNotEmpty) {
            final originalHasArabic = RegExp(r'[أ-ي]').hasMatch(originalText);
            final originalHasNumbers = RegExp(r'\d{8,}').hasMatch(originalText);
            
            // Prefer text with Arabic or long numbers
            if ((originalHasArabic || originalHasNumbers) && 
                (combinedText.isEmpty || combinedText.length < originalText.length * 0.7)) {
              combinedText = originalText;
              print('📝 Using original image OCR (${originalText.length} chars, Arabic: $originalHasArabic, Numbers: $originalHasNumbers)');
            } else if (combinedText.isEmpty) {
              combinedText = originalText;
              print('📝 Using original image OCR as fallback (${originalText.length} chars)');
            }
            print('📝 Original Image OCR Text Length: ${originalText.length}');
          }
        } catch (e) {
          print('❌ Original Image OCR Error: $e');
        }
        
        // Strategy 4: Try with grayscale preprocessing (like Python solution)
        if (combinedText.isEmpty || combinedText.length < 20) {
          try {
            final file = File(imagePath);
            final bytes = await file.readAsBytes();
            var image = img.decodeImage(bytes);
            if (image != null) {
              // Convert to grayscale (like Python: cv2.cvtColor)
              image = img.grayscale(image);
              // Enhance contrast
              image = img.adjustColor(image, contrast: 1.3);
              
              final tempPath = '${imagePath}_grayscale.jpg';
              await File(tempPath).writeAsBytes(img.encodeJpg(image, quality: 95));
              
              try {
                final ocr = FlutterNativeOcr();
                final grayscaleText = await ocr.recognizeText(tempPath);
                if (grayscaleText.isNotEmpty && grayscaleText.length > combinedText.length) {
                  combinedText = grayscaleText;
                  print('📝 Using grayscale preprocessed OCR (${grayscaleText.length} chars)');
                }
              } catch (e) {
                print('❌ Grayscale OCR Error: $e');
              }
              
              // Clean up temp file
              try {
                await File(tempPath).delete();
              } catch (_) {}
            }
          } catch (e) {
            print('❌ Grayscale preprocessing Error: $e');
          }
        }
      }
      
      // Check if OCR text is too short or doesn't contain meaningful content
      final trimmedText = combinedText.trim();
      print('🔍 Final combined text length: ${trimmedText.length}');
      print('🔍 Final combined text (first 200 chars): ${trimmedText.substring(0, trimmedText.length > 200 ? 200 : trimmedText.length)}');
      
      if (trimmedText.length < 10) {
        print('❌ OCR text too short (${trimmedText.length} chars) - blocking processing');
        if (mounted && context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('⚠️ ${AppLanguage.translate("OCR failed to detect text. Please ensure:")}\n• Good lighting\n• Card is flat and in focus\n• No glare or shadows\n• Card fills most of the frame'),
              backgroundColor: Colors.orange,
              duration: const Duration(seconds: 6),
            ),
          );
        }
        return;
      }
      
      // Check if OCR text contains Arabic characters or numbers (ID numbers are important even without Arabic)
      final hasArabic = RegExp(r'[أ-ي]').hasMatch(trimmedText);
      final hasLongNumbers = RegExp(r'\d{8,}').hasMatch(trimmedText); // Check for sequences of 8+ digits (could be ID)
      final hasAnyNumbers = RegExp(r'\d').hasMatch(trimmedText); // Check for any digits
      
      print('🔍 Text analysis: Arabic=$hasArabic, LongNumbers=$hasLongNumbers, AnyNumbers=$hasAnyNumbers, Length=${trimmedText.length}');
      
      // Even if text is short, try to extract ID if it has numbers
      // Don't block processing if we have any numbers - they might be part of the ID
      if (!hasArabic && !hasLongNumbers && !hasAnyNumbers && trimmedText.length < 50) {
        // If no Arabic and no numbers at all and text is very short, likely OCR failed
        print('⚠️ Warning: No Arabic text or numbers detected in OCR result. Text: $trimmedText');
        if (mounted && context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('⚠️ ${AppLanguage.translate("OCR did not detect Arabic text. The image may be blurry or the card may not be fully visible. Please try again with better lighting and focus.")}'),
              backgroundColor: Colors.orange,
              duration: const Duration(seconds: 6),
            ),
          );
        }
        // Still try to parse - might find something
      }
      
      // If we have numbers but no Arabic, still try to extract ID (might be partial OCR)
      if (!hasArabic && (hasLongNumbers || hasAnyNumbers)) {
        print('⚠️ Warning: No Arabic text detected, but found numbers. Attempting ID extraction anyway...');
      }
      
      try {
        // ALWAYS try to parse the extracted text - even if it's short, we might find an ID number
        print('🔍 Calling parseIDText with text length: ${combinedText.length}');
        final parsedData = IDParser.parseIDText(combinedText);
        
        // Debug: Print extracted data
        print('🔍 OCR Extracted Data:');
        print('  Full OCR Text Length: ${combinedText.length}');
        print('  Full OCR Text (first 1000 chars): ${combinedText.substring(0, combinedText.length > 1000 ? 1000 : combinedText.length)}');
        print('  ID Number: ${parsedData['idNumber']}');
        print('  Name: ${parsedData['name']}');
        print('  Birth Date: ${parsedData['birthDate']}');
        print('  Gender: ${parsedData['gender']}');
        print('  Birth Location: ${parsedData['birthLocation']}');
        print('  Confidence: ${parsedData['confidence']}');
        
        // Check if extraction was successful
        final overallConfidence = (parsedData['confidence'] as Map<String, dynamic>)['overall'] as double;
        final hasName = parsedData['name'] != null;
        final hasID = parsedData['idNumber'] != null;
        
        // Show warning if extraction quality is low
        if (overallConfidence < 0.5 || (!hasName && !hasID)) {
          if (mounted && context.mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('⚠️ ${AppLanguage.translate("Low extraction quality. Please verify the extracted data manually.")}\n${hasID ? "✓ ID Number detected" : "✗ ID Number not detected"}\n${hasName ? "✓ Name detected" : "✗ Name not detected"}'),
                backgroundColor: Colors.orange,
                duration: const Duration(seconds: 5),
              ),
            );
          }
        }

        // Auto-fill form fields with extracted data
        if (mounted) {
          setState(() {
            if (parsedData['idNumber'] != null) {
              final idNum = parsedData['idNumber'] as String;
              _idNumberController.text = idNum;
              // Check for duplicate ID
              _checkDuplicateID(idNum);
            }
            
            if (parsedData['name'] != null) {
              final name = parsedData['name'] as String;
              // Additional validation: ensure it's not an alphanumeric code
              if (!RegExp(r'^[A-Z]{1,3}\d{4,}$').hasMatch(name.trim()) && 
                  !RegExp(r'^[A-Z]{2,}\d+$').hasMatch(name.trim()) &&
                  name.length >= 3) {
                _nameController.text = name;
              } else {
                print('⚠️ Skipped invalid name (looks like code): $name');
              }
            }
            
            if (parsedData['birthDate'] != null) {
              _extractedBirthDate = parsedData['birthDate'] as DateTime;
              // Auto-detect Elderly if birth date is before January 1, 1965
              final elderlyThreshold = DateTime(1965, 1, 1);
              if (_extractedBirthDate!.isBefore(elderlyThreshold)) {
                _type = 'Elderly';
              }
            }
            
            if (parsedData['gender'] != null) {
              _gender = parsedData['gender'] as String;
            }
          });
        }

        if (mounted && context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(AppLanguage.translate('ID scanned successfully')),
              backgroundColor: Colors.green,
            ),
          );
        }
      } catch (e, stackTrace) {
        print('Error parsing OCR text: $e');
        print('Stack trace: $stackTrace');
        if (mounted && context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error processing image: ${e.toString()}'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    } catch (e, stackTrace) {
      print('Error processing scanned image: $e');
      print('Stack trace: $stackTrace');
      if (mounted && context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error processing image: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
  DateTime? _extractedBirthDate;
  String? _duplicateIDMessage;
  String? _duplicateMobileMessage; // Track duplicate mobile number message
  String? _duplicateNFCMessage; // Track duplicate NFC tag ID message
  bool _nfcDetected = false; // Track if NFC tag was detected
  String? _originalNfcTagId; // Store original NFC tag ID for saving (not masked)

  final List<String> _typeOptions = ['Normal', 'Child', 'Widowed', 'Divorced', 'Disability', 'Sick', 'Elderly'];
  final List<String> _genderOptions = ['Male', 'Female'];
  final List<String> _statusOptions = ['Active', 'Banned'];
  final List<String> _unitsOptions = ['1', '2'];


  @override
  void initState() {
    super.initState();
    // Add lifecycle observer
    WidgetsBinding.instance.addObserver(this);
    // Start monitoring clipboard for Google Lens results
    GoogleLensResultHelper.startMonitoring(_onGoogleLensTextDetected);
    // Check if Google Lens is available
    _checkGoogleLensAvailability();
    // NFC detection disabled in guest mode
    // WidgetsBinding.instance.addPostFrameCallback((_) {
    //   _startNFCDetection();
    // });
  }
  
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    if (state == AppLifecycleState.resumed && _waitingForGoogleLens) {
      print('🔍 App resumed - checking for Google Lens result...');
      // Wait a bit for clipboard to update
      Future.delayed(const Duration(milliseconds: 500), () async {
        if (mounted && _waitingForGoogleLens) {
          final clipboardText = await GoogleLensResultHelper.getClipboardText();
          if (clipboardText != null && clipboardText.trim().isNotEmpty) {
            print('🔍 Found clipboard text after resume: ${clipboardText.substring(0, clipboardText.length > 200 ? 200 : clipboardText.length)}');
            _onGoogleLensTextDetected(clipboardText);
          }
        }
      });
    }
  }
  
  /// Check if Google Lens is available on the device
  Future<void> _checkGoogleLensAvailability() async {
    try {
      if (Platform.isAndroid) {
        final isAvailable = await _googleLensChannel.invokeMethod('isGoogleLensAvailable');
        if (mounted) {
          setState(() {
            _isGoogleLensAvailable = isAvailable == true;
          });
        }
      }
    } catch (e) {
      print('Error checking Google Lens availability: $e');
      if (mounted) {
        setState(() {
          _isGoogleLensAvailable = false;
        });
      }
    }
  }

  @override
  void dispose() {
    // Remove lifecycle observer
    WidgetsBinding.instance.removeObserver(this);
    // Stop Google Lens monitoring
    GoogleLensResultHelper.stopMonitoring();
    // Stop NFC session if active
    NFCHelper.stopNFCSession();
    _nameController.dispose();
    _idNumberController.dispose();
    _mobileNumberController.dispose();
    _nfcCodeController.dispose();
    _customEntityController.dispose();
    _customUnitsController.dispose();
    super.dispose();
  }

  void _startNFCDetection() async {
    if (kIsWeb) return;
    
    try {
      // Check if NFC is available
      final isAvailable = await NFCHelper.isNFCAvailable();
      if (!isAvailable) {
        return;
      }

      // Start NFC session - auto-detect when card is tapped
      NFCHelper.startNFCSession(
        context: context,
        onTagDetected: (id) {
          if (mounted) {
            setState(() {
              // Display masked NFC tag ID, but we need to store original for saving
              // Store original ID in controller's value (we'll extract it when saving)
              // For now, display masked version
              _nfcCodeController.text = NFCHelper.maskNfcTagId(id);
              _nfcDetected = true; // Mark as detected
              // Store original ID in a hidden way - we'll use the original 'id' when saving
              // The masked value is only for display
            });
          }
        },
        onError: (error) {
          // Silently handle errors for auto-detection
          print('NFC auto-detection error: $error');
        },
      );
    } catch (e) {
      print('Error starting NFC detection: $e');
    }
  }

  Future<void> _handleRegister() async {
    if (_formKey.currentState!.validate()) {
      if (_selectedDistributionArea == null) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(AppLanguage.translate('Please select a distribution area'))),
        );
        return;
      }

      // Prevent saving if there's a duplicate NFC message
      if (_duplicateNFCMessage != null) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(_duplicateNFCMessage!),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 4),
          ),
        );
        return;
      }

      // Check for duplicate ID in Firestore before proceeding
      if (_idNumberController.text.isNotEmpty) {
        final existingBeneficiary = await BeneficiaryService.getBeneficiaryByIdNumber(_idNumberController.text);
        if (existingBeneficiary != null) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('This ID number is already registered in the system.'),
              backgroundColor: Colors.red,
            ),
          );
          return;
        }
      }

      // Check for duplicate NFC tag ID before proceeding
      // First check if there's already a duplicate message set
      if (_duplicateNFCMessage != null) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(_duplicateNFCMessage!),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 4),
          ),
        );
        return;
      }

      // Get NFC code to check - prefer original, but if manually entered, use the text field value
      // Note: If manually entered, the text might be masked, so we need to handle that
      String? nfcCodeToCheck = _originalNfcTagId;
      if (nfcCodeToCheck == null || nfcCodeToCheck.isEmpty) {
        final textFieldValue = _nfcCodeController.text.trim();
        if (textFieldValue.isNotEmpty) {
          // If the text contains asterisks, it's masked - we can't validate it properly
          // In this case, we should ask user to scan the card again
          if (textFieldValue.contains('*')) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Please scan the NFC card again. Manual entry of masked NFC codes is not allowed.'),
                backgroundColor: Colors.orange,
                duration: Duration(seconds: 3),
              ),
            );
            return;
          }
          nfcCodeToCheck = textFieldValue;
        }
      }

      if (nfcCodeToCheck != null && nfcCodeToCheck.isNotEmpty) {
        final existingNfcBeneficiary = await BeneficiaryService.getBeneficiaryByNFC(nfcCodeToCheck);
        if (existingNfcBeneficiary != null) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('This NFC card is already registered to: ${existingNfcBeneficiary.name} (ID: ${existingNfcBeneficiary.idNumber})'),
              backgroundColor: Colors.red,
              duration: const Duration(seconds: 4),
            ),
          );
          return;
        }
      }

      String entityName = '';
      if (_isEntity) {
        if (_useCustomEntity) {
          if (_customEntityController.text.isEmpty) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text(AppLanguage.translate('Please enter entity name'))),
            );
            return;
          }
          entityName = _customEntityController.text;
          widget.onEntityAdded(entityName);
        } else {
          if (_selectedEntity == null) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text(AppLanguage.translate('Please select an entity'))),
            );
            return;
          }
          entityName = _selectedEntity!;
        }
      }

      String units = _numberOfUnits;
      if (_useCustomUnits) {
        if (_customUnitsController.text.isEmpty) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(AppLanguage.translate('Please enter number of units'))),
          );
          return;
        }
        units = _customUnitsController.text;
      }

      // Show loading dialog
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => const Center(
          child: CircularProgressIndicator(),
        ),
      );

      try {
        // Get the current admin ID for createdBy field (or use 'guest' for guest registrations)
        final createdBy = AdminService.currentAdminId ?? 'guest';
        
        // Create beneficiary object
      final beneficiary = Beneficiary(
          id: DateTime.now().millisecondsSinceEpoch.toString(), // Temporary ID, will be replaced by Firestore ID
          distributionArea: _selectedDistributionArea!, // This is the distribution area ID selected from dropdown
          initialAssignedQueuePoint: '', // Not required in registration screen
        type: _type,
        idCopyPath: _idCopyPath,
        gender: _gender,
          name: _nameController.text,
          idNumber: _idNumberController.text.replaceAll(RegExp(r'[\s\-]'), ''), // Clean ID number
          mobileNumber: _mobileNumberController.text.isNotEmpty ? _mobileNumberController.text.replaceAll(RegExp(r'[\s\-]'), '') : null, // Clean mobile number
        isEntity: _isEntity,
        entityName: _isEntity ? entityName : null,
        numberOfUnits: units,
          nfcPreprintedCode: null, // NFC disabled in guest mode
        photoPath: _photoPath,
        status: _status,
        birthDate: _extractedBirthDate,
      );

        // Save to Firestore
        final beneficiaryId = await BeneficiaryService.createBeneficiary(beneficiary, createdBy);
        
        // Update beneficiary with Firestore ID
        final savedBeneficiary = beneficiary.copyWith(id: beneficiaryId);

        // Close loading dialog
        if (mounted) {
          Navigator.of(context).pop();
        }

        // Call the callback with the saved beneficiary
        widget.onBeneficiaryCreated(savedBeneficiary);

        // Show success message
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(AppLanguage.translate('Beneficiary registered successfully')),
              backgroundColor: Colors.green,
            ),
          );
        }
      } catch (e) {
        // Close loading dialog
        if (mounted) {
          Navigator.of(context).pop();
        }
        
        print('Error creating beneficiary: $e');
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error registering beneficiary: $e'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    }
  }

  /// Crop image to focus on ID card
  Future<CroppedFile?> _cropImage(String imagePath) async {
    try {
      final croppedFile = await ImageCropper().cropImage(
        sourcePath: imagePath,
        aspectRatio: const CropAspectRatio(ratioX: 1.6, ratioY: 1.0), // ID card aspect ratio (approximately)
        uiSettings: [
          AndroidUiSettings(
            toolbarTitle: AppLanguage.translate('Crop ID Card'),
            toolbarColor: const Color(0xFF1A237E),
            toolbarWidgetColor: Colors.white,
            initAspectRatio: CropAspectRatioPreset.original,
            lockAspectRatio: false, // Allow free-form cropping
            aspectRatioPresets: [
              CropAspectRatioPreset.original,
              CropAspectRatioPreset.ratio16x9,
              CropAspectRatioPreset.ratio4x3,
            ],
            backgroundColor: Colors.black,
            activeControlsWidgetColor: const Color(0xFF1A237E),
            dimmedLayerColor: Colors.black.withOpacity(0.8),
            cropFrameColor: Colors.white,
            cropGridColor: Colors.white.withOpacity(0.5),
            cropFrameStrokeWidth: 2,
            cropGridStrokeWidth: 1,
            showCropGrid: true,
            hideBottomControls: false,
          ),
          IOSUiSettings(
            title: AppLanguage.translate('Crop ID Card'),
            aspectRatioLockEnabled: false,
            resetAspectRatioEnabled: true,
            aspectRatioPresets: [
              CropAspectRatioPreset.original,
              CropAspectRatioPreset.square,
              CropAspectRatioPreset.ratio16x9,
            ],
            rotateButtonsHidden: false,
            rotateClockwiseButtonHidden: false,
            hidesNavigationBar: false,
            showCancelConfirmationDialog: true,
          ),
        ],
      );
      return croppedFile;
    } catch (e) {
      print('Error cropping image: $e');
      return null;
    }
  }

  Future<void> _scanID() async {
    try {
      // Show dialog to choose image source (camera or gallery)
      final source = await showDialog<ImageSource>(
        context: context,
        builder: (context) => AlertDialog(
          title: Text(AppLanguage.translate('Select Image Source')),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ListTile(
                leading: const Icon(Icons.camera_alt),
                title: Text(AppLanguage.translate('Camera')),
                onTap: () => Navigator.pop(context, ImageSource.camera),
              ),
              ListTile(
                leading: const Icon(Icons.photo_library),
                title: Text(AppLanguage.translate('Gallery')),
                onTap: () => Navigator.pop(context, ImageSource.gallery),
              ),
            ],
          ),
        ),
      );

      if (source == null) return;

      // Request permissions based on source
      bool hasPermission = false;
      if (source == ImageSource.camera) {
        hasPermission = await PermissionHelper.requestCameraPermission();
      if (!hasPermission) {
        if (context.mounted) {
          await PermissionHelper.showPermissionDeniedDialog(
            context,
            AppLanguage.translate('Camera permission is required. Please enable it in app settings.'),
          );
        }
        return;
        }
      } else {
        // For gallery, request storage permission
        hasPermission = await PermissionHelper.requestStoragePermission();
        if (!hasPermission) {
          if (context.mounted) {
            await PermissionHelper.showPermissionDeniedDialog(
              context,
              AppLanguage.translate('Storage permission is required to select images from gallery.'),
            );
          }
          return;
        }
      }

      // Show loading dialog
      if (context.mounted) {
        showDialog(
          context: context,
          barrierDismissible: false,
          builder: (context) => const Center(
            child: CircularProgressIndicator(),
          ),
        );
      }

      // Get image from selected source
      final image_picker.ImagePicker picker = image_picker.ImagePicker();
      final image_picker.XFile? image = await picker.pickImage(
        source: source == ImageSource.camera 
            ? image_picker.ImageSource.camera 
            : image_picker.ImageSource.gallery,
        imageQuality: 90,
      );

      if (image == null) {
        if (context.mounted) {
          Navigator.of(context).pop(); // Close loading dialog
        }
        return;
      }

      // Close loading dialog before showing crop screen
      if (context.mounted) {
        Navigator.of(context).pop();
      }

      // Show image cropping screen to allow user to focus on ID card
      final croppedFile = await _cropImage(image.path);
      if (croppedFile == null) {
        // User cancelled cropping
        return;
      }

      // Save the cropped image path
      setState(() {
        _idCopyPath = croppedFile.path;
      });

      // Validate image quality first (use cropped image)
      final qualityResult = await ImageQualityValidator.validateImageQuality(croppedFile.path);
      print('📸 Image Quality Check:');
      print('  Valid: ${qualityResult['isValid']}');
      print('  Score: ${qualityResult['score']}');
      print('  Issues: ${qualityResult['issues']}');
      
      // Only block if quality is very poor (score < 0.3)
      // Otherwise, just show a warning but continue with OCR
      final qualityScore = qualityResult['score'] as double;
      if (qualityScore < 0.3) {
        if (context.mounted) {
          Navigator.of(context).pop(); // Close loading dialog
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('⚠️ ${AppLanguage.translate("Image quality is very low. Please ensure good lighting and focus.")}\n${(qualityResult['recommendations'] as List).join(", ")}'),
              backgroundColor: Colors.orange,
              duration: const Duration(seconds: 5),
            ),
          );
        }
        return;
      } else if (qualityScore < 0.6 && qualityResult['issues'] != null && (qualityResult['issues'] as List).isNotEmpty) {
        // Show warning but continue - don't block OCR for moderate quality issues
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('ℹ️ ${AppLanguage.translate("Image quality could be better, but proceeding with OCR.")}\n${(qualityResult['recommendations'] as List).take(2).join(", ")}'),
              backgroundColor: Colors.blue,
              duration: const Duration(seconds: 3),
            ),
          );
        }
      }

      // Preprocess image using Python solution approach (threshold at 95 like front.py)
      // Based on: https://github.com/OlaHamdy3/National-ID-card-reader
      String? processedImagePath = await ImageQualityValidator.preprocessImage(
        croppedFile.path, 
        useThresholding: true, 
        threshold: 95  // Python solution uses thresh = 95 for front
      );
      
      // Also try region-based extraction (like Python solution)
      final regions = await ImageQualityValidator.extractRegionsFromImage(croppedFile.path);
      print('🖼️ Extracted ${regions.length} regions: ${regions.keys.join(", ")}');

      // Perform OCR using region-based approach (like Python solution)
      String combinedText = '';
      Map<String, String> ocrResults = {}; // Store results from different approaches
      
      // Strategy 1: Region-based OCR (like Python solution - most accurate)
      if (regions.isNotEmpty) {
        print('🔍 Strategy 1: Starting region-based OCR with ${regions.length} regions');
        try {
          final ocr = FlutterNativeOcr();
          
          // Extract name from name region (like Python: image_to_string(Name, lang="ara"))
          if (regions.containsKey('nameRegion')) {
            print('🔍 Processing name region: ${regions['nameRegion']}');
            try {
              final nameText = await ocr.recognizeText(regions['nameRegion']!);
              if (nameText.isNotEmpty) {
                ocrResults['name'] = nameText;
                combinedText = '${combinedText}${nameText}\n';
                print('📝 Name Region OCR: $nameText (${nameText.length} chars)');
              } else {
                print('⚠️ Name Region OCR returned empty text');
              }
            } catch (e) {
              print('❌ Error processing name region: $e');
            }
          }
          
          // Extract address from address region (like Python: image_to_string(address, lang="ara"))
          if (regions.containsKey('addressRegion')) {
            print('🔍 Processing address region: ${regions['addressRegion']}');
            try {
              final addressText = await ocr.recognizeText(regions['addressRegion']!);
              if (addressText.isNotEmpty) {
                ocrResults['address'] = addressText;
                combinedText = '${combinedText}${addressText}\n';
                print('📝 Address Region OCR: $addressText (${addressText.length} chars)');
              } else {
                print('⚠️ Address Region OCR returned empty text');
              }
            } catch (e) {
              print('❌ Error processing address region: $e');
            }
          }
          
          // Extract ID from ID region (like Python: image_to_string(ID, lang="hin"))
          // Try both thresholded and adaptive threshold versions for better results
          if (regions.containsKey('idRegion')) {
            print('🔍 Processing ID region (thresholded): ${regions['idRegion']}');
            try {
              final idText = await ocr.recognizeText(regions['idRegion']!);
              if (idText.isNotEmpty) {
                ocrResults['id'] = idText;
                combinedText = '${combinedText}${idText}\n';
                print('📝 ID Region OCR (thresholded): $idText (${idText.length} chars)');
              } else {
                print('⚠️ ID Region OCR (thresholded) returned empty text');
              }
            } catch (e) {
              print('❌ Error processing ID region (thresholded): $e');
            }
          }
          
          // Also try adaptive threshold version if available (often better for numbers)
          if (regions.containsKey('idRegionAdaptive')) {
            print('🔍 Processing ID region (adaptive): ${regions['idRegionAdaptive']}');
            try {
              final idTextAdaptive = await ocr.recognizeText(regions['idRegionAdaptive']!);
              if (idTextAdaptive.isNotEmpty) {
                // Prefer adaptive if it has more digits or is longer
                final currentId = ocrResults['id'] ?? '';
                print('🔍 Comparing ID results: thresholded="$currentId" (${currentId.length} chars, ${RegExp(r'\d').allMatches(currentId).length} digits) vs adaptive="$idTextAdaptive" (${idTextAdaptive.length} chars, ${RegExp(r'\d').allMatches(idTextAdaptive).length} digits)');
                if (idTextAdaptive.length > currentId.length || 
                    RegExp(r'\d').allMatches(idTextAdaptive).length > RegExp(r'\d').allMatches(currentId).length) {
                  ocrResults['id'] = idTextAdaptive;
                  // Update combined text if this is better
                  if (currentId.isNotEmpty) {
                    combinedText = combinedText.replaceAll(currentId, idTextAdaptive);
                  } else {
                    combinedText = '${combinedText}${idTextAdaptive}\n';
                  }
                  print('📝 ID Region OCR (adaptive, better): $idTextAdaptive');
                } else {
                  print('📝 ID Region OCR (adaptive): $idTextAdaptive (keeping thresholded version)');
                }
              } else {
                print('⚠️ ID Region OCR (adaptive) returned empty text');
              }
            } catch (e) {
              print('❌ Error processing ID region (adaptive): $e');
            }
          }
          
          print('🔍 Strategy 1 complete. Combined text length: ${combinedText.length}');
        } catch (e, stackTrace) {
          print('❌ Region-based OCR Error: $e');
          print('Stack trace: $stackTrace');
        }
      } else {
        print('⚠️ No regions extracted - skipping region-based OCR');
      }
      
      // Strategy 2: Full image OCR with thresholded image (Python solution approach)
      if (processedImagePath != null) {
        try {
          final ocr = FlutterNativeOcr();
          final fullText = await ocr.recognizeText(processedImagePath);
          if (fullText.isNotEmpty) {
            ocrResults['full'] = fullText;
            // Combine with region results
            if (combinedText.isEmpty || fullText.length > combinedText.length * 1.5) {
              combinedText = fullText;
              print('📝 Using full image OCR (${fullText.length} chars)');
            } else {
              // Merge unique content
              final fullLines = fullText.split('\n');
              for (final line in fullLines) {
                if (line.trim().isNotEmpty && !combinedText.contains(line.trim())) {
                  combinedText = '$combinedText\n${line.trim()}';
                }
              }
            }
          }
        } catch (e) {
          print('❌ Full Image OCR Error: $e');
        }
      }
      
      // Strategy 3: Original image OCR (fallback if region extraction failed)
      if (combinedText.isEmpty || !RegExp(r'[أ-ي]').hasMatch(combinedText)) {
        try {
          final ocr = FlutterNativeOcr();
          final originalText = await ocr.recognizeText(croppedFile.path);
          if (originalText.isNotEmpty) {
            final originalHasArabic = RegExp(r'[أ-ي]').hasMatch(originalText);
            if (originalHasArabic && (combinedText.isEmpty || !RegExp(r'[أ-ي]').hasMatch(combinedText))) {
              combinedText = originalText;
              print('📝 Using original image OCR (better Arabic detection)');
            } else if (combinedText.isEmpty) {
              combinedText = originalText;
            }
            print('📝 Original Image OCR Text Length: ${originalText.length}');
          }
        } catch (e) {
          print('❌ Original Image OCR Error: $e');
        }
      }
      
      // Check if OCR text is too short or doesn't contain meaningful content
      final trimmedText = combinedText.trim();
      print('🔍 Final combined text length: ${trimmedText.length}');
      print('🔍 Final combined text (first 200 chars): ${trimmedText.substring(0, trimmedText.length > 200 ? 200 : trimmedText.length)}');
      
      if (trimmedText.length < 10) {
        print('❌ OCR text too short (${trimmedText.length} chars) - blocking processing');
        if (mounted && context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('⚠️ ${AppLanguage.translate("OCR failed to detect text. Please ensure:")}\n• Good lighting\n• Card is flat and in focus\n• No glare or shadows\n• Card fills most of the frame'),
              backgroundColor: Colors.orange,
              duration: const Duration(seconds: 6),
            ),
          );
        }
        return;
      }
      
      // Check if OCR text contains Arabic characters or numbers (ID numbers are important even without Arabic)
      final hasArabic = RegExp(r'[أ-ي]').hasMatch(trimmedText);
      final hasLongNumbers = RegExp(r'\d{8,}').hasMatch(trimmedText); // Check for sequences of 8+ digits (could be ID)
      final hasAnyNumbers = RegExp(r'\d').hasMatch(trimmedText); // Check for any digits
      
      print('🔍 Text analysis: Arabic=$hasArabic, LongNumbers=$hasLongNumbers, AnyNumbers=$hasAnyNumbers, Length=${trimmedText.length}');
      
      // Even if text is short, try to extract ID if it has numbers
      // Don't block processing if we have any numbers - they might be part of the ID
      if (!hasArabic && !hasLongNumbers && !hasAnyNumbers && trimmedText.length < 50) {
        // If no Arabic and no numbers at all and text is very short, likely OCR failed
        print('⚠️ Warning: No Arabic text or numbers detected in OCR result. Text: $trimmedText');
        if (mounted && context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('⚠️ ${AppLanguage.translate("OCR did not detect Arabic text. The image may be blurry or the card may not be fully visible. Please try again with better lighting and focus.")}'),
              backgroundColor: Colors.orange,
              duration: const Duration(seconds: 6),
            ),
          );
        }
        // Still try to parse - might find something
      }
      
      // If we have numbers but no Arabic, still try to extract ID (might be partial OCR)
      if (!hasArabic && (hasLongNumbers || hasAnyNumbers)) {
        print('⚠️ Warning: No Arabic text detected, but found numbers. Attempting ID extraction anyway...');
      }
      
      try {
        // ALWAYS try to parse the extracted text - even if it's short, we might find an ID number
        print('🔍 Calling parseIDText with text length: ${combinedText.length}');
        final parsedData = IDParser.parseIDText(combinedText);
        
        // Debug: Print extracted data
        print('🔍 OCR Extracted Data:');
        print('  Full OCR Text Length: ${combinedText.length}');
        print('  Full OCR Text (first 1000 chars): ${combinedText.substring(0, combinedText.length > 1000 ? 1000 : combinedText.length)}');
        print('  ID Number: ${parsedData['idNumber']}');
        print('  Name: ${parsedData['name']}');
        print('  Birth Date: ${parsedData['birthDate']}');
        print('  Gender: ${parsedData['gender']}');
        print('  Birth Location: ${parsedData['birthLocation']}');
        print('  Confidence: ${parsedData['confidence']}');
        
        // Check if extraction was successful
        final overallConfidence = (parsedData['confidence'] as Map<String, dynamic>)['overall'] as double;
        final hasName = parsedData['name'] != null;
        final hasID = parsedData['idNumber'] != null;
        
        // Show warning if extraction quality is low
        if (overallConfidence < 0.5 || (!hasName && !hasID)) {
          if (mounted && context.mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('⚠️ ${AppLanguage.translate("Low extraction quality. Please verify the extracted data manually.")}\n${hasID ? "✓ ID Number detected" : "✗ ID Number not detected"}\n${hasName ? "✓ Name detected" : "✗ Name not detected"}'),
                backgroundColor: Colors.orange,
                duration: const Duration(seconds: 5),
              ),
            );
          }
        }

        // Auto-fill form fields with extracted data
        if (mounted) {
        setState(() {
          if (parsedData['idNumber'] != null) {
              final idNum = parsedData['idNumber'] as String;
              _idNumberController.text = idNum;
            // Check for duplicate ID
              _checkDuplicateID(idNum);
          }
          
          if (parsedData['name'] != null) {
              final name = parsedData['name'] as String;
              // Additional validation: ensure it's not an alphanumeric code
              if (!RegExp(r'^[A-Z]{1,3}\d{4,}$').hasMatch(name.trim()) && 
                  !RegExp(r'^[A-Z]{2,}\d+$').hasMatch(name.trim()) &&
                  name.length >= 3) {
                _nameController.text = name;
              } else {
                print('⚠️ Skipped invalid name (looks like code): $name');
              }
          }
          
          if (parsedData['birthDate'] != null) {
            _extractedBirthDate = parsedData['birthDate'] as DateTime;
            // Auto-detect Elderly if birth date is before January 1, 1965
            final elderlyThreshold = DateTime(1965, 1, 1);
            if (_extractedBirthDate!.isBefore(elderlyThreshold)) {
              _type = 'Elderly';
            }
          }
          
          if (parsedData['gender'] != null) {
            _gender = parsedData['gender'] as String;
          }
        });
        }

        if (mounted && context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(AppLanguage.translate('ID scanned successfully')),
              backgroundColor: Colors.green,
            ),
          );
        }
      } catch (e, stackTrace) {
        print('Error parsing OCR text: $e');
        print('Stack trace: $stackTrace');
        if (mounted && context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error processing image: ${e.toString()}'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    } catch (e, stackTrace) {
      print('Error processing ID: $e');
      print('Stack trace: $stackTrace');
      if (mounted && context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error processing ID: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _scanNFCCard() async {
    try {
      // Check if NFC is available
      final isAvailable = await NFCHelper.isNFCAvailable();
      if (!isAvailable) {
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(AppLanguage.translate('NFC is not available on this device')),
              backgroundColor: Colors.orange,
            ),
          );
        }
        return;
      }

      // Start NFC session
      NFCHelper.startNFCSession(
        context: context,
        onTagDetected: (id) {
          if (mounted) {
            setState(() {
              // Store original NFC tag ID for saving
              _originalNfcTagId = id;
              // Display masked NFC tag ID to user
              _nfcCodeController.text = NFCHelper.maskNfcTagId(id);
              _nfcDetected = true; // Mark as detected
            });
            
            // Check for duplicate NFC tag ID
            _checkDuplicateNFC(id);
            
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(AppLanguage.translate('NFC card detected')),
                backgroundColor: Colors.green,
              ),
            );
          }
        },
        onError: (error) {
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(error),
                backgroundColor: Colors.red,
              ),
            );
          }
        },
      );
    } catch (e, stackTrace) {
      print('Error scanning NFC: $e');
      print('Stack trace: $stackTrace');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  /// Capture ID from camera
  Future<void> _captureIDFromCamera() async {
    try {
      final hasPermission = await PermissionHelper.requestCameraPermission();
      if (!hasPermission) {
        if (context.mounted) {
          await PermissionHelper.showPermissionDeniedDialog(
            context,
            AppLanguage.translate('Camera permission is required. Please enable it in app settings.'),
          );
        }
        return;
      }

      if (context.mounted) {
        showDialog(
          context: context,
          barrierDismissible: false,
          builder: (context) => const Center(child: CircularProgressIndicator()),
        );
      }

      final image_picker.ImagePicker picker = image_picker.ImagePicker();
      final image_picker.XFile? image = await picker.pickImage(
        source: image_picker.ImageSource.camera,
        imageQuality: 90,
      );

      if (image == null) {
        if (context.mounted) Navigator.of(context).pop();
        return;
      }

      if (context.mounted) Navigator.of(context).pop();

      final croppedFile = await _cropImage(image.path);
      if (croppedFile == null) return;

      setState(() {
        _idCopyPath = croppedFile.path;
      });

      await _processIDImage(croppedFile.path);
    } catch (e) {
      print('Error capturing ID: $e');
      if (context.mounted) {
        Navigator.of(context).pop();
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error capturing ID: ${e.toString()}'), backgroundColor: Colors.red),
        );
      }
    }
  }

  /// Upload ID from gallery
  Future<void> _uploadIDFromGallery() async {
    try {
      final hasPermission = await PermissionHelper.requestStoragePermission();
      if (!hasPermission) {
        if (context.mounted) {
          await PermissionHelper.showPermissionDeniedDialog(
            context,
            AppLanguage.translate('Storage permission is required to select images from gallery.'),
          );
        }
        return;
      }

      if (context.mounted) {
        showDialog(
          context: context,
          barrierDismissible: false,
          builder: (context) => const Center(child: CircularProgressIndicator()),
        );
      }

      final image_picker.ImagePicker picker = image_picker.ImagePicker();
      final image_picker.XFile? image = await picker.pickImage(
        source: image_picker.ImageSource.gallery,
        imageQuality: 90,
      );

      if (image == null) {
        if (context.mounted) Navigator.of(context).pop();
        return;
      }

      if (context.mounted) Navigator.of(context).pop();

      final croppedFile = await _cropImage(image.path);
      if (croppedFile == null) return;

      setState(() {
        _idCopyPath = croppedFile.path;
      });

      await _processIDImage(croppedFile.path);
    } catch (e) {
      print('Error uploading ID: $e');
      if (context.mounted) {
        Navigator.of(context).pop();
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error uploading ID: ${e.toString()}'), backgroundColor: Colors.red),
        );
      }
    }
  }

  /// Process ID image (shared logic for both camera and gallery)
  Future<void> _processIDImage(String imagePath) async {
    try {
      final qualityResult = await ImageQualityValidator.validateImageQuality(imagePath);
      final qualityScore = qualityResult['score'] as double;
      if (qualityScore < 0.3) {
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('⚠️ ${AppLanguage.translate("Image quality is very low. Please ensure good lighting and focus.")}'),
              backgroundColor: Colors.orange,
            ),
          );
        }
        return;
      }

      await _performOCRAndFillForm(imagePath);
    } catch (e) {
      print('Error processing ID image: $e');
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error processing ID: ${e.toString()}'), backgroundColor: Colors.red),
        );
      }
    }
  }

  /// Perform OCR and fill form (extracted from _scanID)
  Future<void> _performOCRAndFillForm(String imagePath) async {
    try {
      String? processedImagePath = await ImageQualityValidator.preprocessImage(imagePath, useThresholding: true, threshold: 95);
      final regions = await ImageQualityValidator.extractRegionsFromImage(imagePath);
      
      String combinedText = '';
      final ocr = FlutterNativeOcr();
      
      if (regions.isNotEmpty) {
        if (regions.containsKey('nameRegion')) {
          try {
            final nameText = await ocr.recognizeText(regions['nameRegion']!);
            if (nameText.isNotEmpty) combinedText += '$nameText\n';
          } catch (e) {}
        }
        if (regions.containsKey('idRegion')) {
          try {
            final idText = await ocr.recognizeText(regions['idRegion']!);
            if (idText.isNotEmpty) combinedText += '$idText\n';
          } catch (e) {}
        }
      }
      
      if (processedImagePath != null) {
        try {
          final fullText = await ocr.recognizeText(processedImagePath);
          if (fullText.isNotEmpty && fullText.length > combinedText.length) {
            combinedText = fullText;
          }
        } catch (e) {}
      }
      
      if (combinedText.isEmpty) {
        try {
          combinedText = await ocr.recognizeText(imagePath);
        } catch (e) {}
      }
      
      if (combinedText.trim().length < 10) {
        if (mounted && context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('⚠️ ${AppLanguage.translate("OCR failed to detect text")}'), backgroundColor: Colors.orange),
          );
        }
        return;
      }
      
      final parsedData = IDParser.parseIDText(combinedText);
      
      if (mounted) {
        setState(() {
          if (parsedData['idNumber'] != null) {
            _idNumberController.text = parsedData['idNumber'] as String;
            _checkDuplicateID(parsedData['idNumber'] as String);
          }
          if (parsedData['name'] != null) {
            final name = parsedData['name'] as String;
            if (!RegExp(r'^[A-Z]{1,3}\d{4,}$').hasMatch(name.trim()) && name.length >= 3) {
              _nameController.text = name;
            }
          }
          if (parsedData['birthDate'] != null) {
            _extractedBirthDate = parsedData['birthDate'] as DateTime;
            if (_extractedBirthDate!.isBefore(DateTime(1965, 1, 1))) {
              _type = 'Elderly';
            }
          }
          if (parsedData['gender'] != null) {
            _gender = parsedData['gender'] as String;
          }
        });
      }
      
      if (mounted && context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(AppLanguage.translate('ID scanned successfully')), backgroundColor: Colors.green),
        );
      }
    } catch (e) {
      print('Error in OCR processing: $e');
      if (mounted && context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error processing image: ${e.toString()}'), backgroundColor: Colors.red),
        );
      }
    }
  }

  Future<void> _extractNameFromID() async {
    if (_idCopyPath == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(AppLanguage.translate('Please scan ID first'))),
      );
      return;
    }
    
    await Future.delayed(const Duration(milliseconds: 500));
    
    setState(() {
      _nameController.text = 'Extracted Name from ID';
    });
    
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(AppLanguage.translate('Name extracted from ID'))),
    );
  }

  Future<void> _checkDuplicateID(String idNumber) async {
    // Check if ID already exists in Firestore
    try {
      final existingBeneficiary = await BeneficiaryService.getBeneficiaryByIdNumber(idNumber);
      
      if (existingBeneficiary != null) {
        setState(() {
          _duplicateIDMessage = 'This National ID is already registered with another beneficiary (Name: ${existingBeneficiary.name}, Distribution Area: ${existingBeneficiary.distributionArea}). Cannot register this beneficiary with the same National ID.';
        });
      } else {
        // Also check local list as fallback
        try {
          final localBeneficiary = widget.beneficiaries.firstWhere(
            (b) => b.idNumber == idNumber,
          );
          setState(() {
            _duplicateIDMessage = 'This National ID is already registered with another beneficiary (Name: ${localBeneficiary.name}, Initial assigned queue: ${localBeneficiary.initialAssignedQueuePoint}). Cannot register this beneficiary with the same National ID.';
          });
        } catch (e) {
          // ID not found - no duplicate
          setState(() {
            _duplicateIDMessage = null;
          });
        }
      }
    } catch (e) {
      print('Error checking duplicate ID: $e');
      // On error, also check local list
      try {
        final localBeneficiary = widget.beneficiaries.firstWhere(
          (b) => b.idNumber == idNumber,
        );
        setState(() {
          _duplicateIDMessage = 'This National ID is already registered with another beneficiary (Name: ${localBeneficiary.name}, Initial assigned queue: ${localBeneficiary.initialAssignedQueuePoint}). Cannot register this beneficiary with the same National ID.';
        });
      } catch (e2) {
        setState(() {
          _duplicateIDMessage = null;
        });
      }
    }
  }

  Future<void> _checkDuplicateMobile(String mobileNumber) async {
    if (mobileNumber.isEmpty) {
      setState(() {
        _duplicateMobileMessage = null;
      });
      return;
    }

    // Clean the mobile number (remove spaces, dashes)
    final cleanMobile = mobileNumber.replaceAll(RegExp(r'[\s\-]'), '');
    
    // Check if mobile number already exists in Firestore
    try {
      final existingBeneficiary = await BeneficiaryService.getBeneficiaryByMobile(cleanMobile);
      
      if (existingBeneficiary != null) {
        setState(() {
          _duplicateMobileMessage = 'This Mobile Number is already registered with another beneficiary (Name: ${existingBeneficiary.name}, National ID: ${existingBeneficiary.idNumber}, Distribution Area: ${existingBeneficiary.distributionArea}). Cannot register this beneficiary with the same Mobile Number.';
        });
      } else {
        // Also check local list as fallback
        try {
          final localBeneficiary = widget.beneficiaries.firstWhere(
            (b) => b.mobileNumber != null && b.mobileNumber!.replaceAll(RegExp(r'[\s\-]'), '') == cleanMobile,
          );
          setState(() {
            _duplicateMobileMessage = 'This Mobile Number is already registered with another beneficiary (Name: ${localBeneficiary.name}, National ID: ${localBeneficiary.idNumber}, Initial assigned queue: ${localBeneficiary.initialAssignedQueuePoint}). Cannot register this beneficiary with the same Mobile Number.';
          });
        } catch (e) {
          // Mobile number not found - no duplicate
          setState(() {
            _duplicateMobileMessage = null;
          });
        }
      }
    } catch (e) {
      print('Error checking duplicate mobile: $e');
      // On error, also check local list
      try {
        final localBeneficiary = widget.beneficiaries.firstWhere(
          (b) => b.mobileNumber != null && b.mobileNumber!.replaceAll(RegExp(r'[\s\-]'), '') == cleanMobile,
        );
        setState(() {
          _duplicateMobileMessage = 'This Mobile Number is already registered with another beneficiary (Name: ${localBeneficiary.name}, National ID: ${localBeneficiary.idNumber}, Initial assigned queue: ${localBeneficiary.initialAssignedQueuePoint}). Cannot register this beneficiary with the same Mobile Number.';
        });
      } catch (e2) {
        setState(() {
          _duplicateMobileMessage = null;
        });
      }
    }
  }

  Future<void> _checkDuplicateNFC(String nfcCode) async {
    if (nfcCode.isEmpty) {
      setState(() {
        _duplicateNFCMessage = null;
      });
      return;
    }

    // Check if NFC code already exists in Firestore
    try {
      final existingBeneficiary = await BeneficiaryService.getBeneficiaryByNFC(nfcCode);
      
      if (existingBeneficiary != null) {
        setState(() {
          _duplicateNFCMessage = 'This NFC card is already registered to: ${existingBeneficiary.name} (ID: ${existingBeneficiary.idNumber})';
        });
      } else {
        // Also check local list as fallback
        try {
          final localBeneficiary = widget.beneficiaries.firstWhere(
            (b) => b.nfcPreprintedCode != null && b.nfcPreprintedCode == nfcCode,
          );
          setState(() {
            _duplicateNFCMessage = 'This NFC card is already registered to: ${localBeneficiary.name} (ID: ${localBeneficiary.idNumber})';
          });
        } catch (e) {
          // NFC code not found - no duplicate
          setState(() {
            _duplicateNFCMessage = null;
          });
        }
      }
    } catch (e) {
      print('Error checking duplicate NFC: $e');
      // On error, also check local list
      try {
        final localBeneficiary = widget.beneficiaries.firstWhere(
          (b) => b.nfcPreprintedCode != null && b.nfcPreprintedCode == nfcCode,
        );
        setState(() {
          _duplicateNFCMessage = 'This NFC card is already registered to: ${localBeneficiary.name} (ID: ${localBeneficiary.idNumber})';
        });
      } catch (e2) {
        setState(() {
          _duplicateNFCMessage = null;
        });
      }
    }
  }

  Future<void> _takePhoto() async {
    final source = await showDialog<ImageSource>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(AppLanguage.translate('Select Photo Source')),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.camera_alt),
              title: Text(AppLanguage.translate('Camera')),
              onTap: () => Navigator.pop(context, ImageSource.camera),
            ),
            ListTile(
              leading: const Icon(Icons.photo_library),
              title: Text(AppLanguage.translate('Gallery')),
              onTap: () => Navigator.pop(context, ImageSource.gallery),
            ),
          ],
        ),
      ),
    );

    if (source == null) return;

    try {
      // Request permissions based on source
      bool hasPermission = false;
      if (source == ImageSource.camera) {
        hasPermission = await PermissionHelper.requestCameraPermission();
        if (!hasPermission) {
          if (context.mounted) {
            await PermissionHelper.showPermissionDeniedDialog(
              context,
              AppLanguage.translate('Camera permission is required. Please enable it in app settings.'),
            );
          }
          return;
        }
      } else {
        hasPermission = await PermissionHelper.requestStoragePermission();
        if (!hasPermission) {
          if (context.mounted) {
            await PermissionHelper.showPermissionDeniedDialog(
              context,
              AppLanguage.translate('Storage permission is required. Please enable it in app settings.'),
            );
          }
          return;
        }
      }

      // Use image_picker to get the image
      final image_picker.ImagePicker picker = image_picker.ImagePicker();
      final image_picker.XFile? image = await picker.pickImage(
        source: source == ImageSource.camera 
            ? image_picker.ImageSource.camera 
            : image_picker.ImageSource.gallery,
        imageQuality: 85,
      );

      // Check if widget is still mounted after async operation
      if (!mounted) return;

      if (image != null) {
        try {
          // Validate that the file path exists (skip check on web)
          if (!kIsWeb) {
            final file = File(image.path);
            final fileExists = await file.exists();
            
            if (!fileExists) {
              if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text(AppLanguage.translate('Error: Image file not found')),
                    backgroundColor: Colors.red,
                  ),
                );
              }
              return;
            }
          }
          
          // Set the photo path
          if (mounted) {
            setState(() {
              _photoPath = image.path;
            });
          }
          
          // Show success message
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(AppLanguage.translate(
                  source == ImageSource.camera ? 'Photo taken successfully' : 'Photo selected successfully'
                )),
                backgroundColor: Colors.green,
              ),
            );
          }
        } catch (fileError) {
          // If file check fails, still try to set the path (might work on some platforms)
          print('File check error (non-critical): $fileError');
          if (mounted) {
            setState(() {
              _photoPath = image.path;
            });
            
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(AppLanguage.translate(
                  source == ImageSource.camera ? 'Photo taken successfully' : 'Photo selected successfully'
                )),
                backgroundColor: Colors.green,
              ),
            );
          }
        }
      }
    } catch (e, stackTrace) {
      print('Error taking/selecting photo: $e');
      print('Stack trace: $stackTrace');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: ${e.toString()}'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 3),
          ),
        );
      }
    }
  }

  /// Take ID Copy (simple - no OCR processing)
  Future<void> _takeIDCopy() async {
    final source = await showDialog<ImageSource>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(AppLanguage.translate('Select ID Copy Source')),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.camera_alt),
              title: Text(AppLanguage.translate('Camera')),
              onTap: () => Navigator.pop(context, ImageSource.camera),
            ),
            ListTile(
              leading: const Icon(Icons.photo_library),
              title: Text(AppLanguage.translate('Gallery')),
              onTap: () => Navigator.pop(context, ImageSource.gallery),
            ),
          ],
        ),
      ),
    );

    if (source == null) return;

    try {
      // Request permissions based on source
      bool hasPermission = false;
      if (source == ImageSource.camera) {
        hasPermission = await PermissionHelper.requestCameraPermission();
        if (!hasPermission) {
          if (context.mounted) {
            await PermissionHelper.showPermissionDeniedDialog(
              context,
              AppLanguage.translate('Camera permission is required. Please enable it in app settings.'),
            );
          }
          return;
        }
      } else {
        hasPermission = await PermissionHelper.requestStoragePermission();
        if (!hasPermission) {
          if (context.mounted) {
            await PermissionHelper.showPermissionDeniedDialog(
              context,
              AppLanguage.translate('Storage permission is required. Please enable it in app settings.'),
            );
          }
          return;
        }
      }

      // Use image_picker to get the image
      final image_picker.ImagePicker picker = image_picker.ImagePicker();
      final image_picker.XFile? image = await picker.pickImage(
        source: source == ImageSource.camera 
            ? image_picker.ImageSource.camera 
            : image_picker.ImageSource.gallery,
        imageQuality: 90,
      );

      // Check if widget is still mounted after async operation
      if (!mounted) return;

      if (image != null) {
        try {
          // Validate that the file path exists (skip check on web)
          if (!kIsWeb) {
            final file = File(image.path);
            final fileExists = await file.exists();
            
            if (!fileExists) {
              if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text(AppLanguage.translate('Error: Image file not found')),
                    backgroundColor: Colors.red,
                  ),
                );
              }
              return;
            }
          }
          
          // Set the ID copy path (no OCR processing - just save the image)
          if (mounted) {
            setState(() {
              _idCopyPath = image.path;
            });
          }
          
          // Show success message
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(AppLanguage.translate(
                  source == ImageSource.camera ? 'ID Copy captured successfully' : 'ID Copy selected successfully'
                )),
                backgroundColor: Colors.green,
              ),
            );
          }
        } catch (fileError) {
          // If file check fails, still try to set the path (might work on some platforms)
          print('File check error (non-critical): $fileError');
          if (mounted) {
            setState(() {
              _idCopyPath = image.path;
            });
            
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(AppLanguage.translate(
                  source == ImageSource.camera ? 'ID Copy captured successfully' : 'ID Copy selected successfully'
                )),
                backgroundColor: Colors.green,
              ),
            );
          }
        }
      }
    } catch (e, stackTrace) {
      print('Error taking/selecting ID copy: $e');
      print('Stack trace: $stackTrace');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    const darkBlue = Color(0xFF1A237E);
    const tealGreen = Color(0xFF81CF01);

    return Scaffold(
      appBar: AppBar(
        title: Text(AppLanguage.translate('Self Registration')),
        backgroundColor: tealGreen,
        foregroundColor: Colors.white,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => Navigator.of(context).pop(),
        ),
      ),
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Color(0xFFE8F5E9), Colors.white],
          ),
        ),
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(20.0),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
            Text(
                  AppLanguage.translate('Beneficiary Registration'),
                  style: const TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                    color: darkBlue,
                  ),
                ),
                const SizedBox(height: 32),
                _buildLabel('Distribution Area *'),
                const SizedBox(height: 8),
                _buildDistributionAreaDropdown(),
                const SizedBox(height: 24),
                _buildLabel('ID Copy *'),
                const SizedBox(height: 8),
                Row(
                  children: [
                    if (_idCopyPath != null)
                      Container(
                        width: 80,
                        height: 80,
                        decoration: BoxDecoration(
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.grey.withOpacity(0.3)),
                          color: Colors.grey[200],
                        ),
                        child: Stack(
                          children: [
                            ClipRRect(
                              borderRadius: BorderRadius.circular(8),
                              child: kIsWeb
                                  ? const Icon(
                                      Icons.credit_card,
                                      size: 40,
                                      color: Colors.grey,
                                    )
                                  : Image.file(
                                      File(_idCopyPath!),
                                      width: 80,
                                      height: 80,
                                      fit: BoxFit.cover,
                                      errorBuilder: (context, error, stackTrace) {
                                        return const Icon(
                                          Icons.credit_card,
                                          size: 40,
                                          color: Colors.grey,
                                        );
                                      },
                                    ),
                            ),
                            Positioned(
                              right: 0,
                              top: 0,
                              child: IconButton(
                                icon: const Icon(Icons.close, size: 20, color: Colors.red),
                                onPressed: () {
                                  setState(() {
                                    _idCopyPath = null;
                                  });
                                },
                              ),
                            ),
                          ],
                        ),
                      )
                    else
                      Container(
                        width: 80,
                        height: 80,
                        decoration: BoxDecoration(
                          color: Colors.grey[200],
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.grey.withOpacity(0.3)),
                        ),
                        child: const Icon(Icons.credit_card, size: 40, color: Colors.grey),
                      ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: ElevatedButton.icon(
                        onPressed: _takeIDCopy,
                        icon: const Icon(Icons.camera_alt),
                        label: Text(_idCopyPath != null ? AppLanguage.translate('Retake ID Copy') : AppLanguage.translate('Take ID Copy')),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: tealGreen,
                          foregroundColor: Colors.white,
                          padding: const EdgeInsets.symmetric(vertical: 12),
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 24),
                _buildLabel('Type *'),
                const SizedBox(height: 8),
                _buildDropdown(_type, _typeOptions, (value) => setState(() => _type = value ?? 'Normal')),
                const SizedBox(height: 24),
                _buildLabel('Gender *'),
                const SizedBox(height: 8),
                Row(
                  children: [
                    Expanded(
                      child: RadioListTile<String>(
                        title: Text(AppLanguage.translate('Male')),
                        value: 'Male',
                        groupValue: _gender,
                        onChanged: (value) => setState(() => _gender = value ?? 'Male'),
                        contentPadding: EdgeInsets.zero,
                        dense: true,
                      ),
                    ),
                    Expanded(
                      child: RadioListTile<String>(
                        title: Text(AppLanguage.translate('Female')),
                        value: 'Female',
                        groupValue: _gender,
                        onChanged: (value) => setState(() => _gender = value ?? 'Female'),
                        contentPadding: EdgeInsets.zero,
                        dense: true,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 24),
                _buildLabel('Name *'),
                const SizedBox(height: 8),
                TextFormField(
                  controller: _nameController,
                  decoration: _buildInputDecoration(AppLanguage.translate('Enter name')),
                  validator: (value) => value?.isEmpty ?? true ? AppLanguage.translate('Please enter name') : null,
                ),
                const SizedBox(height: 24),
                _buildLabel('ID Number *'),
                const SizedBox(height: 8),
                TextFormField(
                  controller: _idNumberController,
                  keyboardType: TextInputType.number,
                  decoration: _buildInputDecoration('Enter National ID (14 digits)'),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return AppLanguage.translate('Please enter National ID number');
                    }
                    // Remove any spaces or dashes for validation
                    final cleanValue = value.replaceAll(RegExp(r'[\s\-]'), '');
                    // Check if it's exactly 14 digits
                    if (cleanValue.length != 14) {
                      return 'National ID must be exactly 14 digits';
                    }
                    // Check if all characters are digits
                    if (!RegExp(r'^\d{14}$').hasMatch(cleanValue)) {
                      return 'National ID must contain only digits';
                    }
                    // Check if first digit is 2 or 3 (Egyptian ID format)
                    final firstDigit = int.tryParse(cleanValue.substring(0, 1));
                    if (firstDigit != 2 && firstDigit != 3) {
                      return 'Invalid National ID format (must start with 2 or 3)';
                    }
                    return null;
                  },
                  onChanged: (value) {
                    if (value.isNotEmpty) {
                      // Clean the value before checking
                      final cleanValue = value.replaceAll(RegExp(r'[\s\-]'), '');
                      if (cleanValue.length == 14) {
                        _checkDuplicateID(cleanValue);
                      } else {
                        setState(() {
                          _duplicateIDMessage = null;
                        });
                      }
                    } else {
                      setState(() {
                        _duplicateIDMessage = null;
                      });
                    }
                  },
                ),
                if (_duplicateIDMessage != null) ...[
                  const SizedBox(height: 8),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: Colors.orange.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(color: Colors.orange),
                    ),
                    child: Row(
                      children: [
                        const Icon(Icons.warning, color: Colors.orange),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            _duplicateIDMessage!,
                            style: const TextStyle(color: Colors.orange),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
                const SizedBox(height: 24),
                _buildLabel('Mobile Number'),
                const SizedBox(height: 8),
                TextFormField(
                  controller: _mobileNumberController,
                  keyboardType: TextInputType.phone,
                  decoration: _buildInputDecoration('Enter mobile number (01XXXXXXXXX)'),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return null; // Mobile number is optional in guest mode
                    }
                    // Remove any spaces or dashes for validation
                    final cleanValue = value.replaceAll(RegExp(r'[\s\-]'), '');
                    // Check Egyptian mobile number format: 01[0-2,5][0-9]{8}
                    final regex = RegExp(r'^01[0-2,5][0-9]{8}$');
                    if (!regex.hasMatch(cleanValue)) {
                      return 'Invalid Egyptian mobile number format. Must be 11 digits starting with 01 (e.g., 01012345678, 01123456789, 01234567890, 01512345678)';
                    }
                    return null;
                  },
                  onChanged: (value) {
                    if (value.isNotEmpty) {
                      // Clean the value before checking
                      final cleanValue = value.replaceAll(RegExp(r'[\s\-]'), '');
                      // Only check if it's a valid format (11 digits starting with 01)
                      if (RegExp(r'^01[0-2,5][0-9]{8}$').hasMatch(cleanValue)) {
                        _checkDuplicateMobile(cleanValue);
                      } else {
                        setState(() {
                          _duplicateMobileMessage = null;
                        });
                      }
                    } else {
                      setState(() {
                        _duplicateMobileMessage = null;
                      });
                    }
                  },
                ),
                if (_duplicateMobileMessage != null) ...[
                  const SizedBox(height: 8),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: Colors.orange.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(color: Colors.orange),
                    ),
                    child: Row(
                      children: [
                        const Icon(Icons.warning, color: Colors.orange),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            _duplicateMobileMessage!,
                            style: const TextStyle(color: Colors.orange),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
                const SizedBox(height: 24),
                _buildLabel('Number of Units *'),
                const SizedBox(height: 8),
                Row(
                  children: [
                    Expanded(
                      child: _buildDropdown(
                        _numberOfUnits,
                        _unitsOptions,
                        (value) => setState(() {
                          _numberOfUnits = value ?? '1';
                          _useCustomUnits = false;
                        }),
                      ),
                    ),
                    Checkbox(
                      value: _useCustomUnits,
                      onChanged: (value) => setState(() => _useCustomUnits = value ?? false),
                    ),
                    const Text('Custom'),
                  ],
                ),
                if (_useCustomUnits) ...[
                  const SizedBox(height: 12),
                  TextFormField(
                    controller: _customUnitsController,
                    keyboardType: TextInputType.number,
                    decoration: _buildInputDecoration('Enter custom number of units'),
                  ),
                ],
                const SizedBox(height: 24),
                CheckboxListTile(
                  title: Text(AppLanguage.translate('Entity')),
                  value: _isEntity,
                  onChanged: (value) => setState(() => _isEntity = value ?? false),
                ),
                if (_isEntity) ...[
                  const SizedBox(height: 8),
                  Row(
                    children: [
                      Expanded(
                        child: Container(
                          padding: const EdgeInsets.symmetric(horizontal: 16),
                          decoration: BoxDecoration(
                            border: Border.all(color: const Color(0xFFE0E0E0)),
                            borderRadius: BorderRadius.circular(8),
                            color: Colors.white,
                          ),
                          child: DropdownButtonHideUnderline(
                            child: DropdownButton<String>(
                              value: _selectedEntity,
                              isExpanded: true,
                              hint: const Text('Select entity'),
                              items: [...widget.entities, 'Other'].map((entity) {
                                return DropdownMenuItem(
                                  value: entity,
                                  child: Text(
                                    entity,
                                    overflow: TextOverflow.ellipsis,
                                    maxLines: 1,
                                  ),
                                );
                              }).toList(),
                              onChanged: (value) => setState(() {
                                _selectedEntity = value;
                                _useCustomEntity = value == 'Other';
                              }),
                            ),
                          ),
                        ),
                      ),
                    ],
                  ),
                  if (_useCustomEntity) ...[
                    const SizedBox(height: 12),
                    TextFormField(
                      controller: _customEntityController,
                      decoration: _buildInputDecoration('Enter custom entity name'),
                    ),
                  ],
                ],
                const SizedBox(height: 24),
                _buildLabel('Photo (Optional)'),
                const SizedBox(height: 8),
                Row(
                  children: [
                    if (_photoPath != null)
                      Container(
                        width: 80,
                        height: 80,
                        decoration: BoxDecoration(
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.grey.withOpacity(0.3)),
                          color: Colors.grey[200],
                        ),
                        child: Stack(
                          children: [
                            ClipRRect(
                              borderRadius: BorderRadius.circular(8),
                              child: _photoPath!.startsWith('http://') || _photoPath!.startsWith('https://')
                                ? Image.network(
                                    _photoPath!,
                                    width: 80,
                                    height: 80,
                                    fit: BoxFit.cover,
                                    errorBuilder: (context, error, stackTrace) {
                                      return Icon(
                                        Icons.person,
                                        size: 40,
                                        color: Colors.grey[600],
                                      );
                                    },
                                  )
                                : _photoPath!.startsWith('assets/')
                                  ? Image.asset(
                                      _photoPath!,
                                      width: 80,
                                      height: 80,
                                      fit: BoxFit.cover,
                                      errorBuilder: (context, error, stackTrace) {
                                        return Icon(
                                          Icons.person,
                                          size: 40,
                                          color: Colors.grey[600],
                                        );
                                      },
                                    )
                                  : kIsWeb
                                    ? Icon(
                                        Icons.person,
                                        size: 40,
                                        color: Colors.grey[600],
                                      )
                                    : Image.file(
                                        File(_photoPath!),
                                        width: 80,
                                        height: 80,
                                        fit: BoxFit.cover,
                                        errorBuilder: (context, error, stackTrace) {
                                          return Icon(
                                            Icons.person,
                                            size: 40,
                                            color: Colors.grey[600],
                                          );
                                        },
                                      ),
                            ),
                            Positioned(
                              right: 0,
                              top: 0,
                              child: IconButton(
                                icon: const Icon(Icons.close, size: 20, color: Colors.red),
                                onPressed: () {
                                  setState(() {
                                    _photoPath = null;
                                  });
                                },
                              ),
                            ),
                          ],
                        ),
                      )
                    else
                      Container(
                        width: 80,
                        height: 80,
                        decoration: BoxDecoration(
                          color: Colors.grey[200],
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.grey.withOpacity(0.3)),
                        ),
                        child: const Icon(Icons.person, size: 40, color: Colors.grey),
                      ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: ElevatedButton.icon(
                        onPressed: _takePhoto,
                        icon: const Icon(Icons.camera_alt),
                        label: Text(_photoPath != null ? 'Retake Photo' : 'Take Photo'),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: tealGreen,
                          foregroundColor: Colors.white,
                          padding: const EdgeInsets.symmetric(vertical: 12),
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 24),
                Row(
                  children: [
                    _buildLabel('NFC Code'),
                    const SizedBox(width: 8),
                    Expanded(
                      child: TextFormField(
                        controller: _nfcCodeController,
                        decoration: InputDecoration(
                          hintText: AppLanguage.translate('Enter NFC code'),
                          border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          filled: true,
                          fillColor: Colors.white,
                          contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
                          isDense: true,
                          suffixIcon: _nfcDetected
                              ? const Icon(Icons.check_circle, color: Colors.green, size: 24)
                              : IconButton(
                            icon: const Icon(Icons.nfc, color: Color(0xFF81CF01)),
                            onPressed: _scanNFCCard,
                            tooltip: AppLanguage.translate('Scan NFC Card'),
                          ),
                        ),
                        onChanged: (value) {
                          // Reset detection status if user manually edits the field
                          if (mounted && _nfcDetected) {
                            setState(() {
                              _nfcDetected = false;
                              _originalNfcTagId = null; // Clear original ID when manually edited
                            });
                          }
                          // Clear duplicate message when field is cleared
                          if (value.isEmpty) {
                            setState(() {
                              _duplicateNFCMessage = null;
                            });
                          }
                        },
                      ),
                    ),
                  ],
                ),
                if (_duplicateNFCMessage != null) ...[
                  const SizedBox(height: 8),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: Colors.red.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(color: Colors.red),
                    ),
                    child: Row(
                      children: [
                        const Icon(Icons.error, color: Colors.red),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            _duplicateNFCMessage!,
                            style: const TextStyle(color: Colors.red),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
                const SizedBox(height: 24),
                ElevatedButton(
                  onPressed: () => _handleRegister(),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: tealGreen,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    minimumSize: const Size(double.infinity, 0),
                  ),
                  child: Text(AppLanguage.translate('Register Beneficiary')),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildLabel(String text) {
    return Text(
      AppLanguage.translate(text),
      style: const TextStyle(fontSize: 14, fontWeight: FontWeight.w500, color: Color(0xFF1A237E)),
    );
  }

  InputDecoration _buildInputDecoration(String hint) {
    return InputDecoration(
      hintText: AppLanguage.translate(hint),
      border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
      filled: true,
      fillColor: Colors.white,
    );
  }

  Widget _buildDropdown(String value, List<String> items, Function(String?) onChanged) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        border: Border.all(color: const Color(0xFFE0E0E0)),
        borderRadius: BorderRadius.circular(8),
        color: Colors.white,
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: value,
          isExpanded: true,
          items: items.map((item) => DropdownMenuItem(value: item, child: Text(AppLanguage.translate(item)))).toList(),
          onChanged: onChanged,
        ),
      ),
    );
  }

  Widget _buildDistributionAreaDropdown() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        border: Border.all(color: const Color(0xFFE0E0E0)),
        borderRadius: BorderRadius.circular(8),
        color: Colors.white,
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: _selectedDistributionArea,
          isExpanded: true,
          hint: const Text('Select distribution area'),
          items: widget.distributionAreas.map((area) {
            return DropdownMenuItem(
              value: area.id,
              child: Text(
                area.fullName,
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            );
          }).toList(),
          selectedItemBuilder: (context) {
            return widget.distributionAreas.map((area) {
              return Text(
                area.fullName,
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              );
            }).toList();
          },
          onChanged: (value) {
            setState(() {
              _selectedDistributionArea = value;
            });
          },
        ),
      ),
    );
  }

}

class DashboardScreen extends StatefulWidget {
  final bool isGuest;
  
  const DashboardScreen({super.key, this.isGuest = false});

  @override
  State<DashboardScreen> createState() => _DashboardScreenState();
}

class _DashboardScreenState extends State<DashboardScreen> with TickerProviderStateMixin {
  int _selectedIndex = 0;
  String? _selectedDistributionArea;
  
  // Draggable FAB position
  Offset _fabPosition = const Offset(0, 0); // Will be initialized in initState
  bool _isDragging = false;
  late AnimationController _pulseController;
  late Animation<double> _pulseAnimation;
  
  final List<Admin> _admins = [];
  
  List<Admin> get _adminRequests => AdminRequestStorage.adminRequests;
  
  final List<String> _entities = [
    'Red Crescent',
    'Ministry of Social Solidarity',
    'Local Charity Organization',
    'Community Center',
  ];
  
  // Track expansion state for Multi Day queue accordions
  final Map<String, bool> _multiDayQueueExpanded = {};
  final Map<String, Set<String>> _dailyEntryExpanded = {};
  
  List<DistributionArea> _distributionAreas = [];
  
  Future<void> _loadDistributionAreas() async {
    try {
      // Load all distribution areas from Firestore
      final allAreas = await DistributionAreaService.getAllAreas().first;
      
      // Get current admin's assigned distribution area - try multiple times if needed
      Admin? currentAdmin = AdminService.currentAdmin;
      
      // If admin is not loaded yet, wait a bit and try again
      if (currentAdmin == null) {
        await Future.delayed(const Duration(milliseconds: 300));
        currentAdmin = AdminService.currentAdmin;
      }
      
      print('🔍 Loading distribution areas...');
      print('🔍 Current Admin: ${currentAdmin?.fullName}');
      print('🔍 Admin Role: ${currentAdmin?.role}');
      print('🔍 Is Super Admin: ${currentAdmin?.isSuperAdmin}');
      print('🔍 Distribution Point: ${currentAdmin?.distributionPoint}');
      print('🔍 Total areas in Firestore: ${allAreas.length}');
      
      // Super Admin or admin with distributionPoint == "All" can see all distribution areas
      // Check multiple conditions to ensure Super Admin is detected
      final role = currentAdmin?.role ?? '';
      final distributionPoint = currentAdmin?.distributionPoint ?? '';
      final isSuperAdmin = currentAdmin?.isSuperAdmin ?? false;
      
      // Check if this is the test Super Admin user
      final isTestSuperAdmin = currentAdmin?.mobile == '01010646279';
      
      final roleLower = role.toLowerCase().trim();
      final distPointLower = distributionPoint.toLowerCase().trim();
      
      final isSuperAdminRole = currentAdmin != null && (
        isSuperAdmin || 
        roleLower == 'super_admin' ||
        roleLower == 'superadmin' ||
        (roleLower.contains('super') && roleLower.contains('admin')) ||
        distPointLower == 'all' ||
        isTestSuperAdmin  // Fallback for test user
      );
      
      print('🔍 Role check details: role="$role", isSuperAdmin=$isSuperAdmin, distributionPoint="$distributionPoint"');
      print('🔍 Normalized: roleLower="$roleLower", distPointLower="$distPointLower", isTestSuperAdmin=$isTestSuperAdmin, isSuperAdminRole=$isSuperAdminRole');
      
      if (currentAdmin != null && isSuperAdminRole) {
        print('✅ Super Admin detected - showing all ${allAreas.length} distribution areas');
        setState(() {
          _distributionAreas = allAreas;
          print('✅ Set _distributionAreas to ${_distributionAreas.length} areas');
          
          // Reset selected area if it's no longer in the list
          if (_selectedDistributionArea != null) {
            final exists = _distributionAreas.any((area) => area.id == _selectedDistributionArea);
            if (!exists) {
              _selectedDistributionArea = null;
            }
          }
        });
      } else if (currentAdmin != null && (currentAdmin.isAdmin || currentAdmin.isQAdmin) && currentAdmin.distributionPoint.isNotEmpty && currentAdmin.distributionPoint.toLowerCase() != 'all') {
        // For Admin and Q_Admin roles: Filter to only show their assigned distribution areas
        // Match by distributionPoint name with areaName
        final filteredAreas = allAreas.where((area) {
          // Match distributionPoint with areaName (case-insensitive partial match)
          final adminPoint = currentAdmin!.distributionPoint.toLowerCase();
          final areaName = area.areaName.toLowerCase();
          return areaName.contains(adminPoint) || adminPoint.contains(areaName);
        }).toList();
        
        print('📋 Filtered areas for Admin/Q_Admin: ${filteredAreas.length} areas');
        setState(() {
          _distributionAreas = filteredAreas.isNotEmpty ? filteredAreas : [];
          
          // Reset selected area if it's no longer in the list
          if (_selectedDistributionArea != null) {
            final exists = _distributionAreas.any((area) => area.id == _selectedDistributionArea);
            if (!exists) {
              _selectedDistributionArea = null;
            }
          }
          
          // Auto-select the first area if only one is available
          if (_distributionAreas.length == 1 && _selectedDistributionArea == null) {
            _selectedDistributionArea = _distributionAreas.first.id;
          }
        });
      } else {
        // No admin logged in or no distribution point assigned, show all areas
        print('⚠️ No admin or no distribution point - showing all areas');
        setState(() {
          _distributionAreas = allAreas;
          
          // Reset selected area if it's no longer in the list
          if (_selectedDistributionArea != null) {
            final exists = _distributionAreas.any((area) => area.id == _selectedDistributionArea);
            if (!exists) {
              _selectedDistributionArea = null;
            }
          }
        });
      }
      
      print('✅ Final distribution areas count: ${_distributionAreas.length}');
    } catch (e) {
      print('❌ Error loading distribution areas: $e');
      // Fallback to empty list or default areas
      setState(() {
        _distributionAreas = [];
      });
    }
  }
  
  // Queues will be loaded from Firestore via StreamBuilder
  List<Queue> _queues = [];
  
  /// Get valid selected area - ensures the selected value exists in the items list
  String? _getValidSelectedArea() {
    if (_selectedDistributionArea == null) return null;
    
    // Check if the selected value exists in the current distribution areas
    final exists = _distributionAreas.any((area) => area.id == _selectedDistributionArea);
    
    if (!exists) {
      // Selected area no longer exists in the list, reset it
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          setState(() {
            _selectedDistributionArea = null;
          });
        }
      });
      return null;
    }
    
    return _selectedDistributionArea;
  }

  // Beneficiaries are now loaded from Firestore via StreamBuilder
  // No sample data - all data comes from Firestore
  List<Beneficiary> _beneficiaries = [];

  void _addQueue(Queue queue) {
    // Queue is already added to Firestore, so it will appear via StreamBuilder
    // This method is kept for backward compatibility but queues are now loaded from Firestore
    setState(() {
      // Don't add to local list - let StreamBuilder handle it
    });
  }

  void _updateQueue(int index, Queue queue) {
    // This method is kept for backward compatibility
    // Actual updates should be done via QueueService.updateQueue()
    // The StreamBuilder will automatically reflect the changes
    setState(() {
      // Don't update local list - let StreamBuilder handle it
    });
  }

  Future<void> _deleteQueue(String queueName) async {
    // Find queue by name and delete from Firestore
    try {
      final queue = _queues.firstWhere((q) => q.name == queueName);
      // Note: We need the queue ID from Firestore to delete it
      // For now, we'll need to update QueueService to support deletion by name or ID
      // This is a placeholder - actual deletion should use queue ID
      print('Delete queue: $queueName');
    } catch (e) {
      print('Error finding queue to delete: $e');
    }
  }

  void _addBeneficiary(Beneficiary beneficiary) {
    setState(() {
      _beneficiaries.add(beneficiary);
    });
  }

  void _updateBeneficiary(int index, Beneficiary beneficiary) {
    // Safety check: ensure index is valid
    if (index >= 0 && index < _beneficiaries.length) {
      setState(() {
        _beneficiaries[index] = beneficiary;
      });
    } else {
      // If index is invalid, try to find by ID and update
      final foundIndex = _beneficiaries.indexWhere((b) => b.id == beneficiary.id);
      if (foundIndex != -1) {
        setState(() {
          _beneficiaries[foundIndex] = beneficiary;
        });
      } else {
        // Beneficiary not in local list - Firestore stream will handle the update
        // Just log for debugging
        print('Beneficiary ${beneficiary.id} not found in local list - Firestore stream will update');
      }
    }
  }

  @override
  void initState() {
    super.initState();
    // Initialize pulse animation
    _pulseController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    )..repeat(reverse: true);
    
    _pulseAnimation = Tween<double>(begin: 1.0, end: 1.15).animate(
      CurvedAnimation(parent: _pulseController, curve: Curves.easeInOut),
    );
    
    // Load distribution areas filtered by admin
    // Use WidgetsBinding to ensure admin data is loaded, with a delay to ensure admin is set
    WidgetsBinding.instance.addPostFrameCallback((_) {
      Future.delayed(const Duration(milliseconds: 500), () {
        if (mounted) {
    _loadDistributionAreas();
        }
      });
    });
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // Reload distribution areas when dependencies change (e.g., admin data is loaded)
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        // Always reload to ensure Super Admin sees all areas
        _loadDistributionAreas();
      }
    });
  }

  @override
  void dispose() {
    _pulseController.dispose();
    super.dispose();
  }

  void _handleQueueNumberIssued(Queue queue, Beneficiary beneficiary, int queueNumber) {
    final index = _beneficiaries.indexWhere((b) => b.id == beneficiary.id);
    if (index != -1) {
      _updateBeneficiary(index, beneficiary);
    } else {
      _addBeneficiary(beneficiary);
    }
  }

  void _addEntity(String entity) {
    setState(() {
      if (!_entities.contains(entity)) {
        _entities.add(entity);
      }
    });
  }

  void _addDistributionArea(DistributionArea area) {
    setState(() {
      _distributionAreas.add(area);
    });
  }

  void _addAdminRequest(Admin admin) {
    AdminRequestStorage.addRequest(admin);
    setState(() {}); // Trigger rebuild to show updated list
  }

  List<Queue> get _filteredQueues {
    // Super Admin or admin with distributionPoint == "All" can see all queues
    final currentAdmin = AdminService.currentAdmin;
    if (currentAdmin != null && 
        (currentAdmin.isSuperAdmin || currentAdmin.distributionPoint.toLowerCase() == 'all')) {
      // Show all queues, filter by selected distribution area if one is selected
      if (_selectedDistributionArea != null) {
        return _queues.where((q) => q.distributionArea == _selectedDistributionArea).toList();
      }
      return _queues;
    }
    
    // Get admin's assigned distribution area IDs
    final adminAreas = _distributionAreas.map((area) => area.id).toList();
    
    // Filter queues by admin's distribution areas
    List<Queue> adminQueues = _queues.where((q) => adminAreas.contains(q.distributionArea)).toList();
    
    // Further filter by selected distribution area if one is selected
    if (_selectedDistributionArea != null) {
      adminQueues = adminQueues.where((q) => q.distributionArea == _selectedDistributionArea).toList();
    }
    
    return adminQueues;
  }
  
  int get _totalQueues => _filteredQueues.length;
  int get _activeQueues => _filteredQueues.where((q) => q.status == 'active' && !q.isCompleted).length;
  int get _totalBeneficiaries => _beneficiaries.length;

  Widget _buildSummaryCard(String title, dynamic count, IconData icon, Color color, {bool isLandscape = false}) {
    return Expanded(
      child: Container(
        padding: EdgeInsets.symmetric(
          horizontal: isLandscape ? 6 : 10, 
          vertical: isLandscape ? 6 : 12,
        ),
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
            colors: [
              color.withOpacity(0.15),
              color.withOpacity(0.08),
            ],
          ),
          borderRadius: BorderRadius.circular(10),
          border: Border.all(color: color.withOpacity(0.25), width: 1),
          boxShadow: [
            BoxShadow(
              color: color.withOpacity(0.1),
              blurRadius: 4,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                Container(
                  padding: EdgeInsets.all(isLandscape ? 4 : 6),
                  decoration: BoxDecoration(
                    color: color.withOpacity(0.2),
                    borderRadius: BorderRadius.circular(6),
                  ),
                  child: Icon(icon, color: color, size: isLandscape ? 14 : 18),
                ),
                Text(
                  count.toString(),
                  style: TextStyle(
                    fontSize: isLandscape ? 16 : 20,
                    fontWeight: FontWeight.bold,
                    color: color,
                  ),
                ),
              ],
            ),
            SizedBox(height: isLandscape ? 3 : 6),
            Text(
              title,
              style: TextStyle(
                fontSize: isLandscape ? 9 : 11,
                color: Colors.grey[700],
                fontWeight: FontWeight.w500,
              ),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
          ],
        ),
      ),
    );
  }

  /// Generate list of daily entries for a Multi Day queue
  List<DateTime> _generateDailyEntries(Queue queue) {
    if (!queue.isMultiDay) {
      return [];
    }
    
    final List<DateTime> entries = [];
    final currentDate = queue.fromDate;
    final endDate = queue.toDate;
    
    var date = DateTime(currentDate.year, currentDate.month, currentDate.day);
    final end = DateTime(endDate.year, endDate.month, endDate.day);
    
    while (!date.isAfter(end)) {
      entries.add(date);
      date = date.add(const Duration(days: 1));
    }
    
    return entries;
  }

  /// Get icon based on queue unit name
  IconData _getUnitIcon(String unitName) {
    final unitLower = unitName.toLowerCase();
    if (unitLower.contains('meal') || unitLower.contains('food')) {
      return Icons.restaurant;
    } else if (unitLower.contains('bag') || unitLower.contains('package')) {
      return Icons.shopping_bag;
    } else if (unitLower.contains('blanket') || unitLower.contains('bed') || unitLower.contains('cloth')) {
      return Icons.hotel;
    } else {
      // Generic icon for other types
      return Icons.category;
    }
  }

  /// Build Multi Day Queue Accordion with parent and child entries
  Widget _buildMultiDayQueueAccordion(Queue queue, int displayIndex, {bool showOnlyToday = false}) {
    const tealGreen = Color(0xFF81CF01);
    var dailyEntries = _generateDailyEntries(queue);
    
    // For "Today List", only show today's entry for multi-day queues
    if (showOnlyToday) {
      final today = DateTime.now();
      final todayOnly = DateTime(today.year, today.month, today.day);
      dailyEntries = dailyEntries.where((day) {
        final dayOnly = DateTime(day.year, day.month, day.day);
        return dayOnly.isAtSameMomentAs(todayOnly);
      }).toList();
    }
    final queueKey = queue.name;
    final isQueueExpanded = _multiDayQueueExpanded[queueKey] ?? false;
    final dailyExpandedSet = _dailyEntryExpanded[queueKey] ?? <String>{};
    
    return StreamBuilder<List<Beneficiary>>(
      // Multi Day beneficiaries are stored under day-specific queue keys:
      //   <queue.name>_YYYY-MM-DD
      // so we load by distribution area and filter client-side.
      stream: BeneficiaryService.getBeneficiariesByArea(queue.distributionArea),
      builder: (context, beneficiarySnapshot) {
        final allAreaBeneficiaries = beneficiarySnapshot.hasData ? beneficiarySnapshot.data! : <Beneficiary>[];
        final prefix = '${queue.name}_';
        final beneficiariesForQueue = allAreaBeneficiaries.where((b) {
          final q = b.initialAssignedQueuePoint;
          return q == queue.name || q.startsWith(prefix);
        }).toList();
        
        return Container(
          margin: EdgeInsets.only(bottom: 12, top: displayIndex > 0 ? 24 : 0),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(
              color: Colors.blue.withOpacity(0.3),
              width: 2,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.blue.withOpacity(0.2),
                spreadRadius: 2,
                blurRadius: 8,
                offset: const Offset(0, 4),
              ),
            ],
          ),
          child: ExpansionTile(
            initiallyExpanded: isQueueExpanded,
            onExpansionChanged: (expanded) {
              setState(() {
                _multiDayQueueExpanded[queueKey] = expanded;
              });
            },
            tilePadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            childrenPadding: const EdgeInsets.only(bottom: 8),
            leading: Icon(
              Icons.calendar_today,
              color: Colors.blue.shade700,
            ),
            title: Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          Flexible(
                            child: Text(
                              queue.name,
                              style: const TextStyle(
                                fontSize: 18,
                                fontWeight: FontWeight.bold,
                                color: Color(0xFF1A237E),
                              ),
                              overflow: TextOverflow.ellipsis,
                              maxLines: 1,
                            ),
                          ),
                          const SizedBox(width: 8),
                          Container(
                            padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                            decoration: BoxDecoration(
                              color: Colors.blue.shade100,
                              borderRadius: BorderRadius.circular(4),
                            ),
                            child: Text(
                              'Multi Day',
                              style: TextStyle(
                                fontSize: 10,
                                fontWeight: FontWeight.bold,
                                color: Colors.blue.shade900,
                              ),
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 4),
                      Text(
                        '${queue.displayDateRange} • ${queue.displayTimeRange}',
                        style: TextStyle(
                          fontSize: 12,
                          color: Colors.grey[600],
                        ),
                      ),
                      Text(
                        '${dailyEntries.length} days • ${queue.numberOfAvailableUnits} ${queue.unitName}',
                        style: TextStyle(
                          fontSize: 12,
                          color: Colors.grey[600],
                        ),
                      ),
                    ],
                  ),
                ),
                Column(
                  crossAxisAlignment: CrossAxisAlignment.end,
                  children: [
                    if (!queue.isCompleted) ...[
                      Container(
                        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                        decoration: BoxDecoration(
                          color: queue.status == 'active' 
                              ? Colors.green.withOpacity(0.1)
                              : queue.status == 'suspended'
                                  ? Colors.orange.withOpacity(0.1)
                                  : Colors.red.withOpacity(0.1),
                          borderRadius: BorderRadius.circular(4),
                        ),
                        child: Text(
                          AppLanguage.translate(queue.status),
                          style: TextStyle(
                            fontSize: 12,
                            fontWeight: FontWeight.bold,
                            color: queue.status == 'active'
                                ? Colors.green
                                : queue.status == 'suspended'
                                    ? Colors.orange
                                    : Colors.red,
                          ),
                        ),
                      ),
                    ],
                    if (queue.isCompleted) ...[
                      Container(
                        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                        decoration: BoxDecoration(
                          color: Colors.blue.withOpacity(0.1),
                          borderRadius: BorderRadius.circular(4),
                        ),
                        child: Text(
                          AppLanguage.translate('completed').toUpperCase(),
                          style: const TextStyle(
                            fontSize: 12,
                            fontWeight: FontWeight.bold,
                            color: Colors.blue,
                          ),
                        ),
                      ),
                    ],
                  ],
                ),
              ],
            ),
            subtitle: Padding(
              padding: const EdgeInsets.only(top: 8),
              child: SingleChildScrollView(
                scrollDirection: Axis.horizontal,
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.start,
                  children: [
                    if (!queue.isCompleted) ...[
                      _buildActionButton(
                        icon: Icons.play_arrow,
                        label: AppLanguage.translate('Start'),
                        color: Colors.green,
                        onPressed: () {
                        final updatedQueue = queue.copyWith(
                          isStarted: true,
                          isSuspended: false,
                          status: 'active',
                        );
                        QueueService.getQueueIdByName(queue.name).then((queueId) {
                          if (queueId != null) {
                            QueueService.updateQueue(queueId, updatedQueue).then((_) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text(AppLanguage.translate('Queue started successfully')),
                                  backgroundColor: Colors.green,
                                ),
                              );
                            }).catchError((e) {
                              print('Error starting queue: $e');
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text('Error starting queue: $e'),
                                  backgroundColor: Colors.red,
                                ),
                              );
                            });
                          }
                        });
                      },
                    ),
                    _buildActionButton(
                      icon: queue.isSuspended ? Icons.play_arrow : Icons.pause,
                      label: queue.isSuspended ? AppLanguage.translate('Resume') : AppLanguage.translate('Suspend'),
                      color: Colors.orange,
                      onPressed: () {
                        final newSuspendedState = !queue.isSuspended;
                        final updatedQueue = queue.copyWith(
                          isSuspended: newSuspendedState,
                          status: newSuspendedState ? 'suspended' : 'active',
                        );
                        QueueService.getQueueIdByName(queue.name).then((queueId) {
                          if (queueId != null) {
                            QueueService.updateQueue(queueId, updatedQueue).then((_) {
                              if (mounted) {
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content: Text(newSuspendedState 
                                        ? AppLanguage.translate('Queue suspended successfully')
                                        : AppLanguage.translate('Queue resumed successfully')),
                                    backgroundColor: Colors.orange,
                                  ),
                                );
                              }
                            }).catchError((e) {
                              print('Error updating queue status: $e');
                              if (mounted) {
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content: Text('Error updating queue: $e'),
                                    backgroundColor: Colors.red,
                                  ),
                                );
                              }
                            });
                          }
                        });
                      },
                    ),
                  ],
                  _buildActionButton(
                    icon: Icons.visibility,
                    label: AppLanguage.translate('View'),
                    color: tealGreen,
                    onPressed: () {
                      Navigator.of(context).push(
                        MaterialPageRoute(
                          builder: (context) => QueueViewScreen(
                            queue: queue,
                            beneficiaries: beneficiariesForQueue,
                            onQueueUpdated: (updatedQueue) {
                              QueueService.getQueueIdByName(queue.name).then((queueId) {
                                if (queueId != null) {
                                  QueueService.updateQueue(queueId, updatedQueue);
                                }
                              });
                            },
                            onBeneficiaryUpdated: (beneficiary) {},
                          ),
                        ),
                      );
                    },
                  ),
                  _buildActionButton(
                    icon: Icons.edit,
                    label: AppLanguage.translate('Edit'),
                    color: tealGreen,
                    onPressed: () {
                      Navigator.of(context).push(
                        MaterialPageRoute(
                          builder: (context) => QueueDetailsScreen(
                            queue: queue,
                            distributionAreas: _distributionAreas,
                            onQueueUpdated: (updatedQueue) {
                              QueueService.getQueueIdByName(queue.name).then((queueId) {
                                if (queueId != null) {
                                  QueueService.updateQueue(queueId, updatedQueue);
                                }
                              });
                            },
                          ),
                        ),
                      );
                    },
                  ),
                  _buildActionButton(
                    icon: Icons.delete,
                    label: AppLanguage.translate('Delete'),
                    color: Colors.red,
                    onPressed: () {
                      showDialog(
                        context: context,
                        builder: (context) => AlertDialog(
                          title: Text(AppLanguage.translate('Delete Queue')),
                          content: Text(AppLanguage.translate('Are you sure you want to delete this queue?')),
                          actions: [
                            TextButton(
                              onPressed: () => Navigator.pop(context),
                              child: Text(AppLanguage.translate('Cancel')),
                            ),
                            TextButton(
                              onPressed: () async {
                                try {
                                  final queueId = await QueueService.getQueueIdByName(queue.name);
                                  if (queueId != null) {
                                    await QueueService.deleteQueue(queueId);
                                    Navigator.pop(context);
                                    ScaffoldMessenger.of(context).showSnackBar(
                                      SnackBar(
                                        content: Text(AppLanguage.translate('Queue deleted successfully')),
                                        backgroundColor: Colors.green,
                                      ),
                                    );
                                  } else {
                                    Navigator.pop(context);
                                    ScaffoldMessenger.of(context).showSnackBar(
                                      SnackBar(
                                        content: Text(AppLanguage.translate('Queue not found in Firestore')),
                                        backgroundColor: Colors.orange,
                                      ),
                                    );
                                  }
                                } catch (e) {
                                  Navigator.pop(context);
                                  ScaffoldMessenger.of(context).showSnackBar(
                                    SnackBar(
                                      content: Text('Error deleting queue: $e'),
                                      backgroundColor: Colors.red,
                                    ),
                                  );
                                }
                              },
                              child: Text(AppLanguage.translate('Delete'), style: const TextStyle(color: Colors.red)),
                            ),
                          ],
                        ),
                      );
                    },
                  ),
                  ],
                ),
              ),
            ),
            children: dailyEntries.map((day) {
              final dayKey = '${day.year}-${day.month}-${day.day}';
              final fullDayKey = '$queueKey-$dayKey';
              final isDayExpanded = dailyExpandedSet.contains(fullDayKey);
              final isToday = day.year == DateTime.now().year &&
                              day.month == DateTime.now().month &&
                              day.day == DateTime.now().day;
              final isPast = day.isBefore(DateTime.now().subtract(const Duration(days: 1)));
              final isFuture = day.isAfter(DateTime.now());
              
              // Get beneficiaries for this specific day
              final dayStr =
                  '${day.year}-${day.month.toString().padLeft(2, '0')}-${day.day.toString().padLeft(2, '0')}';
              final dayQueueName = '${queue.name}_$dayStr';
              
              // Use StreamBuilder to check queueHistory for beneficiaries who have queue numbers for this day
              return StreamBuilder<QuerySnapshot>(
                stream: FirebaseService.firestore
                    .collection('queueHistory')
                    .where('dayQueueName', isEqualTo: dayQueueName)
                    .where('action', isEqualTo: 'issued')
                    .snapshots(),
                builder: (context, historySnapshot) {
                  // Get beneficiary IDs from queueHistory for this day
                  final beneficiaryIdsInHistory = historySnapshot.hasData
                      ? historySnapshot.data!.docs.map((doc) => doc.data() as Map<String, dynamic>)
                          .map((data) => data['beneficiaryId'] as String?)
                          .where((id) => id != null)
                          .toSet()
                      : <String>{};
                  
                  // Show beneficiaries who either:
                  // 1. Have initialAssignedQueuePoint matching this specific day, OR
                  // 2. Have a queue number recorded in queueHistory for this day
                  final dayBeneficiaries = beneficiariesForQueue.where((b) {
                    // Check if assigned directly to this day
                    if (b.initialAssignedQueuePoint == dayQueueName) {
                      return true;
                    }
                    // Check if they have a queue number in history for this day
                    if (beneficiaryIdsInHistory.contains(b.id)) {
                      return true;
                    }
                    return false;
                  }).toList();
              
              return Container(
                margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
                decoration: BoxDecoration(
                  color: isToday 
                      ? Colors.blue.shade50
                      : isPast
                          ? Colors.grey.shade100
                          : Colors.green.shade50,
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(
                    color: isToday
                        ? Colors.blue.shade300
                        : Colors.grey.shade300,
                    width: 1,
                  ),
                ),
                child: ExpansionTile(
                  initiallyExpanded: isDayExpanded,
                  onExpansionChanged: (expanded) {
                    setState(() {
                      if (expanded) {
                        dailyExpandedSet.add(fullDayKey);
                      } else {
                        dailyExpandedSet.remove(fullDayKey);
                      }
                      _dailyEntryExpanded[queueKey] = dailyExpandedSet;
                    });
                  },
                  tilePadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                  childrenPadding: const EdgeInsets.only(bottom: 8, left: 16, right: 16),
                  leading: Icon(
                    isToday 
                        ? Icons.today
                        : isPast
                            ? Icons.history
                            : Icons.event,
                    color: isToday
                        ? Colors.blue.shade700
                        : isPast
                            ? Colors.grey.shade600
                            : Colors.green.shade700,
                    size: 20,
                  ),
                  title: Row(
                    children: [
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              '${day.day}/${day.month}/${day.year}',
                              style: TextStyle(
                                fontSize: 14,
                                fontWeight: isToday ? FontWeight.bold : FontWeight.normal,
                                color: isToday
                                    ? Colors.blue.shade900
                                    : isPast
                                        ? Colors.grey.shade700
                                        : Colors.green.shade900,
                              ),
                            ),
                            Text(
                              '${queue.fromTime.format(context)} - ${queue.toTime.format(context)}',
                              style: TextStyle(
                                fontSize: 12,
                                color: Colors.grey[600],
                              ),
                            ),
                          ],
                        ),
                      ),
                      if (isToday) ...[
                        Container(
                          padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                          decoration: BoxDecoration(
                            color: Colors.blue.shade200,
                            borderRadius: BorderRadius.circular(4),
                          ),
                          child: Text(
                            'Today',
                            style: TextStyle(
                              fontSize: 10,
                              fontWeight: FontWeight.bold,
                              color: Colors.blue.shade900,
                            ),
                          ),
                        ),
                      ],
                    ],
                  ),
                  subtitle: Padding(
                    padding: const EdgeInsets.only(top: 4),
                    child: Text(
                      '${dayBeneficiaries.length} beneficiaries',
                      style: TextStyle(
                        fontSize: 11,
                        color: Colors.grey[600],
                        fontStyle: FontStyle.italic,
                      ),
                    ),
                  ),
                  children: [
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: Colors.grey.shade50,
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            'Day Details',
                            style: TextStyle(
                              fontSize: 12,
                              fontWeight: FontWeight.bold,
                              color: Colors.grey[800],
                            ),
                          ),
                          const SizedBox(height: 8),
                          Row(
                            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                            children: [
                              Text(
                                'Status: ${isPast ? 'Past' : (isToday ? 'Today' : 'Upcoming')}',
                                style: TextStyle(
                                  fontSize: 11,
                                  color: isPast ? Colors.grey : (isToday ? Colors.blue : Colors.green),
                                ),
                              ),
                              Text(
                                'Time: ${queue.fromTime.format(context)} - ${queue.toTime.format(context)}',
                                style: TextStyle(
                                  fontSize: 11,
                                  color: Colors.grey[700],
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(height: 8),
                          Text(
                            'Beneficiaries: ${dayBeneficiaries.length} registered',
                            style: TextStyle(
                              fontSize: 11,
                              color: Colors.blue,
                            ),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(height: 12),
                    // Action buttons for this specific day
                    SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.start,
                        children: [
                          if (!isPast) ...[
                            // Start/Serve button for this day
                            // For today, label is "Serve", for future days label is "Start"
                            _buildActionButton(
                            icon: isToday ? _getUnitIcon(queue.unitName) : Icons.play_arrow,
                            label: isToday ? AppLanguage.translate('Serve') : AppLanguage.translate('Start'),
                            color: isToday ? Colors.orange : Colors.green,
                            onPressed: () {
                              // Start serving for this specific day
                              // Create a day-specific queue representation
                              final dayQueue = queue.copyWith(
                                fromDate: DateTime(day.year, day.month, day.day),
                                toDate: DateTime(day.year, day.month, day.day),
                                isStarted: true,
                                isSuspended: false,
                                status: 'active',
                              );
                              
                              // Navigate to serving screen for this day
                              Navigator.of(context).push(
                                MaterialPageRoute(
                                  builder: (context) => QueueServingScreen(
                                    queue: dayQueue,
                                    beneficiaries: dayBeneficiaries,
                                    onQueueUpdated: (updatedQueue) {
                                      // Update the parent queue in Firestore
                                      QueueService.getQueueIdByName(queue.name).then((queueId) {
                                        if (queueId != null) {
                                          QueueService.updateQueue(queueId, updatedQueue);
                                        }
                                      });
                                    },
                                    onBeneficiaryUpdated: (beneficiary) {
                                      // Update beneficiary in Firestore
                                      BeneficiaryService.updateBeneficiary(beneficiary.id, beneficiary);
                                    },
                                  ),
                                ),
                              );
                            },
                          ),
                        ],
                        // View button - always available
                        _buildActionButton(
                          icon: Icons.visibility,
                          label: AppLanguage.translate('View'),
                          color: tealGreen,
                          onPressed: () {
                            // View queue details for this specific day
                            final dayQueue = queue.copyWith(
                              fromDate: DateTime(day.year, day.month, day.day),
                              toDate: DateTime(day.year, day.month, day.day),
                            );
                            
                            Navigator.of(context).push(
                              MaterialPageRoute(
                                builder: (context) => QueueViewScreen(
                                  queue: dayQueue,
                                  beneficiaries: dayBeneficiaries,
                                  onQueueUpdated: (updatedQueue) {
                                    QueueService.getQueueIdByName(queue.name).then((queueId) {
                                      if (queueId != null) {
                                        QueueService.updateQueue(queueId, updatedQueue);
                                      }
                                    });
                                  },
                                  onBeneficiaryUpdated: (beneficiary) {
                                    BeneficiaryService.updateBeneficiary(beneficiary.id, beneficiary);
                                  },
                                ),
                              ),
                            );
                          },
                        ),
                        // Serve button - only available for future days (not today)
                        if (!isPast && !isToday) ...[
                          _buildActionButton(
                            icon: _getUnitIcon(queue.unitName),
                            label: AppLanguage.translate('Serve'),
                            color: Colors.orange,
                            onPressed: () {
                              // Navigate to serving screen for this specific day
                              final dayQueue = queue.copyWith(
                                fromDate: DateTime(day.year, day.month, day.day),
                                toDate: DateTime(day.year, day.month, day.day),
                              );
                              
                              Navigator.of(context).push(
                                MaterialPageRoute(
                                  builder: (context) => QueueServingScreen(
                                    queue: dayQueue,
                                    beneficiaries: dayBeneficiaries,
                                    onQueueUpdated: (updatedQueue) {
                                      QueueService.getQueueIdByName(queue.name).then((queueId) {
                                        if (queueId != null) {
                                          QueueService.updateQueue(queueId, updatedQueue);
                                        }
                                      });
                                    },
                                    onBeneficiaryUpdated: (beneficiary) {
                                      BeneficiaryService.updateBeneficiary(beneficiary.id, beneficiary);
                                    },
                                  ),
                                ),
                              );
                            },
                          ),
                        ],
                        ],
                      ),
                    ),
                  ],
                ),
              );
                },
              );
            }).toList(),
          ),
        );
      },
    );
  }

  Widget _buildQueueRow(Queue queue, int displayIndex) {
    const tealGreen = Color(0xFF81CF01);
    // Beneficiaries are loaded from Firestore - use StreamBuilder to get them
    // For now, we'll get the count from Firestore stream
    return StreamBuilder<List<Beneficiary>>(
      stream: BeneficiaryService.getBeneficiariesByQueueName(queue.name),
      builder: (context, beneficiarySnapshot) {
        final beneficiariesForQueue = beneficiarySnapshot.hasData 
            ? beneficiarySnapshot.data! 
            : <Beneficiary>[];
    
    return Container(
      margin: EdgeInsets.only(bottom: 12, top: displayIndex > 0 ? 24 : 0),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: Colors.grey.withOpacity(0.3),
          width: 1,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.2),
            spreadRadius: 2,
            blurRadius: 8,
            offset: const Offset(0, 4),
          ),
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            spreadRadius: 1,
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          InkWell(
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => QueueViewScreen(
                    queue: queue,
                    beneficiaries: beneficiariesForQueue, // Use beneficiaries from Firestore stream
                    onQueueUpdated: (updatedQueue) {
                      // Update in Firestore - changes will be reflected via StreamBuilder
                      QueueService.getQueueIdByName(queue.name).then((queueId) {
                        if (queueId != null) {
                          QueueService.updateQueue(queueId, updatedQueue).catchError((e) {
                            print('Error updating queue: $e');
                            ScaffoldMessenger.of(context).showSnackBar(
                              SnackBar(content: Text('Error updating queue: $e')),
                            );
                          });
                        }
                      });
                    },
                    onBeneficiaryUpdated: (beneficiary) {
                      // Beneficiary updates are handled in Firestore, no need to update local list
                      // The StreamBuilder will automatically reflect the changes
                    },
                  ),
                ),
              );
            },
            child: Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        queue.name,
                        style: const TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                          color: Color(0xFF1A237E),
                        ),
                      ),
                    ],
                  ),
                ),
                Column(
                  crossAxisAlignment: CrossAxisAlignment.end,
                  children: [
                    Row(
                      children: [
                        // Only show status badge if queue is not completed
                        if (!queue.isCompleted) ...[
                          Container(
                            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                            decoration: BoxDecoration(
                              color: queue.status == 'active' 
                                  ? Colors.green.withOpacity(0.1)
                                  : queue.status == 'suspended'
                                      ? Colors.orange.withOpacity(0.1)
                                      : Colors.red.withOpacity(0.1),
                              borderRadius: BorderRadius.circular(4),
                            ),
                            child: Text(
                              AppLanguage.translate(queue.status),
                              style: TextStyle(
                                fontSize: 12,
                                fontWeight: FontWeight.bold,
                                color: queue.status == 'active'
                                    ? Colors.green
                                    : queue.status == 'suspended'
                                        ? Colors.orange
                                        : Colors.red,
                              ),
                            ),
                          ),
                        ],
                        // Show blue completed badge when queue is completed
                        if (queue.isCompleted) ...[
                          Container(
                            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                            decoration: BoxDecoration(
                              color: Colors.blue.withOpacity(0.1),
                              borderRadius: BorderRadius.circular(4),
                            ),
                            child: Text(
                              AppLanguage.translate('completed').toUpperCase(),
                              style: const TextStyle(
                                fontSize: 12,
                                fontWeight: FontWeight.bold,
                                color: Colors.blue,
                              ),
                            ),
                          ),
                        ],
                      ],
                    ),
                    const SizedBox(height: 8),
                    Icon(Icons.visibility, color: tealGreen),
                  ],
                ),
              ],
            ),
          ),
          const SizedBox(height: 12),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              if (!queue.isCompleted) ...[
                Column(
                  children: [
                    IconButton(
                      onPressed: () {
                        // Update queue in Firestore - Start queue (set to active status)
                        final updatedQueue = queue.copyWith(
                          isStarted: true,
                          isSuspended: false,
                          status: 'active',
                        );
                        QueueService.getQueueIdByName(queue.name).then((queueId) {
                          if (queueId != null) {
                            QueueService.updateQueue(queueId, updatedQueue).then((_) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text(AppLanguage.translate('Queue started successfully')),
                                  backgroundColor: Colors.green,
                                ),
                              );
                            }).catchError((e) {
                              print('Error starting queue: $e');
                              if (mounted) {
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content: Text('Error starting queue: $e'),
                                    backgroundColor: Colors.red,
                                  ),
                                );
                              }
                            });
                          } else {
                            if (mounted) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text(AppLanguage.translate('Queue not found in Firestore')),
                                  backgroundColor: Colors.orange,
                                ),
                              );
                            }
                          }
                        });
                        Navigator.of(context).push(
                          MaterialPageRoute(
                            builder: (context) => QueueServingScreen(
                              queue: updatedQueue,
                              beneficiaries: [], // Will be loaded from Firebase in the screen
                              onQueueUpdated: (updatedQueue) {
                                // Update in Firestore
                                QueueService.getQueueIdByName(queue.name).then((queueId) {
                                  if (queueId != null) {
                                    QueueService.updateQueue(queueId, updatedQueue).then((_) {
                                      ScaffoldMessenger.of(context).showSnackBar(
                                        SnackBar(
                                          content: Text(AppLanguage.translate('Queue updated successfully')),
                                          backgroundColor: Colors.green,
                                        ),
                                      );
                                    }).catchError((e) {
                                      print('Error updating queue: $e');
                                      ScaffoldMessenger.of(context).showSnackBar(
                                        SnackBar(
                                          content: Text('${AppLanguage.translate('Error updating queue:')} $e'),
                                          backgroundColor: Colors.red,
                                        ),
                                      );
                                    });
                                  }
                                });
                              },
                              onBeneficiaryUpdated: (beneficiary) {
                                final beneficiaryIndex = _beneficiaries.indexWhere((b) => b.id == beneficiary.id);
                                if (beneficiaryIndex != -1) {
                                  _updateBeneficiary(beneficiaryIndex, beneficiary);
                                }
                              },
                            ),
                          ),
                        );
                      },
                      icon: const Icon(Icons.play_arrow, color: Colors.green),
                      style: IconButton.styleFrom(
                        backgroundColor: Colors.green.withOpacity(0.1),
                        padding: const EdgeInsets.all(12),
                      ),
                    ),
                    const SizedBox(height: 4),
                    const Text(
                      'Start',
                      style: TextStyle(fontSize: 10),
                    ),
                  ],
                ),
                // Hide suspend button for today's queues in dashboard
                // Column(
                //   children: [
                //     IconButton(
                //       onPressed: () {
                //         // Update queue in Firestore - Toggle suspend/resume
                //         final newSuspendedState = !queue.isSuspended;
                //         final updatedQueue = queue.copyWith(
                //           isSuspended: newSuspendedState,
                //           status: newSuspendedState ? 'suspended' : 'active',
                //         );
                //         QueueService.getQueueIdByName(queue.name).then((queueId) {
                //           if (queueId != null) {
                //             QueueService.updateQueue(queueId, updatedQueue).then((_) {
                //               ScaffoldMessenger.of(context).showSnackBar(
                //                 SnackBar(
                //                   content: Text(newSuspendedState
                //                       ? AppLanguage.translate('Queue suspended successfully')
                //                       : AppLanguage.translate('Queue resumed successfully')),
                //                   backgroundColor: Colors.orange,
                //                 ),
                //               );
                //             }).catchError((e) {
                //               print('Error updating queue status: $e');
                //               ScaffoldMessenger.of(context).showSnackBar(
                //                 SnackBar(
                //                   content: Text('Error updating queue: $e'),
                //                   backgroundColor: Colors.red,
                //                 ),
                //               );
                //             });
                //           } else {
                //             ScaffoldMessenger.of(context).showSnackBar(
                //               SnackBar(
                //                 content: Text(AppLanguage.translate('Queue not found in Firestore')),
                //                 backgroundColor: Colors.orange,
                //               ),
                //             );
                //           }
                //         });
                //       },
                //       icon: Icon(queue.isSuspended ? Icons.play_arrow : Icons.pause, color: Colors.orange),
                //       style: IconButton.styleFrom(
                //         backgroundColor: Colors.orange.withOpacity(0.1),
                //         padding: const EdgeInsets.all(12),
                //       ),
                //     ),
                //     const SizedBox(height: 4),
                //     Text(
                //       queue.isSuspended ? AppLanguage.translate('Resume') : AppLanguage.translate('Suspend'),
                //       style: const TextStyle(fontSize: 10),
                //     ),
                //   ],
                // ),
                Column(
                  children: [
                    IconButton(
                      onPressed: () {
                        // Update queue in Firestore - Complete queue
                        final updatedQueue = queue.copyWith(
                          isCompleted: true,
                          isSuspended: false,
                          status: 'completed',
                        );
                        QueueService.getQueueIdByName(queue.name).then((queueId) {
                          if (queueId != null) {
                            QueueService.updateQueue(queueId, updatedQueue).then((_) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text(AppLanguage.translate('Queue completed successfully')),
                                  backgroundColor: Colors.blue,
                                ),
                              );
                            }).catchError((e) {
                              print('Error completing queue: $e');
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text('${AppLanguage.translate('Error completing queue:')} $e'),
                                  backgroundColor: Colors.red,
                                ),
                              );
                            });
                          } else {
                            ScaffoldMessenger.of(context).showSnackBar(
                              SnackBar(
                                content: Text(AppLanguage.translate('Queue not found in Firestore')),
                                backgroundColor: Colors.orange,
                              ),
                            );
                          }
                        });
                      },
                      icon: const Icon(Icons.check_circle, color: Colors.blue),
                      style: IconButton.styleFrom(
                        backgroundColor: Colors.blue.withOpacity(0.1),
                        padding: const EdgeInsets.all(12),
                      ),
                    ),
                    const SizedBox(height: 4),
                  Text(
                    AppLanguage.translate('Complete'),
                    style: const TextStyle(fontSize: 10),
                  ),
                  ],
                ),
              ],
              Column(
                children: [
                  IconButton(
                    onPressed: () {
                      Navigator.of(context).push(
                        MaterialPageRoute(
                          builder: (context) => QueueDetailsScreen(
                            queue: queue,
                            distributionAreas: _distributionAreas,
                            onQueueUpdated: (updatedQueue) {
                      // Update in Firestore - changes will be reflected via StreamBuilder
                      // Note: Success/error messages are already shown in QueueDetailsScreen,
                      // so we don't need to show them here to avoid context disposal issues
                      QueueService.getQueueIdByName(queue.name).then((queueId) {
                        if (queueId != null) {
                          QueueService.updateQueue(queueId, updatedQueue).catchError((e) {
                            print('Error updating queue: $e');
                            // Error will be handled by QueueDetailsScreen
                          });
                        } else {
                          print('Queue not found in Firestore');
                        }
                      }).catchError((e) {
                        print('Error getting queue ID: $e');
                        // Error will be handled by QueueDetailsScreen
                      });
                    },
                          ),
                        ),
                      );
                    },
                    icon: const Icon(Icons.edit, color: tealGreen),
                    style: IconButton.styleFrom(
                      backgroundColor: tealGreen.withOpacity(0.1),
                      padding: const EdgeInsets.all(12),
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    AppLanguage.translate('Edit'),
                    style: const TextStyle(fontSize: 10),
                  ),
                ],
              ),
              Column(
                children: [
                  IconButton(
                    onPressed: () {
                      showDialog(
                        context: context,
                        builder: (context) => AlertDialog(
                          title: Text(AppLanguage.translate('Delete Queue')),
                          content: Text(AppLanguage.translate('Are you sure you want to delete this queue?')),
                          actions: [
                            TextButton(
                              onPressed: () => Navigator.pop(context),
                              child: Text(AppLanguage.translate('Cancel')),
                            ),
                            TextButton(
                              onPressed: () async {
                                // Find queue ID by name and delete from Firestore
                                try {
                                  final queueId = await QueueService.getQueueIdByName(queue.name);
                                  if (queueId != null) {
                                    await QueueService.deleteQueue(queueId);
                                    Navigator.pop(context);
                                    ScaffoldMessenger.of(context).showSnackBar(
                                      SnackBar(
                                        content: Text(AppLanguage.translate('Queue deleted successfully')),
                                        backgroundColor: Colors.green,
                                      ),
                                    );
                                  } else {
                                    Navigator.pop(context);
                                    ScaffoldMessenger.of(context).showSnackBar(
                                      SnackBar(
                                        content: Text(AppLanguage.translate('Queue not found in Firestore')),
                                        backgroundColor: Colors.orange,
                                      ),
                                    );
                                  }
                                } catch (e) {
                                  Navigator.pop(context);
                                  ScaffoldMessenger.of(context).showSnackBar(
                                    SnackBar(
                                      content: Text('Error deleting queue: $e'),
                                      backgroundColor: Colors.red,
                                    ),
                                  );
                                }
                              },
                              child: Text(AppLanguage.translate('Delete'), style: const TextStyle(color: Colors.red)),
                            ),
                          ],
                        ),
                      );
                    },
                    icon: const Icon(Icons.delete, color: Colors.red),
                    style: IconButton.styleFrom(
                      backgroundColor: Colors.red.withOpacity(0.1),
                      padding: const EdgeInsets.all(12),
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    AppLanguage.translate('Delete'),
                    style: const TextStyle(fontSize: 10),
                  ),
                ],
              ),
            ],
          ),
        ],
      ),
    );
      },
    );
  }

  Widget _buildActionButton({
    required IconData icon,
    required String label,
    required Color color,
    required VoidCallback onPressed,
  }) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        IconButton(
          onPressed: onPressed,
          icon: Icon(icon, color: color),
          style: IconButton.styleFrom(
            backgroundColor: color.withOpacity(0.1),
            padding: const EdgeInsets.all(8),
          ),
        ),
        const SizedBox(height: 2),
        Text(
          label,
          style: const TextStyle(fontSize: 10),
        ),
      ],
    );
  }

  Widget _getScreen() {
    switch (_selectedIndex) {
      case 0: // Dashboard
        return GestureDetector(
          onTap: () {
            // Dismiss keyboard when tapping anywhere on the dashboard
            FocusScope.of(context).unfocus();
          },
          child: Container(
            decoration: const BoxDecoration(
              gradient: LinearGradient(
                begin: Alignment.topCenter,
                end: Alignment.bottomCenter,
                colors: [Color(0xFFE8F5E9), Colors.white],
              ),
            ),
          child: SafeArea(
            child: LayoutBuilder(
              builder: (context, constraints) {
                final isLandscape = MediaQuery.of(context).orientation == Orientation.landscape;
                final availableHeight = constraints.maxHeight;
                final padding = isLandscape ? 8.0 : 16.0;
                final spacing = isLandscape ? 4.0 : 8.0;
                
                return GestureDetector(
                  onTap: () {
                    // Dismiss keyboard when tapping anywhere on the dashboard
                    FocusScope.of(context).unfocus();
                  },
                  behavior: HitTestBehavior.opaque,
                  child: Column(
                    children: [
                      Padding(
                        padding: EdgeInsets.all(padding),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              AppLanguage.translate('Distribution Area'),
                              style: TextStyle(
                                fontSize: isLandscape ? 14 : 16,
                                fontWeight: FontWeight.w600,
                                color: const Color(0xFF1A237E),
                              ),
                            ),
                            SizedBox(height: spacing),
                            StreamBuilder<List<DistributionArea>>(
                              stream: DistributionAreaService.getAllAreas(),
                              initialData: _distributionAreas, // Use local list as initial data to prevent multiple loads
                              builder: (context, snapshot) {
                              // Get current admin to filter areas
                              final currentAdmin = AdminService.currentAdmin;
                              
                              // Always show dropdown, use local list if stream hasn't loaded yet or has error
                              List<DistributionArea> displayAreas;
                              
                              if (snapshot.connectionState == ConnectionState.waiting && snapshot.data == null) {
                                // Still loading and no data yet - use local list
                                displayAreas = _distributionAreas;
                              } else if (snapshot.hasError) {
                                // Error occurred - use local list
                                print('StreamBuilder error: ${snapshot.error}');
                                displayAreas = _distributionAreas;
                              } else {
                                // Use Firestore data if available, otherwise fall back to local
                                final firestoreAreas = snapshot.data ?? [];
                                // Prefer Firestore data, but ensure no duplicates
                                if (firestoreAreas.isNotEmpty) {
                                  // Remove duplicates by ID
                                  final uniqueMap = <String, DistributionArea>{};
                                  for (final area in firestoreAreas) {
                                    if (!uniqueMap.containsKey(area.id)) {
                                      uniqueMap[area.id] = area;
                                    }
                                  }
                                  displayAreas = uniqueMap.values.toList();
                                } else {
                                  displayAreas = _distributionAreas;
                                }
                              }
                              
                              // Filter based on admin role (same logic as Add New Queue screen)
                              if (currentAdmin != null && displayAreas.isNotEmpty) {
                                final role = currentAdmin.role ?? '';
                                final distributionPoint = currentAdmin.distributionPoint ?? '';
                                final isSuperAdmin = currentAdmin.isSuperAdmin;
                                final isTestSuperAdmin = currentAdmin.mobile == '01010646279';
                                
                                final roleLower = role.toLowerCase().trim();
                                final distPointLower = distributionPoint.toLowerCase().trim();
                                
                                final isSuperAdminRole = isSuperAdmin || 
                                    roleLower == 'super_admin' ||
                                    roleLower == 'superadmin' ||
                                    (roleLower.contains('super') && roleLower.contains('admin')) ||
                                    distPointLower == 'all' ||
                                    isTestSuperAdmin;
                                
                                if (isSuperAdminRole) {
                                  // Super Admin sees ALL areas from Firestore
                                  displayAreas = List<DistributionArea>.from(displayAreas);
                                } else if ((currentAdmin.isAdmin || currentAdmin.isQAdmin) && distributionPoint.isNotEmpty && distPointLower != 'all') {
                                  // Admin/Q_Admin sees only their assigned areas
                                  displayAreas = displayAreas.where((area) {
                                    final adminPoint = distributionPoint.toLowerCase();
                                    final areaName = area.areaName.toLowerCase();
                                    return areaName.contains(adminPoint) || adminPoint.contains(areaName);
                                  }).toList();
                                }
                              }
                              
                              // Update local list only once when data changes (avoid multiple setState calls)
                              if (snapshot.hasData && snapshot.data!.isNotEmpty) {
                                // Remove duplicates before comparing
                                final uniqueMap = <String, DistributionArea>{};
                                for (final area in snapshot.data!) {
                                  if (!uniqueMap.containsKey(area.id)) {
                                    uniqueMap[area.id] = area;
                                  }
                                }
                                final uniqueFirestoreAreas = uniqueMap.values.toList();
                                
                                final currentIds = _distributionAreas.map((a) => a.id).toSet();
                                final newIds = uniqueFirestoreAreas.map((a) => a.id).toSet();
                                final hasChanged = currentIds.length != newIds.length || 
                                    !currentIds.containsAll(newIds) ||
                                    !newIds.containsAll(currentIds);
                                
                                if (hasChanged) {
                                  WidgetsBinding.instance.addPostFrameCallback((_) {
                                    if (mounted) {
                                      setState(() {
                                        _distributionAreas = uniqueFirestoreAreas;
                                        // Auto-select first area if only one is available for non-super-admins
                                        if (displayAreas.length == 1 && 
                                            _selectedDistributionArea == null && 
                                            currentAdmin != null &&
                                            !(currentAdmin.isSuperAdmin || currentAdmin.mobile == '01010646279')) {
                                          _selectedDistributionArea = displayAreas.first.id;
                                        }
                                      });
                                    }
                                  });
                                }
                              }
                              
                              // Build dropdown items
                              final dropdownItems = <DropdownMenuItem<String>>[];
                              
                              // Only show "All Areas" if admin has multiple areas assigned or is Super Admin
                              final showAllAreasOption = displayAreas.length > 1 || 
                                  (currentAdmin?.isSuperAdmin ?? false) || 
                                  (currentAdmin?.mobile == '01010646279');
                              
                              if (showAllAreasOption) {
                                dropdownItems.add(
                                    DropdownMenuItem<String>(
                                      value: null,
                                      child: Text(AppLanguage.translate('All Areas')),
                                    ),
                                );
                              }
                              
                              // Remove duplicates by ID before adding to dropdown
                              final uniqueAreas = <String, DistributionArea>{};
                              for (final area in displayAreas) {
                                if (!uniqueAreas.containsKey(area.id)) {
                                  uniqueAreas[area.id] = area;
                                }
                              }
                              
                              // Add all unique area items
                              for (final area in uniqueAreas.values) {
                                dropdownItems.add(
                                  DropdownMenuItem<String>(
                                      value: area.id,
                                      child: Text(
                                        area.fullName,
                                        overflow: TextOverflow.ellipsis,
                                        maxLines: 1,
                                    ),
                                  ),
                                );
                              }
                              
                              return Container(
                                padding: const EdgeInsets.symmetric(horizontal: 16),
                                decoration: BoxDecoration(
                                  border: Border.all(color: const Color(0xFFE0E0E0)),
                                  borderRadius: BorderRadius.circular(8),
                                  color: Colors.white,
                                ),
                                child: DropdownButtonHideUnderline(
                                  child: DropdownButton<String>(
                                    value: _getValidSelectedArea(),
                                    isExpanded: true,
                                    hint: Text(AppLanguage.translate('Select Distribution Area')),
                                    items: dropdownItems,
                                    focusNode: FocusNode(skipTraversal: true), // Prevent keyboard from appearing
                                    onChanged: (value) {
                                      // Dismiss keyboard when dropdown value changes
                                      FocusScope.of(context).unfocus();
                                      setState(() {
                                        _selectedDistributionArea = value;
                                      });
                                    },
                              ),
                            ),
                              );
                            },
                          ),
                        ],
                      ),
                    ),
                    StreamBuilder<List<Queue>>(
                      stream: QueueService.getAllQueues(),
                      builder: (context, snapshot) {
                        // Get queues from snapshot with proper type
                        final List<Queue> allQueues = snapshot.hasData 
                            ? (snapshot.data! as List<Queue>)
                            : <Queue>[];
                        
                        // Update local queues list from Firestore (for use in other parts of the app)
                        if (snapshot.hasData) {
                          WidgetsBinding.instance.addPostFrameCallback((_) {
                            if (mounted && _queues != allQueues) {
                              setState(() {
                                _queues = allQueues;
                              });
                            }
                          });
                        }
                        
                        // Super Admin or admin with distributionPoint == "All" can see all queues
                        final currentAdmin = AdminService.currentAdmin;
                        List<Queue> adminQueues;
                        
                        if (currentAdmin != null && 
                            (currentAdmin.isSuperAdmin || currentAdmin.distributionPoint.toLowerCase() == 'all')) {
                          // Show all queues, filter by selected distribution area if one is selected
                          if (_selectedDistributionArea != null) {
                            adminQueues = allQueues.where((q) => q.distributionArea == _selectedDistributionArea).toList();
                          } else {
                            adminQueues = allQueues;
                          }
                        } else {
                        // Get admin's assigned distribution area IDs
                        final adminAreas = _distributionAreas.map((area) => area.id).toList();
                        
                        // Filter queues by admin's distribution areas
                          adminQueues = allQueues.where((q) => adminAreas.contains(q.distributionArea)).toList();
                        
                        // Further filter by selected distribution area if one is selected
                        if (_selectedDistributionArea != null) {
                          adminQueues = adminQueues.where((q) => q.distributionArea == _selectedDistributionArea).toList();
                          }
                        }
                        
                        final totalQueues = adminQueues.length;
                        final activeQueues = adminQueues.where((q) => q.status == 'active' && !q.isCompleted).length;
                        
                        // For dashboard performance, skip loading all beneficiaries - just show queues
                        // Beneficiary count can be calculated on demand if needed
                        return Padding(
                          padding: EdgeInsets.symmetric(horizontal: isLandscape ? 8.0 : 16.0),
                          child: Row(
                            children: [
                              _buildSummaryCard('Total Queues', totalQueues, Icons.queue, Colors.blue, isLandscape: isLandscape),
                              SizedBox(width: isLandscape ? 4 : 8),
                              _buildSummaryCard('Active Queues', activeQueues, Icons.check_circle, Colors.green, isLandscape: isLandscape),
                              SizedBox(width: isLandscape ? 4 : 8),
                              _buildSummaryCard('Beneficiaries', '-', Icons.people, Colors.orange, isLandscape: isLandscape),
                            ],
                          ),
                        );
                      },
                    ),
                    SizedBox(height: isLandscape ? 8 : 16),
                    Expanded(
                      child: Container(
                        padding: EdgeInsets.all(isLandscape ? 8.0 : 16.0),
                        decoration: const BoxDecoration(
                          color: Colors.white,
                          borderRadius: BorderRadius.only(
                            topLeft: Radius.circular(24),
                            topRight: Radius.circular(24),
                          ),
                        ),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              AppLanguage.translate('Our Queue List'),
                              style: TextStyle(
                                fontSize: isLandscape ? 16 : 20,
                                fontWeight: FontWeight.bold,
                                color: const Color(0xFF1A237E),
                              ),
                            ),
                            SizedBox(height: isLandscape ? 6 : 12),
                            Expanded(
                              child: StreamBuilder<List<Queue>>(
                                stream: QueueService.getAllQueues(),
                                builder: (context, snapshot) {
                                  // Show loader only on initial connection, not on active streams
                                  if (snapshot.connectionState == ConnectionState.waiting && !snapshot.hasData) {
                                    return const Center(child: CircularProgressIndicator());
                                  }
                                  
                                  if (snapshot.hasError) {
                                    return Center(
                                      child: Padding(
                                        padding: const EdgeInsets.all(16.0),
                                        child: Column(
                                          mainAxisAlignment: MainAxisAlignment.center,
                                          children: [
                                            Icon(Icons.error_outline, size: 48, color: Colors.red[300]),
                                            const SizedBox(height: 16),
                                            Text(
                                              'Error loading queues',
                                              style: TextStyle(
                                                fontSize: 16,
                                                fontWeight: FontWeight.w500,
                                                color: Colors.red[700],
                                              ),
                                            ),
                                            const SizedBox(height: 8),
                                            Text(
                                              '${snapshot.error}',
                                              style: TextStyle(
                                                fontSize: 12,
                                                color: Colors.grey[600],
                                              ),
                                              textAlign: TextAlign.center,
                                            ),
                                          ],
                                        ),
                                      ),
                                    );
                                  }
                                  
                                  // Get queues from snapshot with proper type
                                  final List<Queue> queuesFromSnapshot = snapshot.hasData 
                                      ? (snapshot.data! as List<Queue>)
                                      : <Queue>[];
                                  
                                  // Note: _queues is already updated by the first StreamBuilder above
                                  // No need to update again here to avoid redundant setState calls
                                  
                                  // Super Admin can see all queues
                                  final currentAdmin = AdminService.currentAdmin;
                                  List<Queue> filteredQueues;
                                  
                                  if (currentAdmin != null && currentAdmin.isSuperAdmin) {
                                    // Show all queues, filter by selected distribution area if one is selected
                                    if (_selectedDistributionArea != null) {
                                      filteredQueues = queuesFromSnapshot.where((q) => q.distributionArea == _selectedDistributionArea).toList();
                                    } else {
                                      filteredQueues = queuesFromSnapshot;
                                    }
                                  } else {
                                  // Get admin's assigned distribution area IDs
                                  final adminAreas = _distributionAreas.map((area) => area.id).toList();
                                  
                                  // Filter queues by admin's distribution areas directly from snapshot
                                    filteredQueues = queuesFromSnapshot.where((q) => adminAreas.contains(q.distributionArea)).toList();
                                  
                                  // Further filter by selected distribution area if one is selected
                                  if (_selectedDistributionArea != null) {
                                    filteredQueues = filteredQueues.where((q) => q.distributionArea == _selectedDistributionArea).toList();
                                    }
                                  }
                                  
                                  // Filter to show only today's queues (queues active today)
                                  final today = DateTime.now();
                                  final todayOnly = DateTime(today.year, today.month, today.day);
                                  filteredQueues = filteredQueues.where((q) {
                                    final fromDateOnly = DateTime(q.fromDate.year, q.fromDate.month, q.fromDate.day);
                                    final toDateOnly = DateTime(q.toDate.year, q.toDate.month, q.toDate.day);
                                    // Include queue if today falls between fromDate and toDate (inclusive)
                                    return todayOnly.compareTo(fromDateOnly) >= 0 && todayOnly.compareTo(toDateOnly) <= 0;
                                  }).toList();
                                  
                                  if (filteredQueues.isEmpty) {
                                    return Center(
                                      child: Padding(
                                        padding: const EdgeInsets.all(32.0),
                                        child: Column(
                                          mainAxisAlignment: MainAxisAlignment.center,
                                          children: [
                                            Icon(
                                              Icons.queue_outlined,
                                              size: 64,
                                              color: Colors.grey[400],
                                            ),
                                            const SizedBox(height: 16),
                                            Text(
                                              'Please Add new queue',
                                              style: TextStyle(
                                                fontSize: 18,
                                                fontWeight: FontWeight.w500,
                                                color: Colors.grey[700],
                                              ),
                                            ),
                                            const SizedBox(height: 8),
                                            Text(
                                              _selectedDistributionArea == null
                                                  ? 'No queues found for your distribution area'
                                                  : 'No queues found for selected area',
                                              style: TextStyle(
                                                fontSize: 14,
                                                color: Colors.grey[500],
                                              ),
                                              textAlign: TextAlign.center,
                                            ),
                                          ],
                                        ),
                                      ),
                                    );
                                  }
                                  
                                  // Create a local immutable copy to prevent race conditions
                                  final queuesToDisplay = List<Queue>.unmodifiable(filteredQueues);
                                  final queueCount = queuesToDisplay.length;
                                  
                                  return ListView.builder(
                                    key: ValueKey('queues_$queueCount'), // Force rebuild if count changes
                                    itemCount: queueCount,
                                    padding: const EdgeInsets.only(bottom: 16),
                                    itemBuilder: (context, index) {
                                      // Triple-check bounds to prevent index errors
                                      if (index < 0 || index >= queueCount || index >= queuesToDisplay.length) {
                                        return const SizedBox.shrink();
                                      }
                                      final queue = queuesToDisplay[index];
                                      // Use accordion for Multi Day queues, regular row for Single Day
                                      if (queue.isMultiDay) {
                                        return _buildMultiDayQueueAccordion(queue, index, showOnlyToday: true);
                                      } else {
                                        return _buildQueueRow(queue, index);
                                      }
                                    },
                                  );
                                },
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ],
                ),
                );
              },
            ),
          ),
        ),
        );
      case 1: // Add Queue
        return NewQueueScreen(
          onQueueCreated: (queue) {
            _addQueue(queue);
            setState(() {
              _selectedIndex = 0; // Switch back to dashboard
            });
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text(AppLanguage.translate('Queue created successfully'))),
            );
          },
          distributionAreas: _distributionAreas,
        );
      case 2: // Add Beneficiary
        return BeneficiaryRegistrationScreen(
          queues: _filteredQueues, // Only show admin's queues
          beneficiaries: _beneficiaries,
          distributionAreas: _distributionAreas,
          entities: _entities,
          onBeneficiaryCreated: (beneficiary) {
            _addBeneficiary(beneficiary);
            setState(() {
              _selectedIndex = 0; // Switch back to dashboard
            });
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text(AppLanguage.translate('Beneficiary registered successfully'))),
            );
          },
          onEntityAdded: _addEntity,
        );
      case 3: // Beneficiaries List
        return BeneficiariesListScreen(
          beneficiaries: _beneficiaries,
          queues: _filteredQueues, // Only show admin's queues
          distributionAreas: _distributionAreas,
          entities: _entities,
          onBeneficiaryUpdated: (beneficiary) {
            // Try to update local list if beneficiary exists
            // Firestore stream will also update automatically
            try {
              final index = _beneficiaries.indexWhere((b) => b.id == beneficiary.id);
              if (index != -1) {
                _updateBeneficiary(index, beneficiary);
              } else {
                // Beneficiary not in local list - Firestore stream will handle it
                print('Beneficiary ${beneficiary.id} updated in Firestore - stream will reflect changes');
              }
            } catch (e) {
              print('Error updating beneficiary in local list: $e');
              // Don't crash - Firestore stream will handle the update
            }
          },
          onEntityAdded: _addEntity,
        );
      case 4: // Add Queue Point
        return AddDistributionAreaScreen(
          onAreaCreated: _addDistributionArea,
          onCancel: () {
            setState(() {
              _selectedIndex = 0;
            });
          },
        );
      default:
        return const Center(child: Text('Unknown screen'));
    }
  }

  String _getRoleDisplayName(String? role) {
    if (role == null || role.isEmpty) {
      return 'Admin';
    }
    switch (role) {
      case 'Super_Admin':
        return 'Super Admin';
      case 'Q_Admin':
        return 'Q Admin';
      case 'Admin':
        return 'Admin';
      default:
        return role;
    }
  }

  Widget _buildDrawer(BuildContext context) {
    const tealGreen = Color(0xFF81CF01);
    
    return Drawer(
      child: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
            colors: [Color(0xFF81CF01), Color(0xFF6BA801)],
          ),
        ),
        child: ListView(
          padding: EdgeInsets.zero,
          children: [
            DrawerHeader(
              decoration: const BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                  colors: [Color(0xFF81CF01), Color(0xFF6BA801)],
                ),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  const CircleAvatar(
                    radius: 28,
                    backgroundColor: Colors.white,
                    child: Icon(Icons.person, size: 36, color: Color(0xFF81CF01)),
                  ),
                  const SizedBox(height: 8),
                  // Welcome message
                  Text(
                    'Welcome',
                    style: TextStyle(
                      color: Colors.white.withOpacity(0.9),
                      fontSize: 12,
                    ),
                  ),
                  const SizedBox(height: 2),
                  // User name
                  Flexible(
                    child: Text(
                      AdminService.currentAdmin?.fullName ?? 'Admin User',
                    style: const TextStyle(
                      color: Colors.white,
                        fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                  ),
                  ),
                  const SizedBox(height: 2),
                  // User role
                  Text(
                    _getRoleDisplayName(AdminService.currentAdmin?.role),
                    style: TextStyle(
                      color: Colors.white.withOpacity(0.9),
                      fontSize: 12,
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ),
            ),
            ListTile(
              leading: const Icon(Icons.person, color: Colors.white),
              title: const Text(
                'Profile',
                style: TextStyle(color: Colors.white, fontWeight: FontWeight.w500),
              ),
              onTap: () {
                Navigator.pop(context);
                Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (context) => const ProfileScreen(),
                  ),
                );
              },
            ),
            const Divider(color: Colors.white54, height: 1),
            // Only show Admin Management for Super Admin
            if (AdminService.currentAdmin?.isSuperAdmin ?? false)
              StreamBuilder<int>(
                stream: AdminRequestService.getPendingRequestsCount(),
                builder: (context, snapshot) {
                  final pendingCount = snapshot.data ?? 0;
                  return ListTile(
                    leading: Stack(
                      children: [
                        const Icon(Icons.admin_panel_settings, color: Colors.white),
                        if (pendingCount > 0)
                          Positioned(
                            right: 0,
                            top: 0,
                            child: Container(
                              padding: const EdgeInsets.all(4),
                              decoration: const BoxDecoration(
                                color: Colors.red,
                                shape: BoxShape.circle,
                              ),
                              constraints: const BoxConstraints(
                                minWidth: 16,
                                minHeight: 16,
                              ),
                              child: Text(
                                pendingCount > 99 ? '99+' : '$pendingCount',
                                style: const TextStyle(
                                  color: Colors.white,
                                  fontSize: 10,
                                  fontWeight: FontWeight.bold,
                                ),
                                textAlign: TextAlign.center,
                              ),
                            ),
                          ),
                      ],
                    ),
                    title: Text(
                      AppLanguage.translate('Admin Management'),
                      style: const TextStyle(color: Colors.white, fontWeight: FontWeight.w500),
                    ),
                    onTap: () {
                      Navigator.pop(context);
                      Navigator.of(context).push(
                        MaterialPageRoute(
                          builder: (context) => AdminManagementScreen(
                            admins: _admins,
                            adminRequests: _adminRequests,
                            distributionAreas: _distributionAreas,
                            onAdminCreated: (admin) {
                              setState(() {
                                _admins.add(admin);
                              });
                            },
                            onAdminRequestApproved: (admin) {
                              AdminRequestStorage.removeRequest(admin.id);
                              setState(() {
                                _admins.add(admin);
                              });
                            },
                            onAdminRequestRejected: (adminId) {
                              AdminRequestStorage.removeRequest(adminId);
                              setState(() {});
                            },
                          ),
                        ),
                      );
                    },
                );
              },
            ),
            ListTile(
              leading: const Icon(Icons.history, color: Colors.white),
              title: Text(
                AppLanguage.translate('Queue History'),
                style: const TextStyle(color: Colors.white, fontWeight: FontWeight.w500),
              ),
              onTap: () {
                Navigator.pop(context);
                Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (context) => QueueHistoryScreen(
                      distributionAreas: _distributionAreas,
                    ),
                  ),
                );
              },
            ),
            ListTile(
              leading: const Icon(Icons.assessment, color: Colors.white),
              title: Text(
                AppLanguage.translate('Reports'),
                style: const TextStyle(color: Colors.white, fontWeight: FontWeight.w500),
              ),
              onTap: () {
                Navigator.pop(context);
                Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (context) => ReportsScreen(
                      queues: _queues,
                      beneficiaries: _beneficiaries,
                      distributionAreas: _distributionAreas,
                    ),
                  ),
                );
              },
            ),
            ListTile(
              leading: const Icon(Icons.settings, color: Colors.white),
              title: Text(
                AppLanguage.translate('Settings'),
                style: const TextStyle(color: Colors.white, fontWeight: FontWeight.w500),
              ),
              onTap: () {
                Navigator.pop(context);
                Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (context) => const SettingsScreen(),
                  ),
                );
              },
            ),
            const Divider(color: Colors.white54, height: 1),
            ListTile(
              leading: const Icon(Icons.logout, color: Colors.white),
              title: Text(
                AppLanguage.translate('Logout'),
                style: const TextStyle(color: Colors.white, fontWeight: FontWeight.w500),
              ),
              onTap: () {
                Navigator.pop(context);
                showDialog(
                  context: context,
                  builder: (context) => AlertDialog(
                    title: Text(AppLanguage.translate('Logout')),
                    content: Text(AppLanguage.translate('Are you sure you want to logout?')),
                    actions: [
                      TextButton(
                        onPressed: () => Navigator.pop(context),
                        child: Text(AppLanguage.translate('Cancel')),
                      ),
                      TextButton(
                        onPressed: () {
                          Navigator.of(context).pushAndRemoveUntil(
                            MaterialPageRoute(
                              builder: (context) => const LoginScreen(),
                            ),
                            (route) => false,
                          );
                        },
                        child: Text(AppLanguage.translate('Logout'), style: const TextStyle(color: Colors.red)),
                      ),
                    ],
                  ),
                );
              },
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDraggableFAB(BuildContext context) {
    // Only show FAB on dashboard screen (index 0)
    if (_selectedIndex != 0) {
      return const SizedBox.shrink();
    }
    
    const tealGreen = Color(0xFF81CF01);
    const fabSize = 56.0;
    const rightPadding = 16.0;
    const bottomNavBarHeight = 56.0; // Standard bottom navigation bar height
    const fabOffsetFromBottomNav = 16.0; // 16px above bottom navigation bar
    
    return Positioned(
      right: rightPadding,
      bottom: bottomNavBarHeight + fabOffsetFromBottomNav, // Position above bottom navigation bar
      child: AnimatedBuilder(
        animation: _pulseAnimation,
        builder: (context, child) {
          return Transform.scale(
            scale: _isDragging ? 1.0 : _pulseAnimation.value,
            child: Material(
              elevation: _isDragging ? 8 : 6,
              borderRadius: BorderRadius.circular(28),
              color: Colors.transparent,
              child: Container(
                width: fabSize,
                height: fabSize,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  gradient: LinearGradient(
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                    colors: [
                      tealGreen,
                      const Color(0xFF6BA801),
                    ],
                  ),
                  boxShadow: [
                    BoxShadow(
                      color: tealGreen.withOpacity(_isDragging ? 0.3 : 0.5),
                      blurRadius: _isDragging ? 8 : 12,
                      spreadRadius: _isDragging ? 0 : 2,
                      offset: const Offset(0, 4),
                    ),
                  ],
                ),
                child: InkWell(
                  borderRadius: BorderRadius.circular(28),
                  onTap: () {
                    // Open Issue Queue Number Screen directly
                    Navigator.of(context).push(
                      MaterialPageRoute(
                        builder: (context) => IssueQueueNumberScreen(
                          queues: _filteredQueues, // Use filtered queues (admin's queues only)
                          beneficiaries: _beneficiaries,
                          onQueueNumberIssued: _handleQueueNumberIssued,
                        ),
                      ),
                    );
                  },
                  child: const Icon(
                    Icons.confirmation_number,
                    color: Colors.white,
                    size: 28,
                  ),
                ),
              ),
            ),
          );
        },
      ),
    );
  }


  @override
  Widget build(BuildContext context) {
    return PopScope(
      canPop: false,
      onPopInvoked: (didPop) async {
        if (didPop) return;
        final shouldExit = await showDialog<bool>(
          context: context,
          builder: (context) => AlertDialog(
            title: Text(AppLanguage.translate('Exit App')),
            content: Text(AppLanguage.translate('Are you sure you want to exit the app?')),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context, false),
                child: Text(AppLanguage.translate('Cancel')),
              ),
              TextButton(
                onPressed: () => Navigator.pop(context, true),
                child: Text(AppLanguage.translate('Exit'), style: const TextStyle(color: Colors.red)),
              ),
            ],
          ),
        );
        if (shouldExit == true && context.mounted) {
          // Exit the app
          SystemNavigator.pop();
        }
      },
      child: Scaffold(
        appBar: AppBar(
          title: const Text('EQMS Dashboard'),
          backgroundColor: const Color(0xFF81CF01),
          foregroundColor: Colors.white,
        actions: [
          // Only show Admin Management for Super Admin
          if (AdminService.currentAdmin?.isSuperAdmin ?? false)
          IconButton(
            icon: const Icon(Icons.admin_panel_settings),
            tooltip: 'Admin Management',
            onPressed: () {
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => AdminManagementScreen(
                    admins: _admins,
                    adminRequests: _adminRequests,
                    distributionAreas: _distributionAreas,
                    onAdminCreated: (admin) {
                      setState(() {
                        _admins.add(admin);
                      });
                    },
                    onAdminRequestApproved: (admin) {
                      AdminRequestStorage.removeRequest(admin.id);
                      setState(() {
                        _admins.add(admin);
                      });
                    },
                    onAdminRequestRejected: (adminId) {
                      AdminRequestStorage.removeRequest(adminId);
                      setState(() {});
                    },
                  ),
                ),
              );
            },
          ),
          IconButton(
            icon: const Icon(Icons.person),
            tooltip: 'Profile',
            onPressed: () {
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => ProfileScreen(),
                ),
              );
            },
          ),
        ],
      ),
      drawer: _buildDrawer(context),
      body: Stack(
        children: [
          _getScreen(),
          _buildDraggableFAB(context),
        ],
      ),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _selectedIndex,
        onTap: (index) {
          setState(() {
            _selectedIndex = index;
          });
        },
        type: BottomNavigationBarType.fixed,
        selectedItemColor: const Color(0xFF81CF01),
        unselectedItemColor: Colors.grey,
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.dashboard),
            label: 'Dashboard',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.add_circle),
            label: 'Add Queue',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.person_add),
            label: 'Add Beneficiary',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.people),
            label: 'Beneficiaries',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.location_on),
            label: 'Add Area',
          ),
        ],
      ),
      ),
    );
  }
}

// New Queue Screen
class NewQueueScreen extends StatefulWidget {
  final Function(Queue) onQueueCreated;
  final List<DistributionArea> distributionAreas; // Kept for backward compatibility

  const NewQueueScreen({
    super.key,
    required this.onQueueCreated,
    required this.distributionAreas,
  });

  @override
  State<NewQueueScreen> createState() => _NewQueueScreenState();
}

class _NewQueueScreenState extends State<NewQueueScreen> {
  final _formKey = GlobalKey<FormState>();
  final _queueNameController = TextEditingController();
  final _unitNameController = TextEditingController();
  final _customUnitNameController = TextEditingController();
  final _queueSizeController = TextEditingController();

  // Focus nodes for keyboard navigation
  final _queueNameFocus = FocusNode();
  final _customUnitNameFocus = FocusNode();
  final _unitsFocus = FocusNode();
  final _queueSizeFocus = FocusNode();

  String? _selectedDistributionArea;
  String? _selectedQueueType = 'Single Day';
  String? _selectedUnitName;
  DateTime? _fromDate;
  DateTime? _toDate;
  TimeOfDay? _fromTime;
  TimeOfDay? _toTime;
  int? _numberOfAvailableUnits;
  int? _estimatedQueueSize;
  bool _directServe = false;
  final List<String> _selectedPriority = [];
  String _status = 'active';

  @override
  void dispose() {
    _queueNameController.dispose();
    _unitNameController.dispose();
    _customUnitNameController.dispose();
    _queueSizeController.dispose();

    // Dispose focus nodes
    _queueNameFocus.dispose();
    _customUnitNameFocus.dispose();
    _unitsFocus.dispose();
    _queueSizeFocus.dispose();

    super.dispose();
  }

  Widget _buildPriorityButton(String priority, Color color) {
    final isSelected = _selectedPriority.contains(priority);
    return OutlinedButton(
      onPressed: () {
        setState(() {
          if (isSelected) {
            _selectedPriority.remove(priority);
          } else {
            _selectedPriority.add(priority);
          }
        });
      },
      style: OutlinedButton.styleFrom(
        backgroundColor: isSelected ? color.withOpacity(0.1) : Colors.white,
        foregroundColor: isSelected ? color : Colors.grey[700],
        side: BorderSide(
          color: isSelected ? color : Colors.grey[300]!,
          width: isSelected ? 2 : 1,
        ),
        padding: const EdgeInsets.symmetric(vertical: 12),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
        ),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            isSelected ? Icons.check_circle : Icons.circle_outlined,
            size: 18,
            color: isSelected ? color : Colors.grey[600],
          ),
          const SizedBox(width: 6),
          Text(
            AppLanguage.translate(priority),
            style: TextStyle(
              fontSize: 13,
              fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _handleCreate() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }
    
    if (_selectedDistributionArea == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(AppLanguage.translate('Please select a distribution area'))),
      );
      return;
    }
    if (_fromDate == null || _toDate == null || _fromTime == null || _toTime == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select date and time ranges')),
      );
      return;
    }
    if (_numberOfAvailableUnits == null || _estimatedQueueSize == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter number of units and estimated queue size')),
      );
      return;
    }

    // Get distribution area details from Firestore
    DistributionArea? selectedArea;
    try {
      selectedArea = await DistributionAreaService.getAreaById(_selectedDistributionArea!);
      if (selectedArea == null) {
        // Fallback to widget.distributionAreas if not found in Firestore
        try {
          selectedArea = widget.distributionAreas.firstWhere(
            (area) => area.id == _selectedDistributionArea,
          );
        } catch (e) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(AppLanguage.translate('Distribution area not found. Please select a valid area.'))),
          );
          return;
        }
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(AppLanguage.translate('Distribution area not found. Please select a valid area.'))),
      );
      return;
    }

    if (selectedArea == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(AppLanguage.translate('Please select a distribution area'))),
      );
      return;
    }

    // For Multi Day queues, ensure available units > 1
    if (_selectedQueueType == 'Multi Day' && _numberOfAvailableUnits! <= 1) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('For multi-day queues, number of available units must be greater than 1')),
      );
      return;
    }

    // For Single Day queues, use the selected date range (can be one day or multiple days)
    final queue = Queue(
      name: _queueNameController.text,
      queueManager: 'Admin User',
      country: selectedArea.country,
      governorate: selectedArea.governorate,
      city: selectedArea.city,
      queuePointName: selectedArea.areaName,
      distributionArea: _selectedDistributionArea!,
      queueType: _selectedQueueType!,
      fromDate: _fromDate!,
      toDate: _toDate!,
      fromTime: _fromTime!,
      toTime: _toTime!,
      unitName: _selectedUnitName == 'Others' ? _customUnitNameController.text : _selectedUnitName!,
      numberOfAvailableUnits: _numberOfAvailableUnits!,
      estimatedQueueSize: _estimatedQueueSize!,
      directServe: _directServe,
      priority: _selectedPriority,
      status: _status,
    );

    // Validate the queue before creating
    final validationError = queue.validate();
    if (validationError != null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(validationError)),
      );
      return;
    }

    // Show loading indicator
    if (mounted) {
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => const Center(
          child: CircularProgressIndicator(),
        ),
      );
    }

    try {
      // Save to Firestore
      final createdBy = AdminService.currentAdminId ?? 'system';
      final queueId = await QueueService.createQueue(queue, createdBy);
      
      print('✅ Queue created successfully in Firestore with ID: $queueId');
      
      // Close loading dialog
      if (mounted) {
        Navigator.of(context).pop(); // Close loading dialog
      }

      // Call the callback - it will switch to dashboard tab and show success message
      // NewQueueScreen is part of tab system, not a separate route, so no need to pop
      if (mounted) {
        try {
          widget.onQueueCreated(queue);
        } catch (e) {
          print('Warning: Error in onQueueCreated callback: $e');
          // Show success message manually if callback fails
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(AppLanguage.translate('Queue created successfully')),
              backgroundColor: Colors.green,
              duration: const Duration(seconds: 2),
            ),
          );
        }
      }
    } catch (e) {
      print('❌ Error creating queue in Firestore: $e');
      
      // Close loading dialog
      if (mounted) {
        Navigator.of(context).pop();
      }
      
      // Show error message
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to create queue: $e'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 3),
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    const tealGreen = Color(0xFF81CF01);
    const darkBlue = Color(0xFF1A237E);

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Color(0xFFE8F5E9), Colors.white],
          ),
        ),
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(20.0),
          child: Form(
            key: _formKey,
        child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
          children: [
                Text(
                  AppLanguage.translate('Add New Queue'),
                  style: const TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                    color: darkBlue,
                  ),
                ),
                const SizedBox(height: 32),
                TextFormField(
                  controller: _queueNameController,
                  focusNode: _queueNameFocus,
                  textInputAction: TextInputAction.next,
                  onFieldSubmitted: (_) {
                    if (_selectedUnitName == 'Others') {
                      _customUnitNameFocus.requestFocus();
                    } else {
                      _unitsFocus.requestFocus();
                    }
                  },
                  decoration: InputDecoration(
                    labelText: AppLanguage.translate('Queue Name *'),
                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                    filled: true,
                    fillColor: Colors.white,
                  ),
                  validator: (value) => value?.isEmpty ?? true ? AppLanguage.translate('Please enter queue name') : null,
                ),
                const SizedBox(height: 16),
                Text(AppLanguage.translate('Distribution Area *'), style: const TextStyle(fontWeight: FontWeight.bold)),
                const SizedBox(height: 8),
                StreamBuilder<List<DistributionArea>>(
                  stream: DistributionAreaService.getAllAreas(),
                  initialData: widget.distributionAreas, // Use local list as initial data
                  builder: (context, snapshot) {
                    // Always show dropdown, use local list if stream hasn't loaded yet or has error
                    List<DistributionArea> displayAreas;
                    
                    if (snapshot.connectionState == ConnectionState.waiting && snapshot.data == null) {
                      // Still loading and no data yet - use local list
                      displayAreas = widget.distributionAreas;
                    } else if (snapshot.hasError) {
                      // Error occurred - use local list
                      print('StreamBuilder error: ${snapshot.error}');
                      displayAreas = widget.distributionAreas;
                    } else {
                      // Use Firestore data if available, otherwise fall back to local
                      final firestoreAreas = snapshot.data ?? [];
                      // Prefer Firestore data, but ensure no duplicates
                      if (firestoreAreas.isNotEmpty) {
                        // Remove duplicates by ID
                        final uniqueMap = <String, DistributionArea>{};
                        for (final area in firestoreAreas) {
                          if (!uniqueMap.containsKey(area.id)) {
                            uniqueMap[area.id] = area;
                          }
                        }
                        final allUniqueAreas = uniqueMap.values.toList();
                        
                        // Filter areas based on logged-in user's distribution point
                        final currentAdmin = AdminService.currentAdmin;
                        if (currentAdmin != null && 
                            (currentAdmin.isSuperAdmin || currentAdmin.distributionPoint.toLowerCase() == 'all' || currentAdmin.mobile == '01010646279')) {
                          // Super Admin or admin with "All" can see all areas
                          displayAreas = allUniqueAreas;
                        } else if (currentAdmin != null && 
                                   (currentAdmin.isAdmin || currentAdmin.isQAdmin) && 
                                   currentAdmin.distributionPoint.isNotEmpty && 
                                   currentAdmin.distributionPoint.toLowerCase() != 'all') {
                          // For Admin and Q_Admin roles: Filter to only show their assigned distribution areas
                          // Match by distributionPoint name with areaName
                          displayAreas = allUniqueAreas.where((area) {
                            final adminPoint = currentAdmin.distributionPoint.toLowerCase();
                            final areaName = area.areaName.toLowerCase();
                            return areaName.contains(adminPoint) || adminPoint.contains(areaName);
                          }).toList();
                      } else {
                          // No admin logged in or no distribution point assigned, use passed list
                          displayAreas = widget.distributionAreas;
                        }
                      } else {
                        displayAreas = widget.distributionAreas;
                      }
                    }
                    
                    return DropdownButtonFormField<String>(
                      value: _selectedDistributionArea,
                      isExpanded: true,
                      decoration: InputDecoration(
                        border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                        filled: true,
                        fillColor: Colors.white,
                        hintText: displayAreas.isEmpty 
                            ? AppLanguage.translate('No areas available')
                            : AppLanguage.translate('Select Distribution Area'),
                      ),
                      items: displayAreas.isEmpty
                          ? [
                              DropdownMenuItem(
                                value: null,
                                enabled: false,
                                child: Text(
                                  AppLanguage.translate('No areas available'),
                                  style: TextStyle(color: Colors.grey[600]),
                                ),
                              ),
                            ]
                          : (() {
                              // Remove duplicates by ID
                              final uniqueAreas = <String, DistributionArea>{};
                              for (final area in displayAreas) {
                                if (!uniqueAreas.containsKey(area.id)) {
                                  uniqueAreas[area.id] = area;
                                }
                              }
                              return uniqueAreas.values.map((area) {
                                return DropdownMenuItem(
                                  value: area.id,
                                  child: Text(
                                    area.fullName,
                                    overflow: TextOverflow.ellipsis,
                                    maxLines: 1,
                                  ),
                                );
                              }).toList();
                            })(),
                      selectedItemBuilder: (context) {
                        if (displayAreas.isEmpty) {
                          return [
                            Text(
                              AppLanguage.translate('No areas available'),
                              style: TextStyle(color: Colors.grey[600]),
                            ),
                          ];
                        }
                        // Remove duplicates for selectedItemBuilder too
                        final uniqueAreas = <String, DistributionArea>{};
                        for (final area in displayAreas) {
                          if (!uniqueAreas.containsKey(area.id)) {
                            uniqueAreas[area.id] = area;
                          }
                        }
                        return uniqueAreas.values.map((area) {
                          return Text(
                            area.fullName,
                            overflow: TextOverflow.ellipsis,
                            maxLines: 1,
                          );
                        }).toList();
                      },
                      onChanged: displayAreas.isEmpty ? null : (value) {
                        // Validate that the selected value exists in unique areas
                        final uniqueAreas = <String, DistributionArea>{};
                        for (final area in displayAreas) {
                          if (!uniqueAreas.containsKey(area.id)) {
                            uniqueAreas[area.id] = area;
                          }
                        }
                        if (value == null || uniqueAreas.containsKey(value)) {
                          setState(() {
                            _selectedDistributionArea = value;
                          });
                        }
                      },
                    );
                  },
                ),
                const SizedBox(height: 16),
                Text(AppLanguage.translate('Queue Type *'), style: const TextStyle(fontWeight: FontWeight.bold)),
                const SizedBox(height: 8),
                DropdownButtonFormField<String>(
                  value: _selectedQueueType,
                  decoration: InputDecoration(
                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                    filled: true,
                    fillColor: Colors.white,
                  ),
                  items: ['Single Day', 'Multi Day'].map((type) {
                    return DropdownMenuItem(value: type, child: Text(AppLanguage.translate(type)));
                  }).toList(),
                  onChanged: (value) {
                    setState(() {
                      _selectedQueueType = value;
                      // Ensure toDate is not before fromDate
                      if (_fromDate != null && _toDate != null && _toDate!.isBefore(_fromDate!)) {
                        _toDate = _fromDate;
                      }
                    });
                  },
                ),
                const SizedBox(height: 16),
                // Show different UI based on queue type
                _selectedQueueType == 'Single Day'
                    ? Column(
                        crossAxisAlignment: CrossAxisAlignment.stretch,
                        children: [
                          // Date range pickers for Single Day (can be one day or multiple days)
                          Row(
                            children: [
                              Expanded(
                                child: ElevatedButton.icon(
                            onPressed: () async {
                              final date = await showDatePicker(
                                context: context,
                                initialDate: _fromDate ?? DateTime.now(),
                                firstDate: DateTime.now(),
                                lastDate: DateTime.now().add(const Duration(days: 365)),
                              );
                              if (date != null) {
                                setState(() {
                                  _fromDate = date;
                                        // Ensure toDate is not before fromDate
                                        if (_toDate != null && _toDate!.isBefore(date)) {
                                  _toDate = date;
                                        }
                                });
                              }
                            },
                            icon: const Icon(Icons.calendar_today, size: 18),
                            label: Text(
                              _fromDate == null
                                        ? AppLanguage.translate('From Date *')
                                  : '${_fromDate!.day}/${_fromDate!.month}/${_fromDate!.year}',
                              style: const TextStyle(fontSize: 14),
                            ),
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Colors.white,
                              foregroundColor: tealGreen,
                              padding: const EdgeInsets.symmetric(vertical: 12),
                              side: BorderSide(color: tealGreen),
                            ),
                                ),
                              ),
                              const SizedBox(width: 12),
                              Expanded(
                                child: ElevatedButton.icon(
                                  onPressed: () async {
                                    final date = await showDatePicker(
                                      context: context,
                                      initialDate: _toDate ?? (_fromDate ?? DateTime.now()),
                                      firstDate: _fromDate ?? DateTime.now(),
                                      lastDate: DateTime.now().add(const Duration(days: 365)),
                                    );
                                    if (date != null) {
                                      setState(() {
                                        _toDate = date;
                                      });
                                    }
                                  },
                                  icon: const Icon(Icons.calendar_today, size: 18),
                                  label: Text(
                                    _toDate == null
                                        ? AppLanguage.translate('To Date *')
                                        : '${_toDate!.day}/${_toDate!.month}/${_toDate!.year}',
                                    style: const TextStyle(fontSize: 14),
                                  ),
                                  style: ElevatedButton.styleFrom(
                                    backgroundColor: Colors.white,
                                    foregroundColor: tealGreen,
                                    padding: const EdgeInsets.symmetric(vertical: 12),
                                    side: BorderSide(color: tealGreen),
                                  ),
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(height: 12),
                          // Time pickers for Single Day (12-hour format)
                          Row(
                            children: [
                              Expanded(
                                child: ElevatedButton.icon(
                                  onPressed: () async {
                                    final time = await showTimePicker(
                                      context: context,
                                      initialTime: _fromTime ?? TimeOfDay.now(),
                                      builder: (context, child) {
                                        return MediaQuery(
                                          data: MediaQuery.of(context).copyWith(alwaysUse24HourFormat: false),
                                          child: child!,
                                        );
                                      },
                                    );
                                    if (time != null) {
                                      setState(() {
                                        _fromTime = time;
                                      });
                                    }
                                  },
                                  icon: const Icon(Icons.access_time, size: 18),
                                  label: Text(
                                    _fromTime == null
                                        ? AppLanguage.translate('From Time *')
                                        : _fromTime!.format(context),
                                    style: const TextStyle(fontSize: 14),
                                  ),
                                  style: ElevatedButton.styleFrom(
                                    backgroundColor: Colors.white,
                                    foregroundColor: tealGreen,
                                    padding: const EdgeInsets.symmetric(vertical: 12),
                                    side: BorderSide(color: tealGreen),
                                  ),
                                ),
                              ),
                              const SizedBox(width: 12),
                              Expanded(
                                child: ElevatedButton.icon(
                                  onPressed: () async {
                                    final time = await showTimePicker(
                                      context: context,
                                      initialTime: _toTime ?? TimeOfDay.now(),
                                      builder: (context, child) {
                                        return MediaQuery(
                                          data: MediaQuery.of(context).copyWith(alwaysUse24HourFormat: false),
                                          child: child!,
                                        );
                                      },
                                    );
                                    if (time != null) {
                                      setState(() {
                                        _toTime = time;
                                      });
                                    }
                                  },
                                  icon: const Icon(Icons.access_time, size: 18),
                                  label: Text(
                                    _toTime == null
                                        ? AppLanguage.translate('To Time *')
                                        : _toTime!.format(context),
                                    style: const TextStyle(fontSize: 14),
                                  ),
                                  style: ElevatedButton.styleFrom(
                                    backgroundColor: Colors.white,
                                    foregroundColor: tealGreen,
                                    padding: const EdgeInsets.symmetric(vertical: 12),
                                    side: BorderSide(color: tealGreen),
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ],
                      )
                    : Row(
                        children: [
                          Expanded(
                            child: ElevatedButton.icon(
                              onPressed: () async {
                                // Show date picker first
                                final date = await showDatePicker(
                                  context: context,
                                  initialDate: _fromDate ?? DateTime.now(),
                                  firstDate: DateTime.now(),
                                  lastDate: DateTime.now().add(const Duration(days: 365)),
                                );
                                if (date != null) {
                                  // Then show time picker (12-hour format)
                                  final time = await showTimePicker(
                                    context: context,
                                    initialTime: _fromTime ?? TimeOfDay.now(),
                                    builder: (context, child) {
                                      return MediaQuery(
                                        data: MediaQuery.of(context).copyWith(alwaysUse24HourFormat: false),
                                        child: child!,
                                      );
                                    },
                                  );
                                  if (time != null) {
                                    setState(() {
                                      _fromDate = date;
                                      _fromTime = time;
                                    });
                                  }
                                }
                              },
                              icon: const Icon(Icons.calendar_today, size: 18),
                              label: Text(
                                _fromDate == null || _fromTime == null
                                    ? AppLanguage.translate('From Date & Time *')
                                    : '${_fromDate!.day}/${_fromDate!.month}/${_fromDate!.year} ${_fromTime!.format(context)}',
                                style: const TextStyle(fontSize: 14),
                              ),
                              style: ElevatedButton.styleFrom(
                                backgroundColor: Colors.white,
                                foregroundColor: tealGreen,
                                padding: const EdgeInsets.symmetric(vertical: 12),
                                side: BorderSide(color: tealGreen),
                              ),
                            ),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: ElevatedButton.icon(
                              onPressed: () async {
                                // Show date picker first
                                final date = await showDatePicker(
                                  context: context,
                                  initialDate: _toDate ?? (_fromDate ?? DateTime.now()),
                                  firstDate: _fromDate ?? DateTime.now(),
                                  lastDate: DateTime.now().add(const Duration(days: 365)),
                                );
                                if (date != null) {
                                  // Then show time picker (12-hour format)
                                  final time = await showTimePicker(
                                    context: context,
                                    initialTime: _toTime ?? TimeOfDay.now(),
                                    builder: (context, child) {
                                      return MediaQuery(
                                        data: MediaQuery.of(context).copyWith(alwaysUse24HourFormat: false),
                                        child: child!,
                                      );
                                    },
                                  );
                                  if (time != null) {
                                    setState(() {
                                      _toDate = date;
                                      _toTime = time;
                                    });
                                  }
                                }
                              },
                              icon: const Icon(Icons.calendar_today, size: 18),
                              label: Text(
                                _toDate == null || _toTime == null
                                    ? AppLanguage.translate('To Date & Time *')
                                    : '${_toDate!.day}/${_toDate!.month}/${_toDate!.year} ${_toTime!.format(context)}',
                                style: const TextStyle(fontSize: 14),
                              ),
                              style: ElevatedButton.styleFrom(
                                backgroundColor: Colors.white,
                                foregroundColor: tealGreen,
                                padding: const EdgeInsets.symmetric(vertical: 12),
                                side: BorderSide(color: tealGreen),
                              ),
                            ),
                          ),
                        ],
                      ),
                const SizedBox(height: 16),
                Text(AppLanguage.translate('Unit Name *'), style: const TextStyle(fontWeight: FontWeight.bold)),
                const SizedBox(height: 8),
                StreamBuilder<List<Unit>>(
                  stream: UnitService.getAllUnits(),
                  initialData: const [], // Empty list as initial data
                  builder: (context, snapshot) {
                    List<Unit> displayUnits = [];
                    
                    if (snapshot.connectionState == ConnectionState.waiting && snapshot.data == null) {
                      // Still loading
                      displayUnits = [];
                    } else if (snapshot.hasError) {
                      // Error occurred - use default units as fallback
                      print('StreamBuilder error for units: ${snapshot.error}');
                      displayUnits = [
                        Unit(
                          id: 'meals',
                          name: 'Meals',
                          description: 'Food meals',
                          isActive: true,
                          order: 1,
                          createdAt: DateTime.now(),
                          updatedAt: DateTime.now(),
                        ),
                        Unit(
                          id: 'bags',
                          name: 'Bags',
                          description: 'Food bags',
                          isActive: true,
                          order: 2,
                          createdAt: DateTime.now(),
                          updatedAt: DateTime.now(),
                        ),
                        Unit(
                          id: 'blankets',
                          name: 'Blankets',
                          description: 'Blankets and covers',
                          isActive: true,
                          order: 3,
                          createdAt: DateTime.now(),
                          updatedAt: DateTime.now(),
                        ),
                        Unit(
                          id: 'others',
                          name: 'Others',
                          description: 'Other unit types',
                          isActive: true,
                          order: 99,
                          createdAt: DateTime.now(),
                          updatedAt: DateTime.now(),
                        ),
                      ];
                    } else {
                      // Use Firestore data if available
                      final firestoreUnits = snapshot.data ?? [];
                      if (firestoreUnits.isNotEmpty) {
                        // Remove duplicates by unit name to prevent dropdown errors
                        final seenNames = <String>{};
                        displayUnits = firestoreUnits.where((unit) {
                          if (seenNames.contains(unit.name)) {
                            return false; // Skip duplicate
                          }
                          seenNames.add(unit.name);
                          return true;
                        }).toList();
                      } else {
                              // Fallback default units
                        displayUnits = [
                              Unit(
                                id: 'meals',
                                name: 'Meals',
                                description: 'Food meals',
                                isActive: true,
                                order: 1,
                                createdAt: DateTime.now(),
                                updatedAt: DateTime.now(),
                              ),
                              Unit(
                                id: 'bags',
                                name: 'Bags',
                                description: 'Food bags',
                                isActive: true,
                                order: 2,
                                createdAt: DateTime.now(),
                                updatedAt: DateTime.now(),
                              ),
                              Unit(
                                id: 'blankets',
                                name: 'Blankets',
                                description: 'Blankets and covers',
                                isActive: true,
                                order: 3,
                                createdAt: DateTime.now(),
                                updatedAt: DateTime.now(),
                              ),
                              Unit(
                                id: 'others',
                                name: 'Others',
                                description: 'Other unit types',
                                isActive: true,
                                order: 99,
                                createdAt: DateTime.now(),
                                updatedAt: DateTime.now(),
                              ),
                            ];
                      }
                    }
                    
                    return DropdownButtonFormField<String>(
                      value: _selectedUnitName,
                      decoration: InputDecoration(
                        border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                        filled: true,
                        fillColor: Colors.white,
                        hintText: displayUnits.isEmpty 
                            ? AppLanguage.translate('Loading units...')
                            : AppLanguage.translate('Select Unit Name'),
                      ),
                      items: displayUnits.isEmpty
                          ? [
                              DropdownMenuItem(
                                value: null,
                                enabled: false,
                                child: Text(
                                  AppLanguage.translate('No units available'),
                                  style: TextStyle(color: Colors.grey[600]),
                                ),
                              ),
                            ]
                          : displayUnits.map((unit) {
                              return DropdownMenuItem(
                                value: unit.name,
                                child: Text(unit.name),
                              );
                            }).toList(),
                      onChanged: displayUnits.isEmpty ? null : (value) => setState(() => _selectedUnitName = value),
                    );
                  },
                ),
                if (_selectedUnitName == 'Others') ...[
                  const SizedBox(height: 16),
                  TextFormField(
                    controller: _customUnitNameController,
                    focusNode: _customUnitNameFocus,
                    textInputAction: TextInputAction.next,
                    onFieldSubmitted: (_) => _unitsFocus.requestFocus(),
                    decoration: InputDecoration(
                      labelText: AppLanguage.translate('Custom Unit Name *'),
                      border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                      filled: true,
                      fillColor: Colors.white,
                    ),
                    validator: _selectedUnitName == 'Others' ? (value) => value?.isEmpty ?? true ? AppLanguage.translate('Please enter unit name') : null : null,
                  ),
                ],
                const SizedBox(height: 16),
                TextFormField(
                  controller: _unitNameController,
                  focusNode: _unitsFocus,
                  keyboardType: TextInputType.number,
                  textInputAction: TextInputAction.next,
                  onFieldSubmitted: (_) => _queueSizeFocus.requestFocus(),
                  decoration: InputDecoration(
                    labelText: AppLanguage.translate('Number of Available Units *'),
                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                    filled: true,
                    fillColor: Colors.white,
                  ),
                  onChanged: (value) => _numberOfAvailableUnits = int.tryParse(value),
                  validator: (value) => value?.isEmpty ?? true ? AppLanguage.translate('Please enter number of units') : null,
                ),
                const SizedBox(height: 16),
                TextFormField(
                  controller: _queueSizeController,
                  focusNode: _queueSizeFocus,
                  keyboardType: TextInputType.number,
                  textInputAction: TextInputAction.done,
                  decoration: InputDecoration(
                    labelText: AppLanguage.translate('Estimated Queue Size *'),
                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                    filled: true,
                    fillColor: Colors.white,
                  ),
                  onChanged: (value) => _estimatedQueueSize = int.tryParse(value),
                  validator: (value) => value?.isEmpty ?? true ? AppLanguage.translate('Please enter estimated queue size') : null,
                ),
                const SizedBox(height: 16),
                CheckboxListTile(
                  title: Text(AppLanguage.translate('Direct Serve Option')),
                  value: _directServe,
                  onChanged: (value) => setState(() => _directServe = value ?? false),
                ),
                const SizedBox(height: 16),
                Text(AppLanguage.translate('Priority (optional)'), style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 14)),
                const SizedBox(height: 8),
                Row(
                  children: [
                    Expanded(
                      child: _buildPriorityButton('Female', tealGreen),
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: _buildPriorityButton('Elderly', tealGreen),
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: _buildPriorityButton('Disability', tealGreen),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                Text(AppLanguage.translate('Status *'), style: const TextStyle(fontWeight: FontWeight.bold)),
                const SizedBox(height: 8),
                DropdownButtonFormField<String>(
                  value: _status,
                  decoration: InputDecoration(
                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                    filled: true,
                    fillColor: Colors.white,
                  ),
                  items: ['active', 'banned', 'suspended', 'completed'].map((status) {
                    return DropdownMenuItem(value: status, child: Text(status.toUpperCase()));
                  }).toList(),
                  onChanged: (value) => setState(() => _status = value ?? 'active'),
                ),
                const SizedBox(height: 32),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton(
                    onPressed: _handleCreate,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: tealGreen,
                      foregroundColor: Colors.white,
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                    ),
                    child: const Text('Create Queue', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

// Queue Details Screen (for editing)
class QueueDetailsScreen extends StatefulWidget {
  final Queue queue;
  final List<DistributionArea> distributionAreas;
  final Function(Queue) onQueueUpdated;

  const QueueDetailsScreen({
    super.key,
    required this.queue,
    required this.distributionAreas,
    required this.onQueueUpdated,
  });

  @override
  State<QueueDetailsScreen> createState() => _QueueDetailsScreenState();
}

class _QueueDetailsScreenState extends State<QueueDetailsScreen> {
  final _formKey = GlobalKey<FormState>();
  late TextEditingController _queueNameController;
  late TextEditingController _customUnitNameController;
  
  late String? _selectedDistributionArea;
  late String? _selectedQueueType;
  late String? _selectedUnitName;
  late DateTime? _fromDate;
  late DateTime? _toDate;
  late TimeOfDay? _fromTime;
  late TimeOfDay? _toTime;
  int? _numberOfAvailableUnits;
  int? _estimatedQueueSize;
  late bool _directServe;
  late List<String> _selectedPriority;
  late String _status;


  @override
  void initState() {
    super.initState();
    // Initialize with widget.queue data first (for immediate display)
    _initializeFromQueue(widget.queue);
    
    // Fetch latest queue data from Firestore to ensure we have the most up-to-date values
    _loadLatestQueueData();
  }
  
  void _initializeFromQueue(Queue queue, {bool updateControllers = true}) {
    if (updateControllers) {
      _queueNameController = TextEditingController(text: queue.name);
    _customUnitNameController = TextEditingController();
    } else {
      // Update existing controllers
      _queueNameController.text = queue.name;
      if (_selectedUnitName == 'Others') {
        _customUnitNameController.text = queue.unitName;
      }
    }
    // Validate distribution area exists in the list before setting
    _selectedDistributionArea = queue.distributionArea;
    _selectedQueueType = queue.queueType ?? 'Single Day';
    // Check if unit name is in standard list or custom
    final standardUnits = ['Meals', 'Bags', 'Blankets'];
    _selectedUnitName = standardUnits.contains(queue.unitName) ? queue.unitName : 'Others';
    if (_selectedUnitName == 'Others' && updateControllers) {
      _customUnitNameController.text = queue.unitName;
    }
    _fromDate = queue.fromDate;
    _toDate = queue.toDate;
    _fromTime = queue.fromTime;
    _toTime = queue.toTime;
    _numberOfAvailableUnits = queue.numberOfAvailableUnits;
    _estimatedQueueSize = queue.estimatedQueueSize;
    _directServe = queue.directServe;
    _selectedPriority = List.from(queue.priority);
    // Handle 'completed' status - if queue is completed, default to 'active' for editing
    // (or keep 'completed' if it's in the dropdown options)
    final validStatuses = ['active', 'banned', 'suspended', 'completed'];
    _status = validStatuses.contains(queue.status) 
        ? queue.status 
        : 'active';
  }
  
  Future<void> _loadLatestQueueData() async {
    try {
      print('🔄 Loading latest queue data for: ${widget.queue.name}');
      // Get the latest queue data from Firestore
      final queueId = await QueueService.getQueueIdByName(widget.queue.name);
      if (queueId != null) {
        print('✅ Found queue ID: $queueId');
        final latestQueue = await QueueService.getQueueById(queueId);
        if (latestQueue != null && mounted) {
          print('✅ Loaded latest queue data. toDate: ${latestQueue.toDate}, fromDate: ${latestQueue.fromDate}');
          // Update the UI with the latest data from Firestore (don't recreate controllers)
          setState(() {
            _initializeFromQueue(latestQueue, updateControllers: false);
          });
          print('✅ Updated UI with latest queue data');
        } else {
          print('⚠️ Latest queue is null or widget not mounted');
        }
      } else {
        print('⚠️ Queue ID not found for: ${widget.queue.name}');
      }
    } catch (e) {
      print('⚠️ Warning: Could not load latest queue data: $e');
      // Continue with widget.queue data if fetch fails
    }
  }

  @override
  void dispose() {
    _queueNameController.dispose();
    _customUnitNameController.dispose();
    super.dispose();
  }

  Widget _buildPriorityButton(String priority, Color color) {
    final isSelected = _selectedPriority.contains(priority);
    return OutlinedButton(
      onPressed: () {
        setState(() {
          if (isSelected) {
            _selectedPriority.remove(priority);
          } else {
            _selectedPriority.add(priority);
          }
        });
      },
      style: OutlinedButton.styleFrom(
        backgroundColor: isSelected ? color.withOpacity(0.1) : Colors.white,
        foregroundColor: isSelected ? color : Colors.grey[700],
        side: BorderSide(
          color: isSelected ? color : Colors.grey[300]!,
          width: isSelected ? 2 : 1,
        ),
        padding: const EdgeInsets.symmetric(vertical: 12),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
        ),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            isSelected ? Icons.check_circle : Icons.circle_outlined,
            size: 18,
            color: isSelected ? color : Colors.grey[600],
          ),
          const SizedBox(width: 6),
          Text(
            AppLanguage.translate(priority),
            style: TextStyle(
              fontSize: 13,
              fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _handleUpdate() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }
    
    if (_selectedDistributionArea == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(AppLanguage.translate('Please select a distribution area'))),
      );
      return;
    }
    if (_fromDate == null || _toDate == null || _fromTime == null || _toTime == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select date and time ranges')),
      );
      return;
    }
    if (_numberOfAvailableUnits == null || _estimatedQueueSize == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter number of units and estimated queue size')),
      );
      return;
    }

    // Get distribution area details from Firestore
    DistributionArea? selectedArea;
    try {
      selectedArea = await DistributionAreaService.getAreaById(_selectedDistributionArea!);
      if (selectedArea == null) {
        // Fallback to widget.distributionAreas if not found in Firestore
        try {
          selectedArea = widget.distributionAreas.firstWhere(
            (area) => area.id == _selectedDistributionArea,
          );
        } catch (e) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(AppLanguage.translate('Distribution area not found. Please select a valid area.'))),
          );
          return;
        }
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(AppLanguage.translate('Distribution area not found. Please select a valid area.'))),
      );
      return;
    }

    if (selectedArea == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(AppLanguage.translate('Please select a distribution area'))),
      );
      return;
    }

    // Use the selected toDate (Single Day queues can have different dates)
    final updatedQueue = widget.queue.copyWith(
      name: _queueNameController.text,
      country: selectedArea.country,
      governorate: selectedArea.governorate,
      city: selectedArea.city,
      queuePointName: selectedArea.areaName,
      distributionArea: _selectedDistributionArea!,
      queueType: _selectedQueueType!,
      fromDate: _fromDate!,
      toDate: _toDate!,
      fromTime: _fromTime!,
      toTime: _toTime!,
      unitName: _selectedUnitName == 'Others' ? _customUnitNameController.text : _selectedUnitName!,
      numberOfAvailableUnits: _numberOfAvailableUnits!,
      estimatedQueueSize: _estimatedQueueSize!,
      directServe: _directServe,
      priority: _selectedPriority,
      status: _status,
    );

    // Show loading indicator
    if (mounted) {
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => const Center(
          child: CircularProgressIndicator(),
        ),
      );
    }

    try {
      // Get queue ID by name
      final queueId = await QueueService.getQueueIdByName(widget.queue.name);
      
      if (queueId == null) {
        throw Exception(AppLanguage.translate('Queue not found in Firestore'));
      }

      // Update in Firestore
      await QueueService.updateQueue(queueId, updatedQueue);
      
      print('✅ Queue updated successfully in Firestore with ID: $queueId');
      
      // Close loading dialog
      if (mounted) {
        Navigator.of(context).pop(); // Close loading dialog
      }

      // Call the callback for UI updates
      if (mounted) {
        try {
    widget.onQueueUpdated(updatedQueue);
        } catch (e) {
          print('Warning: Error in onQueueUpdated callback: $e');
        }
      }

      // Close the edit screen
      if (mounted) {
    Navigator.of(context).pop();
    ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(AppLanguage.translate('Queue updated successfully')),
            backgroundColor: Colors.green,
            duration: const Duration(seconds: 2),
          ),
        );
      }
    } catch (e) {
      print('❌ Error updating queue in Firestore: $e');
      
      // Close loading dialog
      if (mounted) {
        Navigator.of(context).pop();
      }
      
      // Show error message
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to update queue: $e'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 3),
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    const tealGreen = Color(0xFF81CF01);
    const darkBlue = Color(0xFF1A237E);

    return Scaffold(
      appBar: AppBar(
        title: Text(AppLanguage.translate('Update Queue')),
        backgroundColor: tealGreen,
        foregroundColor: Colors.white,
      ),
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Color(0xFFE8F5E9), Colors.white],
          ),
        ),
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(20.0),
          child: Form(
            key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
                Text(
                  AppLanguage.translate('Update Queue'),
                  style: const TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                    color: darkBlue,
                  ),
                ),
                const SizedBox(height: 32),
              TextFormField(
                controller: _queueNameController,
                decoration: InputDecoration(
                    labelText: AppLanguage.translate('Queue Name *'),
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                  filled: true,
                  fillColor: Colors.white,
                ),
                  validator: (value) => value?.isEmpty ?? true ? AppLanguage.translate('Please enter queue name') : null,
              ),
              const SizedBox(height: 16),
                Text(AppLanguage.translate('Distribution Area *'), style: const TextStyle(fontWeight: FontWeight.bold)),
              const SizedBox(height: 8),
                StreamBuilder<List<DistributionArea>>(
                  stream: DistributionAreaService.getAllAreas(),
                  initialData: widget.distributionAreas,
                  builder: (context, snapshot) {
                    List<DistributionArea> displayAreas;
                    
                    if (snapshot.connectionState == ConnectionState.waiting && snapshot.data == null) {
                      displayAreas = widget.distributionAreas;
                    } else if (snapshot.hasError) {
                      print('StreamBuilder error: ${snapshot.error}');
                      displayAreas = widget.distributionAreas;
                    } else {
                      final firestoreAreas = snapshot.data ?? [];
                      // Prefer Firestore data, but ensure no duplicates
                      if (firestoreAreas.isNotEmpty) {
                        // Remove duplicates by ID
                        final uniqueMap = <String, DistributionArea>{};
                        for (final area in firestoreAreas) {
                          if (!uniqueMap.containsKey(area.id)) {
                            uniqueMap[area.id] = area;
                          }
                        }
                        final allUniqueAreas = uniqueMap.values.toList();
                        
                        // Filter areas based on logged-in user's distribution point
                        final currentAdmin = AdminService.currentAdmin;
                        if (currentAdmin != null && 
                            (currentAdmin.isSuperAdmin || currentAdmin.distributionPoint.toLowerCase() == 'all' || currentAdmin.mobile == '01010646279')) {
                          // Super Admin or admin with "All" can see all areas
                          displayAreas = allUniqueAreas;
                        } else if (currentAdmin != null && 
                                   (currentAdmin.isAdmin || currentAdmin.isQAdmin) && 
                                   currentAdmin.distributionPoint.isNotEmpty && 
                                   currentAdmin.distributionPoint.toLowerCase() != 'all') {
                          // For Admin and Q_Admin roles: Filter to only show their assigned distribution areas
                          // Match by distributionPoint name with areaName
                          displayAreas = allUniqueAreas.where((area) {
                            final adminPoint = currentAdmin.distributionPoint.toLowerCase();
                            final areaName = area.areaName.toLowerCase();
                            return areaName.contains(adminPoint) || adminPoint.contains(areaName);
                          }).toList();
                      } else {
                          // No admin logged in or no distribution point assigned, use passed list
                          displayAreas = widget.distributionAreas;
                        }
                      } else {
                        displayAreas = widget.distributionAreas;
                      }
                    }
                    
                    // Remove duplicates from displayAreas before validation
                    final uniqueDisplayAreas = <String, DistributionArea>{};
                    for (final area in displayAreas) {
                      if (!uniqueDisplayAreas.containsKey(area.id)) {
                        uniqueDisplayAreas[area.id] = area;
                      }
                    }
                    final finalDisplayAreas = uniqueDisplayAreas.values.toList();
                    
                    // Validate that selected distribution area exists in the list
                    final validSelectedArea = finalDisplayAreas.any((area) => area.id == _selectedDistributionArea)
                        ? _selectedDistributionArea
                        : null;
                    
                    return DropdownButtonFormField<String>(
                value: validSelectedArea,
                isExpanded: true,
                decoration: InputDecoration(
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                  filled: true,
                  fillColor: Colors.white,
                        hintText: finalDisplayAreas.isEmpty 
                            ? AppLanguage.translate('No areas available')
                            : AppLanguage.translate('Select Distribution Area'),
                      ),
                      items: finalDisplayAreas.isEmpty
                          ? [
                              DropdownMenuItem(
                                value: null,
                                enabled: false,
                                child: Text(
                                  AppLanguage.translate('No areas available'),
                                  style: TextStyle(color: Colors.grey[600]),
                                ),
                              ),
                            ]
                          : finalDisplayAreas.map((area) {
                  return DropdownMenuItem(
                    value: area.id,
                    child: Text(
                      area.fullName,
                      overflow: TextOverflow.ellipsis,
                      maxLines: 1,
                    ),
                  );
                }).toList(),
                selectedItemBuilder: (context) {
                        if (finalDisplayAreas.isEmpty) {
                          return [
                            Text(
                              AppLanguage.translate('No areas available'),
                              style: TextStyle(color: Colors.grey[600]),
                            ),
                          ];
                        }
                        return finalDisplayAreas.map((area) {
                    return Text(
                      area.fullName,
                      overflow: TextOverflow.ellipsis,
                      maxLines: 1,
                    );
                  }).toList();
                },
                      onChanged: finalDisplayAreas.isEmpty ? null : (value) {
                        // Validate that the selected value exists in unique areas
                        if (value == null || finalDisplayAreas.any((area) => area.id == value)) {
                          setState(() {
                            _selectedDistributionArea = value;
                          });
                        }
                      },
                    );
                  },
                ),
              const SizedBox(height: 16),
                Text(AppLanguage.translate('Queue Type *'), style: const TextStyle(fontWeight: FontWeight.bold)),
              const SizedBox(height: 8),
              DropdownButtonFormField<String>(
                value: _selectedQueueType,
                decoration: InputDecoration(
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                  filled: true,
                  fillColor: Colors.white,
                ),
                items: ['Single Day', 'Multi Day'].map((type) {
                  return DropdownMenuItem(value: type, child: Text(type));
                }).toList(),
                onChanged: (value) {
                  setState(() {
                    _selectedQueueType = value;
                    // Ensure toDate is not before fromDate
                    if (_fromDate != null && _toDate != null && _toDate!.isBefore(_fromDate!)) {
                      _toDate = _fromDate;
                    }
                  });
                },
              ),
              const SizedBox(height: 16),
              // Show different UI based on queue type
              _selectedQueueType == 'Single Day'
                  ? Column(
                      crossAxisAlignment: CrossAxisAlignment.stretch,
                      children: [
                        // Date range pickers for Single Day (can be one day or multiple days)
                        Row(
                          children: [
                            Expanded(
                              child: ElevatedButton.icon(
                          onPressed: () async {
                            final date = await showDatePicker(
                              context: context,
                              initialDate: _fromDate ?? DateTime.now(),
                              firstDate: DateTime.now(),
                              lastDate: DateTime.now().add(const Duration(days: 365)),
                            );
                            if (date != null) {
                              setState(() {
                                _fromDate = date;
                                      // Ensure toDate is not before fromDate
                                      if (_toDate != null && _toDate!.isBefore(date)) {
                                _toDate = date;
                                      }
                              });
                            }
                          },
                          icon: const Icon(Icons.calendar_today, size: 18),
                          label: Text(
                            _fromDate == null
                                      ? AppLanguage.translate('From Date *')
                                : '${_fromDate!.day}/${_fromDate!.month}/${_fromDate!.year}',
                            style: const TextStyle(fontSize: 14),
                          ),
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.white,
                            foregroundColor: tealGreen,
                            padding: const EdgeInsets.symmetric(vertical: 12),
                            side: BorderSide(color: tealGreen),
                          ),
                              ),
                            ),
                            const SizedBox(width: 12),
                            Expanded(
                              child: ElevatedButton.icon(
                                onPressed: () async {
                                  final date = await showDatePicker(
                                    context: context,
                                    initialDate: _toDate ?? (_fromDate ?? DateTime.now()),
                                    firstDate: _fromDate ?? DateTime.now(),
                                    lastDate: DateTime.now().add(const Duration(days: 365)),
                                  );
                                  if (date != null) {
                                    setState(() {
                                      _toDate = date;
                                    });
                                  }
                                },
                                icon: const Icon(Icons.calendar_today, size: 18),
                                label: Text(
                                  _toDate == null
                                      ? AppLanguage.translate('To Date *')
                                      : '${_toDate!.day}/${_toDate!.month}/${_toDate!.year}',
                                  style: const TextStyle(fontSize: 14),
                                ),
                                style: ElevatedButton.styleFrom(
                                  backgroundColor: Colors.white,
                                  foregroundColor: tealGreen,
                                  padding: const EdgeInsets.symmetric(vertical: 12),
                                  side: BorderSide(color: tealGreen),
                                ),
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 12),
                        // Time pickers for Single Day (12-hour format)
                        Row(
                          children: [
                            Expanded(
                              child: ElevatedButton.icon(
                                onPressed: () async {
                                  final time = await showTimePicker(
                                    context: context,
                                    initialTime: _fromTime ?? TimeOfDay.now(),
                                    builder: (context, child) {
                                      return MediaQuery(
                                        data: MediaQuery.of(context).copyWith(alwaysUse24HourFormat: false),
                                        child: child!,
                                      );
                                    },
                                  );
                                  if (time != null) {
                                    setState(() {
                                      _fromTime = time;
                                    });
                                  }
                                },
                                icon: const Icon(Icons.access_time, size: 18),
                                label: Text(
                                  _fromTime == null
                                      ? AppLanguage.translate('From Time *')
                                      : _fromTime!.format(context),
                                  style: const TextStyle(fontSize: 14),
                                ),
                                style: ElevatedButton.styleFrom(
                                  backgroundColor: Colors.white,
                                  foregroundColor: tealGreen,
                                  padding: const EdgeInsets.symmetric(vertical: 12),
                                  side: BorderSide(color: tealGreen),
                                ),
                              ),
                            ),
                            const SizedBox(width: 12),
                            Expanded(
                              child: ElevatedButton.icon(
                                onPressed: () async {
                                  final time = await showTimePicker(
                                    context: context,
                                    initialTime: _toTime ?? TimeOfDay.now(),
                                    builder: (context, child) {
                                      return MediaQuery(
                                        data: MediaQuery.of(context).copyWith(alwaysUse24HourFormat: false),
                                        child: child!,
                                      );
                                    },
                                  );
                                  if (time != null) {
                                    setState(() {
                                      _toTime = time;
                                    });
                                  }
                                },
                                icon: const Icon(Icons.access_time, size: 18),
                                label: Text(
                                  _toTime == null
                                      ? AppLanguage.translate('To Time *')
                                      : _toTime!.format(context),
                                  style: const TextStyle(fontSize: 14),
                                ),
                                style: ElevatedButton.styleFrom(
                                  backgroundColor: Colors.white,
                                  foregroundColor: tealGreen,
                                  padding: const EdgeInsets.symmetric(vertical: 12),
                                  side: BorderSide(color: tealGreen),
                                ),
                              ),
                            ),
                          ],
                        ),
                      ],
                    )
                  : Row(
                      children: [
                        Expanded(
                          child: ElevatedButton.icon(
                            onPressed: () async {
                              final date = await showDatePicker(
                                context: context,
                                initialDate: _fromDate ?? DateTime.now(),
                                firstDate: DateTime.now(),
                                lastDate: DateTime.now().add(const Duration(days: 365)),
                              );
                              if (date != null) {
                                // Show time picker in 12-hour format
                                final time = await showTimePicker(
                                  context: context,
                                  initialTime: _fromTime ?? TimeOfDay.now(),
                                  builder: (context, child) {
                                    return MediaQuery(
                                      data: MediaQuery.of(context).copyWith(alwaysUse24HourFormat: false),
                                      child: child!,
                                    );
                                  },
                                );
                                if (time != null) {
                                  setState(() {
                                    _fromDate = date;
                                    _fromTime = time;
                                  });
                                }
                              }
                            },
                            icon: const Icon(Icons.calendar_today, size: 18),
                            label: Text(
                              _fromDate == null || _fromTime == null
                                  ? AppLanguage.translate('From Date & Time *')
                                  : '${_fromDate!.day}/${_fromDate!.month}/${_fromDate!.year} ${_fromTime!.format(context)}',
                              style: const TextStyle(fontSize: 14),
                            ),
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Colors.white,
                              foregroundColor: tealGreen,
                              padding: const EdgeInsets.symmetric(vertical: 12),
                              side: BorderSide(color: tealGreen),
                            ),
                          ),
                        ),
                        const SizedBox(width: 12),
                        Expanded(
                          child: ElevatedButton.icon(
                            onPressed: () async {
                              final date = await showDatePicker(
                                context: context,
                                initialDate: _toDate ?? (_fromDate ?? DateTime.now()),
                                firstDate: _fromDate ?? DateTime.now(),
                                lastDate: DateTime.now().add(const Duration(days: 365)),
                              );
                              if (date != null) {
                                // Show time picker in 12-hour format
                                final time = await showTimePicker(
                                  context: context,
                                  initialTime: _toTime ?? TimeOfDay.now(),
                                  builder: (context, child) {
                                    return MediaQuery(
                                      data: MediaQuery.of(context).copyWith(alwaysUse24HourFormat: false),
                                      child: child!,
                                    );
                                  },
                                );
                                if (time != null) {
                                  setState(() {
                                    _toDate = date;
                                    _toTime = time;
                                  });
                                }
                              }
                            },
                            icon: const Icon(Icons.calendar_today, size: 18),
                            label: Text(
                              _toDate == null || _toTime == null
                                  ? AppLanguage.translate('To Date & Time *')
                                  : '${_toDate!.day}/${_toDate!.month}/${_toDate!.year} ${_toTime!.format(context)}',
                              style: const TextStyle(fontSize: 14),
                            ),
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Colors.white,
                              foregroundColor: tealGreen,
                              padding: const EdgeInsets.symmetric(vertical: 12),
                              side: BorderSide(color: tealGreen),
                            ),
                          ),
                        ),
                      ],
                    ),
              const SizedBox(height: 16),
                Text(AppLanguage.translate('Unit Name *'), style: const TextStyle(fontWeight: FontWeight.bold)),
                        const SizedBox(height: 8),
                StreamBuilder<List<Unit>>(
                  stream: UnitService.getAllUnits(),
                  initialData: const [],
                  builder: (context, snapshot) {
                    List<Unit> displayUnits = [];
                    
                    if (snapshot.connectionState == ConnectionState.waiting && snapshot.data == null) {
                      displayUnits = [];
                    } else if (snapshot.hasError) {
                      print('StreamBuilder error for units: ${snapshot.error}');
                      displayUnits = [
                        Unit(
                          id: 'meals',
                          name: 'Meals',
                          description: 'Food meals',
                          isActive: true,
                          order: 1,
                          createdAt: DateTime.now(),
                          updatedAt: DateTime.now(),
                        ),
                        Unit(
                          id: 'bags',
                          name: 'Bags',
                          description: 'Food bags',
                          isActive: true,
                          order: 2,
                          createdAt: DateTime.now(),
                          updatedAt: DateTime.now(),
                        ),
                        Unit(
                          id: 'blankets',
                          name: 'Blankets',
                          description: 'Blankets and covers',
                          isActive: true,
                          order: 3,
                          createdAt: DateTime.now(),
                          updatedAt: DateTime.now(),
                        ),
                        Unit(
                          id: 'others',
                          name: 'Others',
                          description: 'Other unit types',
                          isActive: true,
                          order: 99,
                          createdAt: DateTime.now(),
                          updatedAt: DateTime.now(),
                        ),
                      ];
                    } else {
                      final firestoreUnits = snapshot.data ?? [];
                      if (firestoreUnits.isNotEmpty) {
                        // Remove duplicates by unit name to prevent dropdown errors
                        final seenNames = <String>{};
                        displayUnits = firestoreUnits.where((unit) {
                          if (seenNames.contains(unit.name)) {
                            return false; // Skip duplicate
                          }
                          seenNames.add(unit.name);
                          return true;
                        }).toList();
                      } else {
                        displayUnits = [
                              Unit(
                                id: 'meals',
                                name: 'Meals',
                                description: 'Food meals',
                                isActive: true,
                                order: 1,
                                createdAt: DateTime.now(),
                                updatedAt: DateTime.now(),
                              ),
                              Unit(
                                id: 'bags',
                                name: 'Bags',
                                description: 'Food bags',
                                isActive: true,
                                order: 2,
                                createdAt: DateTime.now(),
                                updatedAt: DateTime.now(),
                              ),
                              Unit(
                                id: 'blankets',
                                name: 'Blankets',
                                description: 'Blankets and covers',
                                isActive: true,
                                order: 3,
                                createdAt: DateTime.now(),
                                updatedAt: DateTime.now(),
                              ),
                              Unit(
                                id: 'others',
                                name: 'Others',
                                description: 'Other unit types',
                                isActive: true,
                                order: 99,
                                createdAt: DateTime.now(),
                                updatedAt: DateTime.now(),
                              ),
                            ];
                      }
                    }
                    
                    return DropdownButtonFormField<String>(
                value: _selectedUnitName,
                decoration: InputDecoration(
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                  filled: true,
                  fillColor: Colors.white,
                        hintText: displayUnits.isEmpty 
                            ? AppLanguage.translate('Loading units...')
                            : AppLanguage.translate('Select Unit Name'),
                      ),
                      items: displayUnits.isEmpty
                          ? [
                              DropdownMenuItem(
                                value: null,
                                enabled: false,
                                child: Text(
                                  AppLanguage.translate('No units available'),
                                  style: TextStyle(color: Colors.grey[600]),
                                ),
                              ),
                            ]
                          : displayUnits.map((unit) {
                              return DropdownMenuItem(
                                value: unit.name,
                                child: Text(unit.name),
                              );
                }).toList(),
                      onChanged: displayUnits.isEmpty ? null : (value) => setState(() => _selectedUnitName = value),
                    );
                  },
              ),
              if (_selectedUnitName == 'Others') ...[
                const SizedBox(height: 16),
                TextFormField(
                  controller: _customUnitNameController,
                  decoration: InputDecoration(
                      labelText: AppLanguage.translate('Custom Unit Name *'),
                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                    filled: true,
                    fillColor: Colors.white,
                  ),
                    validator: _selectedUnitName == 'Others' ? (value) => value?.isEmpty ?? true ? AppLanguage.translate('Please enter unit name') : null : null,
                ),
              ],
              const SizedBox(height: 16),
              TextFormField(
                  initialValue: _numberOfAvailableUnits?.toString() ?? '',
                keyboardType: TextInputType.number,
                decoration: InputDecoration(
                    labelText: AppLanguage.translate('Number of Available Units *'),
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                  filled: true,
                  fillColor: Colors.white,
                ),
                  onChanged: (value) => _numberOfAvailableUnits = int.tryParse(value),
                  validator: (value) => value?.isEmpty ?? true ? AppLanguage.translate('Please enter number of units') : null,
              ),
              const SizedBox(height: 16),
              TextFormField(
                  initialValue: _estimatedQueueSize?.toString() ?? '',
                keyboardType: TextInputType.number,
                decoration: InputDecoration(
                    labelText: AppLanguage.translate('Estimated Queue Size *'),
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                  filled: true,
                  fillColor: Colors.white,
                ),
                  onChanged: (value) => _estimatedQueueSize = int.tryParse(value),
                  validator: (value) => value?.isEmpty ?? true ? AppLanguage.translate('Please enter estimated queue size') : null,
              ),
              const SizedBox(height: 16),
              CheckboxListTile(
                  title: Text(AppLanguage.translate('Direct Serve Option')),
                value: _directServe,
                onChanged: (value) => setState(() => _directServe = value ?? false),
              ),
              const SizedBox(height: 16),
                Text(AppLanguage.translate('Priority (optional)'), style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 14)),
              const SizedBox(height: 8),
                Row(
                  children: [
                    Expanded(
                      child: _buildPriorityButton('Female', tealGreen),
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: _buildPriorityButton('Elderly', tealGreen),
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: _buildPriorityButton('Disability', tealGreen),
                    ),
                  ],
                ),
              const SizedBox(height: 16),
                Text(AppLanguage.translate('Status *'), style: const TextStyle(fontWeight: FontWeight.bold)),
              const SizedBox(height: 8),
              DropdownButtonFormField<String>(
                value: _status,
                decoration: InputDecoration(
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                  filled: true,
                  fillColor: Colors.white,
                ),
                items: ['active', 'banned', 'suspended', 'completed'].map((status) {
                  return DropdownMenuItem(value: status, child: Text(status.toUpperCase()));
                }).toList(),
                onChanged: (value) => setState(() => _status = value ?? 'active'),
              ),
              const SizedBox(height: 32),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: _handleUpdate,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: tealGreen,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                  ),
                  child: Text(AppLanguage.translate('Update Queue'), style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                ),
              ),
            ],
            ),
          ),
        ),
      ),
    );
  }
}

// Admin Management Screen
class AdminManagementScreen extends StatefulWidget {
  final List<Admin> admins;
  final List<Admin> adminRequests;
  final List<DistributionArea> distributionAreas;
  final Function(Admin) onAdminCreated;
  final Function(Admin) onAdminRequestApproved;
  final Function(String) onAdminRequestRejected;

  const AdminManagementScreen({
    super.key,
    required this.admins,
    required this.adminRequests,
    required this.distributionAreas,
    required this.onAdminCreated,
    required this.onAdminRequestApproved,
    required this.onAdminRequestRejected,
  });

  @override
  State<AdminManagementScreen> createState() => _AdminManagementScreenState();
}

class _AdminManagementScreenState extends State<AdminManagementScreen> {
  int _selectedTab = 0; // 0: Create Admin, 1: Requests

  @override
  Widget build(BuildContext context) {
    // Security check: Only Super Admin can access this screen
    final currentAdmin = AdminService.currentAdmin;
    if (currentAdmin == null || !currentAdmin.isSuperAdmin) {
      // If not super admin, show error and go back
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Access denied. Super Admin only.'),
              backgroundColor: Colors.red,
            ),
          );
          Navigator.of(context).pop();
        }
      });
      return Scaffold(
        appBar: AppBar(
          title: Text(AppLanguage.translate('Admin Management')),
          backgroundColor: Colors.red,
          foregroundColor: Colors.white,
        ),
        body: const Center(
          child: Text('Access Denied'),
        ),
      );
    }
    
    const tealGreen = Color(0xFF81CF01);
    
    return Scaffold(
      backgroundColor: Colors.grey[50],
      appBar: AppBar(
        elevation: 0,
        title: Row(
          children: [
            Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: Colors.white.withOpacity(0.2),
                borderRadius: BorderRadius.circular(8),
              ),
              child: const Icon(Icons.admin_panel_settings, size: 24),
            ),
            const SizedBox(width: 12),
            Text(
              AppLanguage.translate('Q Admin Management'),
              style: const TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
                letterSpacing: 0.5,
              ),
            ),
          ],
        ),
        backgroundColor: tealGreen,
        foregroundColor: Colors.white,
        flexibleSpace: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
              colors: [tealGreen, tealGreen.withOpacity(0.8)],
            ),
          ),
        ),
      ),
      body: Column(
        children: [
          // Modern Tab Bar
          Container(
            margin: const EdgeInsets.all(16),
                    decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(12),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.05),
                  blurRadius: 10,
                  offset: const Offset(0, 2),
                ),
              ],
            ),
            child: Row(
              children: [
                Expanded(
                  child: _buildTabButton(
                    index: 0,
                    icon: Icons.person_add,
                    label: AppLanguage.translate('Create Admin'),
                    isSelected: _selectedTab == 0,
                  ),
                ),
                Expanded(
                  child: _buildTabButton(
                    index: 1,
                    icon: Icons.request_quote,
                    label: AppLanguage.translate('Admin Requests'),
                    isSelected: _selectedTab == 1,
                    badgeCount: widget.adminRequests.isNotEmpty ? widget.adminRequests.length : null,
                  ),
                ),
              ],
                ),
              ),
              Expanded(
            child: _selectedTab == 0
                ? CreateAdminScreen(
                    distributionAreas: widget.distributionAreas,
                    onAdminCreated: widget.onAdminCreated,
                  )
                : AdminRequestsScreen(
                    distributionAreas: widget.distributionAreas,
                    onRequestApproved: widget.onAdminRequestApproved,
                    onRequestRejected: widget.onAdminRequestRejected,
                  ),
          ),
        ],
      ),
    );
  }

  Widget _buildTabButton({
    required int index,
    required IconData icon,
    required String label,
    required bool isSelected,
    int? badgeCount,
  }) {
    const tealGreen = Color(0xFF81CF01);
    
    return InkWell(
      onTap: () => setState(() => _selectedTab = index),
      borderRadius: BorderRadius.circular(12),
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 8),
        decoration: BoxDecoration(
          color: isSelected ? tealGreen.withOpacity(0.1) : Colors.transparent,
          borderRadius: BorderRadius.circular(12),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
                      children: [
            Stack(
              clipBehavior: Clip.none,
              children: [
                Icon(
                  icon,
                  color: isSelected ? tealGreen : Colors.grey[600],
                  size: 24,
                ),
                if (badgeCount != null && badgeCount > 0)
                          Positioned(
                    right: -8,
                    top: -8,
                            child: Container(
                              padding: const EdgeInsets.all(4),
                              decoration: const BoxDecoration(
                                color: Colors.red,
                                shape: BoxShape.circle,
                              ),
                      constraints: const BoxConstraints(
                        minWidth: 18,
                        minHeight: 18,
                      ),
                      child: Center(
                              child: Text(
                          '$badgeCount',
                                style: const TextStyle(
                                  color: Colors.white,
                                  fontSize: 10,
                                  fontWeight: FontWeight.bold,
                                ),
                    ),
                  ),
                ),
              ),
            ],
          ),
            const SizedBox(height: 6),
            Text(
              label,
              textAlign: TextAlign.center,
              style: TextStyle(
                color: isSelected ? tealGreen : Colors.grey[700],
                fontWeight: isSelected ? FontWeight.bold : FontWeight.w500,
                fontSize: 12,
                  ),
          ),
        ],
        ),
      ),
    );
  }
}

// Create Admin Screen (Super Admin)
class CreateAdminScreen extends StatefulWidget {
  final List<DistributionArea> distributionAreas;
  final Function(Admin) onAdminCreated;

  const CreateAdminScreen({
    super.key,
    required this.distributionAreas,
    required this.onAdminCreated,
  });

  @override
  State<CreateAdminScreen> createState() => _CreateAdminScreenState();
}

class _CreateAdminScreenState extends State<CreateAdminScreen> {
  final _formKey = GlobalKey<FormState>();
  final _fullNameController = TextEditingController();
  final _mobileController = TextEditingController();
  final _passwordController = TextEditingController();
  final _notesController = TextEditingController();
  final _referenceController = TextEditingController();
  final _newDistributionPointController = TextEditingController();
  final _newDistributionPointDescController = TextEditingController();

  String? _selectedCountry = 'Egypt';
  String? _selectedGovernorate;
  String? _selectedCity;
  String? _selectedDistributionPoint;
  bool _useNewDistributionPoint = false;
  String _status = 'active';
  String? _selectedRole; // 'Super_Admin', 'Admin', or 'Q_Admin'

  final Map<String, List<String>> _egyptGovernoratesCities = {
    'Cairo': ['Cairo', 'Nasr City', 'Heliopolis', 'Maadi', 'Zamalek'],
    'Giza': ['Giza', '6th of October', 'Sheikh Zayed', 'Dokki'],
    'Alexandria': ['Alexandria', 'Montaza', 'Sidi Bishr'],
    'Luxor': ['Luxor', 'Karnak'],
    'Aswan': ['Aswan', 'Elephantine'],
  };

  List<String> get _availableCities {
    if (_selectedGovernorate == null) return [];
    return _egyptGovernoratesCities[_selectedGovernorate] ?? [];
  }

  // This will be populated from Firestore based on selected city
  List<DistributionArea> _availableDistributionAreas = [];

  @override
  void dispose() {
    _fullNameController.dispose();
    _mobileController.dispose();
    _passwordController.dispose();
    _notesController.dispose();
    _referenceController.dispose();
    _newDistributionPointController.dispose();
    _newDistributionPointDescController.dispose();
    super.dispose();
  }

  Future<void> _handleCreate() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }
    
    if (_selectedGovernorate == null || _selectedCity == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select governorate and city')),
      );
      return;
    }
    if (_selectedDistributionPoint == null && !_useNewDistributionPoint) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select or create a distribution point')),
      );
      return;
    }
    if (_useNewDistributionPoint && _newDistributionPointController.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter distribution point name')),
      );
      return;
    }
    if (_passwordController.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter password')),
      );
      return;
    }
    if (_selectedRole == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select role')),
      );
      return;
    }

    // Show loading indicator
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const Center(child: CircularProgressIndicator()),
    );

    try {
      // Get distribution point name
      String distributionPointName;
      String? distributionPointDescription;
      
      if (_useNewDistributionPoint) {
        // Using new distribution point - create it in Firestore first
        distributionPointName = _newDistributionPointController.text;
        distributionPointDescription = _newDistributionPointDescController.text.isNotEmpty
            ? _newDistributionPointDescController.text
            : null;
        
        // Create the new distribution area in Firestore
        try {
          final newArea = DistributionArea(
            id: '', // Will be set by Firestore
            country: _selectedCountry!,
            governorate: _selectedGovernorate!,
            city: _selectedCity!,
            areaName: distributionPointName,
          );
          final areaId = await DistributionAreaService.createArea(newArea);
          print('✅ Created new distribution area with ID: $areaId');
        } catch (e) {
          print('⚠️ Could not create distribution area in Firestore: $e');
          // Continue anyway - admin will still be created
        }
      } else {
        // Using predefined distribution point from database
        distributionPointName = _selectedDistributionPoint!;
        distributionPointDescription = null;
      }

      // For Super Admin, set distributionPoint to "All"
      final finalDistributionPoint = _selectedRole == 'Super_Admin' ? 'All' : distributionPointName;

      final admin = Admin(
        id: '', // Will be set by Firestore
        country: _selectedCountry!,
        governorate: _selectedGovernorate!,
        city: _selectedCity!,
        distributionPoint: finalDistributionPoint,
        distributionPointDescription: _selectedRole == 'Super_Admin' ? null : distributionPointDescription,
        fullName: _fullNameController.text,
        mobile: _mobileController.text,
        password: _passwordController.text,
        role: _selectedRole,
        notes: _notesController.text,
        reference: _referenceController.text.isNotEmpty ? _referenceController.text : null,
        status: _status,
        isRequestedByGuest: false,
        createdAt: DateTime.now(),
      );

      // Save to Firestore
      print('💾 Saving admin to Firestore...');
      final adminId = await AdminService.createAdmin(admin);
      print('✅ Admin saved to Firestore with ID: $adminId');
      
      // Update admin with the ID from Firestore
      final createdAdmin = admin.copyWith(id: adminId);

      if (mounted) {
        Navigator.pop(context); // Close loading dialog
        widget.onAdminCreated(createdAdmin);
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Admin created successfully'),
            backgroundColor: Colors.green,
          ),
        );
        
        // Reset form
        _formKey.currentState!.reset();
        setState(() {
          _selectedGovernorate = null;
          _selectedCity = null;
          _selectedDistributionPoint = null;
          _useNewDistributionPoint = false;
          _status = 'active';
          _selectedRole = null;
          _passwordController.clear();
        });
      }
    } catch (e, stackTrace) {
      print('❌ Error creating admin: $e');
      print('Stack trace: $stackTrace');
      if (mounted) {
        Navigator.pop(context); // Close loading dialog
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error creating admin: $e'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 5),
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    const tealGreen = Color(0xFF81CF01);
    const darkBlue = Color(0xFF1A237E);

    return Container(
      decoration: const BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topCenter,
          end: Alignment.bottomCenter,
          colors: [Color(0xFFE8F5E9), Colors.white],
        ),
      ),
      child: SingleChildScrollView(
        padding: const EdgeInsets.all(20.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                AppLanguage.translate('Create Admin'),
                style: TextStyle(
                  fontSize: 24,
                  fontWeight: FontWeight.bold,
                  color: darkBlue,
                ),
              ),
              const SizedBox(height: 32),
              _buildLabel('Country *'),
              const SizedBox(height: 8),
              _buildDropdown(
                _selectedCountry ?? '',
                ['Egypt'],
                (value) => setState(() => _selectedCountry = value),
              ),
              const SizedBox(height: 24),
              _buildLabel('Governorate *'),
              const SizedBox(height: 8),
              _buildGovernorateDropdown(
                _selectedGovernorate,
                (value) => setState(() {
                  _selectedGovernorate = value;
                  _selectedCity = null;
                  _selectedDistributionPoint = null;
                }),
              ),
              const SizedBox(height: 24),
              _buildLabel('City *'),
              const SizedBox(height: 8),
              _buildDropdown(
                (_selectedCity != null && _availableCities.contains(_selectedCity)) ? _selectedCity! : '',
                _availableCities,
                (value) => setState(() {
                  _selectedCity = value;
                  _selectedDistributionPoint = null;
                  _useNewDistributionPoint = false;
                }),
                enabled: _selectedGovernorate != null,
              ),
              const SizedBox(height: 24),
              _buildLabel('Distribution Point *'),
              const SizedBox(height: 8),
              // Use StreamBuilder to load distribution areas from Firestore
              StreamBuilder<List<DistributionArea>>(
                stream: DistributionAreaService.getAllAreas(),
                initialData: widget.distributionAreas, // Use local list as initial data
                builder: (context, snapshot) {
                  // Always show dropdown, use local list if stream hasn't loaded yet or has error
                  List<DistributionArea> displayAreas;
                  
                  if (snapshot.connectionState == ConnectionState.waiting && snapshot.data == null) {
                    // Still loading and no data yet - use local list
                    displayAreas = widget.distributionAreas;
                  } else if (snapshot.hasError) {
                    // Error occurred - use local list
                    displayAreas = widget.distributionAreas;
                  } else {
                    // Use Firestore data if available, otherwise fall back to local
                    final firestoreAreas = snapshot.data ?? [];
                    displayAreas = firestoreAreas.isNotEmpty ? firestoreAreas : widget.distributionAreas;
                  }
                  
                  // Filter areas by selected city
                  final cityAreas = _selectedCity != null
                      ? displayAreas.where((area) => area.city == _selectedCity).toList()
                      : <DistributionArea>[];
                  
                  // Update local list for reference (no setState to avoid rebuilds)
                  _availableDistributionAreas = cityAreas;
                  
                  // Create list of area names + "Others" option
                  final areaNames = cityAreas.map((area) => area.areaName).toList();
                  final dropdownItems = <String>[...areaNames, 'Others'];
                  
                  return _buildDropdown(
                    _useNewDistributionPoint ? 'Others' : (_selectedDistributionPoint ?? ''),
                    dropdownItems,
                    (value) {
                      setState(() {
                        if (value == 'Others') {
                          _useNewDistributionPoint = true;
                          _selectedDistributionPoint = null;
                        } else {
                          _useNewDistributionPoint = false;
                          _selectedDistributionPoint = value;
                        }
                      });
                    },
                    enabled: _selectedCity != null,
                  );
                },
              ),
              if (_useNewDistributionPoint) ...[
                const SizedBox(height: 16),
                TextFormField(
                  controller: _newDistributionPointController,
                  decoration: _buildInputDecoration('Distribution Point Name *'),
                  validator: (value) => value?.isEmpty ?? true ? 'Required' : null,
                ),
                const SizedBox(height: 16),
                TextFormField(
                  controller: _newDistributionPointDescController,
                  maxLines: 3,
                  decoration: _buildInputDecoration('Distribution Point Description'),
                ),
              ],
              const SizedBox(height: 24),
              _buildLabel('Full Name *'),
              const SizedBox(height: 8),
              TextFormField(
                controller: _fullNameController,
                decoration: _buildInputDecoration('Enter full name'),
                validator: (value) => value?.isEmpty ?? true ? 'Required' : null,
              ),
              const SizedBox(height: 24),
              _buildLabel('Mobile *'),
              const SizedBox(height: 8),
              TextFormField(
                controller: _mobileController,
                keyboardType: TextInputType.phone,
                decoration: _buildInputDecoration('Enter mobile number'),
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Required';
                  }
                  final regex = RegExp(r'^01[0-2,5]{1}[0-9]{8}$');
                  if (!regex.hasMatch(value)) {
                    return 'Invalid Egyptian mobile number';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 24),
              _buildLabel('Password *'),
              const SizedBox(height: 8),
              TextFormField(
                controller: _passwordController,
                obscureText: true,
                decoration: _buildInputDecoration('Enter password'),
                validator: (value) => value?.isEmpty ?? true ? 'Required' : null,
              ),
              const SizedBox(height: 24),
              _buildLabel('Role *'),
              const SizedBox(height: 8),
              _buildDropdown(
                _selectedRole ?? '',
                ['Super_Admin', 'Admin', 'Q_Admin'],
                (value) => setState(() => _selectedRole = value),
              ),
              const SizedBox(height: 24),
              _buildLabel('Notes *'),
              const SizedBox(height: 8),
              TextFormField(
                controller: _notesController,
                maxLines: 3,
                decoration: _buildInputDecoration('Enter notes'),
                validator: (value) => value?.isEmpty ?? true ? 'Required' : null,
              ),
              const SizedBox(height: 24),
              _buildLabel('Reference (Optional)'),
              const SizedBox(height: 8),
              TextFormField(
                controller: _referenceController,
                decoration: _buildInputDecoration('Enter reference'),
              ),
              const SizedBox(height: 24),
              _buildLabel('Status *'),
              const SizedBox(height: 8),
              _buildDropdown(
                _status,
                ['pending', 'active', 'banned'],
                (value) => setState(() => _status = value ?? 'active'),
              ),
              const SizedBox(height: 32),
              ElevatedButton(
                onPressed: _handleCreate,
                style: ElevatedButton.styleFrom(
                  backgroundColor: tealGreen,
                  foregroundColor: Colors.white,
                  minimumSize: const Size(double.infinity, 0),
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
                child: Text(AppLanguage.translate('Create Admin')),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildLabel(String text) {
    return Text(
      AppLanguage.translate(text),
      style: const TextStyle(fontSize: 14, fontWeight: FontWeight.w500, color: Color(0xFF1A237E)),
    );
  }

  InputDecoration _buildInputDecoration(String hint) {
    return InputDecoration(
      hintText: AppLanguage.translate(hint),
      border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
      filled: true,
      fillColor: Colors.white,
    );
  }

  // Helper method to get governorate display name based on current language
  String _getGovernorateDisplayName(String governorate) {
    const Map<String, Map<String, String>> governorateNames = {
      'Cairo': {'ar': 'القاهرة', 'en': 'Cairo'},
      'Alexandria': {'ar': 'الإسكندرية', 'en': 'Alexandria'},
      'Giza': {'ar': 'الجيزة', 'en': 'Giza'},
      'Qalyubia': {'ar': 'القليوبية', 'en': 'Qalyubia'},
      'Sharqia': {'ar': 'الشرقية', 'en': 'Sharqia'},
      'Dakahlia': {'ar': 'الدقهلية', 'en': 'Dakahlia'},
      'Beheira': {'ar': 'البحيرة', 'en': 'Beheira'},
      'Kafr El Sheikh': {'ar': 'كفر الشيخ', 'en': 'Kafr El Sheikh'},
      'Monufia': {'ar': 'المنوفية', 'en': 'Monufia'},
      'Gharbia': {'ar': 'الغربية', 'en': 'Gharbia'},
      'Damietta': {'ar': 'دمياط', 'en': 'Damietta'},
      'Port Said': {'ar': 'بورسعيد', 'en': 'Port Said'},
      'Ismailia': {'ar': 'الإسماعيلية', 'en': 'Ismailia'},
      'Suez': {'ar': 'السويس', 'en': 'Suez'},
      'Faiyum': {'ar': 'الفيوم', 'en': 'Fayoum'},
      'Beni Suef': {'ar': 'بني سويف', 'en': 'Beni Suef'},
      'Minya': {'ar': 'المنيا', 'en': 'Minya'},
      'Assiut': {'ar': 'أسيوط', 'en': 'Assiut'},
      'Sohag': {'ar': 'سوهاج', 'en': 'Sohag'},
      'Qena': {'ar': 'قنا', 'en': 'Qena'},
      'Luxor': {'ar': 'الأقصر', 'en': 'Luxor'},
      'Aswan': {'ar': 'أسوان', 'en': 'Aswan'},
      'Red Sea': {'ar': 'البحر الأحمر', 'en': 'Red Sea'},
      'New Valley': {'ar': 'الوادي الجديد', 'en': 'New Valley'},
      'Matruh': {'ar': 'مطروح', 'en': 'Matrouh'},
      'North Sinai': {'ar': 'شمال سيناء', 'en': 'North Sinai'},
      'South Sinai': {'ar': 'جنوب سيناء', 'en': 'South Sinai'},
    };
    final names = governorateNames[governorate];
    if (names == null) return governorate;
    return AppLanguage.isArabic ? names['ar']! : names['en']!;
  }

  // Helper method to build governorate dropdown with localized names
  Widget _buildGovernorateDropdown(String? selectedKey, Function(String?) onChanged, {bool enabled = true}) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        border: Border.all(color: const Color(0xFFE0E0E0)),
        borderRadius: BorderRadius.circular(8),
        color: enabled ? Colors.white : Colors.grey[200],
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: selectedKey,
          isExpanded: true,
          hint: Text(AppLanguage.translate('Select governorate')),
          items: _egyptGovernoratesCities.keys.map((gov) {
            final displayName = _getGovernorateDisplayName(gov);
            return DropdownMenuItem(value: gov, child: Text(displayName));
          }).toList(),
          onChanged: enabled ? onChanged : null,
        ),
      ),
    );
  }

  Widget _buildDropdown(String value, List<String> items, Function(String?) onChanged, {bool enabled = true}) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        border: Border.all(color: const Color(0xFFE0E0E0)),
        borderRadius: BorderRadius.circular(8),
        color: enabled ? Colors.white : Colors.grey[200],
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: value.isEmpty ? null : value,
          isExpanded: true,
          hint: Text(enabled ? 'Select' : 'Select previous field first'),
          items: items.map((item) => DropdownMenuItem(value: item, child: Text(AppLanguage.translate(item)))).toList(),
          onChanged: enabled ? onChanged : null,
        ),
      ),
    );
  }
}

// Admin Requests Screen
class AdminRequestsScreen extends StatefulWidget {
  final List<DistributionArea> distributionAreas;
  final Function(Admin) onRequestApproved;
  final Function(String) onRequestRejected;

  const AdminRequestsScreen({
    super.key,
    required this.distributionAreas,
    required this.onRequestApproved,
    required this.onRequestRejected,
  });

  @override
  State<AdminRequestsScreen> createState() => _AdminRequestsScreenState();
}

class _AdminRequestsScreenState extends State<AdminRequestsScreen> {
  int _selectedTab = 0; // 0: Pending, 1: Approved, 2: Rejected

  @override
  Widget build(BuildContext context) {
    const tealGreen = Color(0xFF81CF01);
    
    return Container(
      color: Colors.grey[50],
      child: Column(
        children: [
          // Modern Filter Tabs
          Container(
            margin: const EdgeInsets.fromLTRB(16, 8, 16, 16),
                    decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(12),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.05),
                  blurRadius: 10,
                  offset: const Offset(0, 2),
                ),
              ],
            ),
            child: Row(
              children: [
                Expanded(
                  child: _buildFilterTab(
                    index: 0,
                    icon: Icons.pending_actions,
                    label: 'Pending',
                    color: Colors.orange,
                    isSelected: _selectedTab == 0,
                ),
              ),
              Expanded(
                  child: _buildFilterTab(
                    index: 1,
                    icon: Icons.check_circle,
                    label: 'Approved',
                    color: Colors.green,
                    isSelected: _selectedTab == 1,
                ),
              ),
              Expanded(
                  child: _buildFilterTab(
                    index: 2,
                    icon: Icons.cancel,
                    label: 'Rejected',
                    color: Colors.red,
                    isSelected: _selectedTab == 2,
                ),
              ),
            ],
            ),
          ),
          // Requests list
          Expanded(
            child: StreamBuilder<List<Admin>>(
              stream: AdminRequestService.getAllRequestsHistory(),
              builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting && !snapshot.hasData) {
            return const Center(child: CircularProgressIndicator());
          }
          
          if (snapshot.hasError) {
            return Center(
              child: Text('Error loading admin requests: ${snapshot.error}'),
            );
          }
          
          final allRequests = snapshot.data ?? <Admin>[];
          
          // Filter requests based on selected tab
          final filteredRequests = allRequests.where((request) {
            if (_selectedTab == 0) return request.status == 'pending';
            if (_selectedTab == 1) return request.status == 'approved';
            if (_selectedTab == 2) return request.status == 'rejected';
            return true;
          }).toList();
          
          if (filteredRequests.isEmpty) {
            return _buildEmptyState(_selectedTab);
          }
          
          return ListView.builder(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              itemCount: filteredRequests.length,
              itemBuilder: (context, index) {
                final request = filteredRequests[index];
                return _buildRequestCard(request, context);
              },
            );
          },
        ),
      ),
        ],
      ),
    );
  }

  Widget _buildFilterTab({
    required int index,
    required IconData icon,
    required String label,
    required Color color,
    required bool isSelected,
  }) {
    return InkWell(
      onTap: () => setState(() => _selectedTab = index),
      borderRadius: BorderRadius.circular(12),
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        padding: const EdgeInsets.symmetric(vertical: 14, horizontal: 8),
        decoration: BoxDecoration(
          color: isSelected ? color.withOpacity(0.1) : Colors.transparent,
          borderRadius: BorderRadius.circular(12),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              icon,
              color: isSelected ? color : Colors.grey[600],
              size: 22,
            ),
            const SizedBox(height: 6),
            Text(
              label,
              style: TextStyle(
                color: isSelected ? color : Colors.grey[700],
                fontWeight: isSelected ? FontWeight.bold : FontWeight.w500,
                fontSize: 12,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildEmptyState(int selectedTab) {
    IconData icon;
    String message;
    Color color;

    switch (selectedTab) {
      case 0:
        icon = Icons.pending_actions;
        message = 'No pending requests';
        color = Colors.orange;
        break;
      case 1:
        icon = Icons.check_circle;
        message = 'No approved requests';
        color = Colors.green;
        break;
      default:
        icon = Icons.cancel;
        message = 'No rejected requests';
        color = Colors.red;
    }

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: color.withOpacity(0.1),
              shape: BoxShape.circle,
            ),
            child: Icon(
              icon,
              size: 64,
              color: color.withOpacity(0.6),
            ),
          ),
          const SizedBox(height: 24),
          Text(
            message,
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.w600,
              color: Colors.grey[700],
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'All requests have been processed',
            style: TextStyle(
              fontSize: 14,
              color: Colors.grey[500],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildRequestCard(Admin request, BuildContext context) {
    const tealGreen = Color(0xFF81CF01);
    Color statusColor;
    Color statusBgColor;
    IconData statusIcon;

    switch (request.status) {
      case 'pending':
        statusColor = Colors.orange;
        statusBgColor = Colors.orange.withOpacity(0.1);
        statusIcon = Icons.pending_actions;
        break;
      case 'approved':
      case 'active':
        statusColor = Colors.green;
        statusBgColor = Colors.green.withOpacity(0.1);
        statusIcon = Icons.check_circle;
        break;
      default:
        statusColor = Colors.red;
        statusBgColor = Colors.red.withOpacity(0.1);
        statusIcon = Icons.cancel;
    }

    return Container(
                  margin: const EdgeInsets.only(bottom: 16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, 2),
          ),
        ],
      ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
          // Header with status
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: statusBgColor,
              borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(16),
                topRight: Radius.circular(16),
              ),
            ),
            child: Row(
                          children: [
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: statusColor.withOpacity(0.2),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Icon(statusIcon, color: statusColor, size: 20),
                ),
                const SizedBox(width: 12),
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(
                                    request.fullName,
                                    style: const TextStyle(
                                      fontSize: 18,
                                      fontWeight: FontWeight.bold,
                          color: Color(0xFF1A237E),
                                    ),
                                  ),
                                  const SizedBox(height: 4),
                      Row(
                        children: [
                          Icon(Icons.phone, size: 14, color: Colors.grey[600]),
                          const SizedBox(width: 4),
                                  Text(
                            request.mobile,
                            style: TextStyle(
                              fontSize: 14,
                              color: Colors.grey[700],
                            ),
                          ),
                        ],
                                  ),
                                ],
                              ),
                            ),
                            Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                              decoration: BoxDecoration(
                    color: statusColor,
                    borderRadius: BorderRadius.circular(20),
                              ),
                              child: Text(
                                request.status.toUpperCase(),
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 11,
                                  fontWeight: FontWeight.bold,
                      letterSpacing: 0.5,
                                ),
                              ),
                            ),
                          ],
            ),
          ),
          // Content
          Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildInfoRow(Icons.location_on, '${request.country} > ${request.governorate} > ${request.city}'),
                const SizedBox(height: 8),
                _buildInfoRow(Icons.place, 'Distribution Point: ${request.distributionPoint}'),
                if (request.distributionPointDescription != null) ...[
                  const SizedBox(height: 8),
                  _buildInfoRow(Icons.description, 'Description: ${request.distributionPointDescription}'),
                ],
                if (request.reference != null) ...[
                  const SizedBox(height: 8),
                  _buildInfoRow(Icons.link, 'Reference: ${request.reference}'),
                ],
                const SizedBox(height: 12),
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.grey[50],
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Icon(Icons.note, size: 16, color: Colors.grey[600]),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          request.notes,
                          style: TextStyle(
                            fontSize: 14,
                            color: Colors.grey[700],
                            height: 1.4,
                          ),
                        ),
                      ),
                    ],
                  ),
                        ),
                        // Only show action buttons for pending requests
                        if (request.status == 'pending') ...[
                          const SizedBox(height: 16),
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                    decoration: BoxDecoration(
                      color: Colors.grey[50],
                      borderRadius: const BorderRadius.only(
                        bottomLeft: Radius.circular(16),
                        bottomRight: Radius.circular(16),
                      ),
                    ),
                    child: Row(
                            mainAxisAlignment: MainAxisAlignment.end,
                            children: [
                        Expanded(
                          child: OutlinedButton.icon(
                                onPressed: () {
                                  // Capture parent context before showing dialog
                                  final parentContext = context;
                                  
                                showDialog(
                                  context: context,
                                    builder: (dialogContext) => AlertDialog(
                                    title: const Text('Reject Request'),
                                    content: const Text('Are you sure you want to reject this admin request?'),
                                    actions: [
                                      TextButton(
                                          onPressed: () => Navigator.pop(dialogContext),
                                        child: Text(AppLanguage.translate('Cancel')),
                                      ),
                                      TextButton(
                                        onPressed: () async {
                                            // Close confirmation dialog first
                                            Navigator.pop(dialogContext);
                                            
                                            if (!parentContext.mounted) return;
                                            
                                            // Get root navigator before showing dialog
                                            final rootNavigator = Navigator.of(parentContext, rootNavigator: true);
                                            
                                            // Show loading dialog using root navigator
                                          showDialog(
                                              context: parentContext,
                                            barrierDismissible: false,
                                              builder: (_) => const Center(child: CircularProgressIndicator()),
                                          );
                                          
                                          try {
                                            await AdminRequestService.rejectRequest(request.id);
                                              
                                              // Close loading dialog using root navigator
                                              if (rootNavigator.canPop()) {
                                                rootNavigator.pop();
                                              }
                                              
                                              // Call callback after closing loading dialog
                                            widget.onRequestRejected(request.id);
                                            
                                              // Show success message
                                              if (parentContext.mounted) {
                                                ScaffoldMessenger.of(parentContext).showSnackBar(
                                                const SnackBar(
                                                  content: Text('Request rejected'),
                                                  backgroundColor: Colors.green,
                                                ),
                                              );
                                            }
                                          } catch (e) {
                                              // Close loading on error
                                              if (rootNavigator.canPop()) {
                                                rootNavigator.pop();
                                              }
                                              
                                              // Show error message
                                              if (parentContext.mounted) {
                                                ScaffoldMessenger.of(parentContext).showSnackBar(
                                                SnackBar(
                                                  content: Text('Error rejecting request: $e'),
                                                  backgroundColor: Colors.red,
                                                ),
                                              );
                                            }
                                          }
                                        },
                                        child: const Text('Reject', style: TextStyle(color: Colors.red)),
                                      ),
                                    ],
                                  ),
                                );
                              },
                              icon: const Icon(Icons.close, size: 18),
                              label: const Text('Reject'),
                              style: OutlinedButton.styleFrom(
                                foregroundColor: Colors.red,
                                side: const BorderSide(color: Colors.red),
                                padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(8),
                                ),
                              ),
                            ),
                        ),
                        const SizedBox(width: 12),
                        Expanded(
                              child: ElevatedButton.icon(
                              onPressed: () async {
                                // Capture context before showing loading
                                final parentContext = context;
                                
                                // Show loading dialog
                                showDialog(
                                  context: context,
                                  barrierDismissible: false,
                                  builder: (context) => const Center(child: CircularProgressIndicator()),
                                );
                                
                                try {
                                  // Approve request (creates admin in Firestore)
                                  await AdminRequestService.approveRequest(request.id, 'Q_Admin');
                                  
                                  // Close loading dialog before callback that triggers setState
                                  if (parentContext.mounted) {
                                    final navigator = Navigator.of(parentContext, rootNavigator: true);
                                    if (navigator.canPop()) {
                                      navigator.pop();
                                    }
                                  }
                                  
                                  // Get the created admin
                                  final approvedAdmin = request.copyWith(status: 'active', role: 'Q_Admin');
                                  widget.onRequestApproved(approvedAdmin);
                                  
                                  if (parentContext.mounted) {
                                    ScaffoldMessenger.of(parentContext).showSnackBar(
                                      const SnackBar(
                                        content: Text('Admin request approved'),
                                        backgroundColor: Colors.green,
                                      ),
                                    );
                                  }
                                } catch (e) {
                                  // Close loading on error
                                  if (parentContext.mounted) {
                                    final navigator = Navigator.of(parentContext, rootNavigator: true);
                                    if (navigator.canPop()) {
                                      navigator.pop();
                                    }
                                  }
                                  
                                  if (parentContext.mounted) {
                                    ScaffoldMessenger.of(parentContext).showSnackBar(
                                      SnackBar(
                                        content: Text('Error approving request: $e'),
                                        backgroundColor: Colors.red,
                                      ),
                                    );
                                  }
                                }
                              },
                              icon: const Icon(Icons.check, size: 18),
                              label: const Text('Approve'),
                              style: ElevatedButton.styleFrom(
                                backgroundColor: tealGreen,
                                foregroundColor: Colors.white,
                                padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(8),
                              ),
                                elevation: 2,
                              ),
                            ),
                            ),
                            ],
                        ),
                          ),
                        ],
                      ],
                    ),
                  ),
        ],
      ),
    );
  }

  Widget _buildInfoRow(IconData icon, String text) {
    return Row(
      children: [
        Icon(icon, size: 16, color: Colors.grey[600]),
        const SizedBox(width: 8),
        Expanded(
          child: Text(
            text,
            style: TextStyle(
              fontSize: 14,
              color: Colors.grey[700],
            ),
          ),
        ),
      ],
    );
  }
}

// Profile Screen
class ProfileScreen extends StatefulWidget {
  const ProfileScreen({super.key});

  @override
  State<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends State<ProfileScreen> {
  final _oldPasswordController = TextEditingController();
  final _newPasswordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  bool _isChangingPassword = false;
  bool _oldPasswordVisible = false;
  bool _newPasswordVisible = false;
  bool _confirmPasswordVisible = false;

  @override
  void dispose() {
    _oldPasswordController.dispose();
    _newPasswordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  void _showLanguageDialog() {
    final currentLanguage = AppLanguage.currentLanguage;
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(AppLanguage.translate('Select Language')),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              title: Text(AppLanguage.translate('English')),
              leading: Radio<String>(
                value: 'English',
                groupValue: currentLanguage,
                onChanged: (value) {
                  if (value != null) {
                    AppLanguage.setLanguage(value);
                    Navigator.pop(context);
                  }
                },
              ),
              onTap: () {
                AppLanguage.setLanguage('English');
                Navigator.pop(context);
              },
            ),
            ListTile(
              title: Text(AppLanguage.translate('Arabic')),
              leading: Radio<String>(
                value: 'Arabic',
                groupValue: currentLanguage,
                onChanged: (value) {
                  if (value != null) {
                    AppLanguage.setLanguage(value);
                    Navigator.pop(context);
                  }
                },
              ),
              onTap: () {
                AppLanguage.setLanguage('Arabic');
                Navigator.pop(context);
              },
          ),
          ],
        ),
      ),
    );
  }

  Future<void> _showChangePasswordDialog() async {
    _oldPasswordController.clear();
    _newPasswordController.clear();
    _confirmPasswordController.clear();
    _isChangingPassword = false;
    _oldPasswordVisible = false;
    _newPasswordVisible = false;
    _confirmPasswordVisible = false;

    await showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setDialogState) => AlertDialog(
          title: Text(AppLanguage.translate('Change Password')),
          content: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                TextField(
                  controller: _oldPasswordController,
                  obscureText: !_oldPasswordVisible,
                  decoration: InputDecoration(
                    labelText: AppLanguage.translate('Current Password'),
                    border: const OutlineInputBorder(),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _oldPasswordVisible ? Icons.visibility : Icons.visibility_off,
                      ),
                      onPressed: () {
                        setDialogState(() {
                          _oldPasswordVisible = !_oldPasswordVisible;
                        });
                      },
                    ),
                  ),
                ),
                const SizedBox(height: 16),
                TextField(
                  controller: _newPasswordController,
                  obscureText: !_newPasswordVisible,
                  decoration: InputDecoration(
                    labelText: AppLanguage.translate('New Password'),
                    border: const OutlineInputBorder(),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _newPasswordVisible ? Icons.visibility : Icons.visibility_off,
                      ),
                      onPressed: () {
                        setDialogState(() {
                          _newPasswordVisible = !_newPasswordVisible;
                        });
                      },
                    ),
                  ),
                ),
                const SizedBox(height: 16),
                TextField(
                  controller: _confirmPasswordController,
                  obscureText: !_confirmPasswordVisible,
                  decoration: InputDecoration(
                    labelText: AppLanguage.translate('Confirm New Password'),
                    border: const OutlineInputBorder(),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _confirmPasswordVisible ? Icons.visibility : Icons.visibility_off,
                      ),
                      onPressed: () {
                        setDialogState(() {
                          _confirmPasswordVisible = !_confirmPasswordVisible;
                        });
                      },
                    ),
                  ),
                ),
                if (_isChangingPassword) ...[
                  const SizedBox(height: 16),
                  const CircularProgressIndicator(),
                ],
              ],
            ),
          ),
          actions: [
            TextButton(
              onPressed: _isChangingPassword
                  ? null
                  : () => Navigator.pop(context),
              child: Text(AppLanguage.translate('Cancel')),
            ),
            ElevatedButton(
              onPressed: _isChangingPassword
                  ? null
                  : () async {
                    if (_oldPasswordController.text.isEmpty ||
                        _newPasswordController.text.isEmpty ||
                        _confirmPasswordController.text.isEmpty) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text(AppLanguage.translate('Please fill all fields')),
                          backgroundColor: Colors.red,
                        ),
                      );
                      return;
                    }

                    if (_newPasswordController.text != _confirmPasswordController.text) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text(AppLanguage.translate('New passwords do not match')),
                          backgroundColor: Colors.red,
                        ),
                      );
                      return;
                    }

                    final currentAdmin = AdminService.currentAdmin;
                    if (currentAdmin == null) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text(AppLanguage.translate('User not found')),
                          backgroundColor: Colors.red,
                        ),
                      );
                      return;
                    }

                    // Verify old password
                    final admin = await AdminService.authenticateAdmin(
                      currentAdmin.mobile,
                      _oldPasswordController.text,
                    );

                    if (admin == null) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text(AppLanguage.translate('Current password is incorrect')),
                          backgroundColor: Colors.red,
                        ),
                      );
                      return;
                    }

                    setDialogState(() {
                      _isChangingPassword = true;
                    });

                    try {
                      // Update password in Firebase
                      await AdminService.updateAdminPassword(
                        currentAdmin.id,
                        _newPasswordController.text,
                      );

                      if (context.mounted) {
                        Navigator.pop(context);
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                            content: Text(AppLanguage.translate('Password changed successfully')),
                            backgroundColor: Colors.green,
                          ),
                        );
                      }
                    } catch (e) {
                      if (context.mounted) {
                        setDialogState(() {
                          _isChangingPassword = false;
                        });
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                            content: Text('${AppLanguage.translate('Error changing password:')} $e'),
                            backgroundColor: Colors.red,
                          ),
                        );
                      }
                    }
                  },
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF81CF01),
                foregroundColor: Colors.white,
              ),
              child: Text(AppLanguage.translate('Change Password')),
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    const darkBlue = Color(0xFF1A237E);
    const tealGreen = Color(0xFF81CF01);

    final currentAdmin = AdminService.currentAdmin;
    final userName = currentAdmin?.fullName ?? 'Admin User';
    final userRole = currentAdmin?.role ?? 'Admin';
    final userMobile = currentAdmin?.mobile ?? 'N/A';

    // Format role for display
    String roleDisplay = userRole;
    if (userRole == 'Super_Admin') {
      roleDisplay = 'Super Admin';
    } else if (userRole == 'Q_Admin') {
      roleDisplay = 'Q Admin';
    }

    return Scaffold(
      appBar: AppBar(
        title: Text(AppLanguage.translate('Profile')),
        backgroundColor: tealGreen,
        foregroundColor: Colors.white,
      ),
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Color(0xFFE8F5E9), Colors.white],
          ),
        ),
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(20.0),
          child: Column(
            children: [
              // User Info Section at Top
              Container(
                padding: const EdgeInsets.all(24.0),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(16),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.grey.withOpacity(0.1),
                      spreadRadius: 2,
                      blurRadius: 8,
                      offset: const Offset(0, 2),
                    ),
                  ],
                ),
          child: Column(
            children: [
              const CircleAvatar(
                radius: 50,
                backgroundColor: tealGreen,
                child: Icon(Icons.person, size: 50, color: Colors.white),
              ),
              const SizedBox(height: 16),
                    Text(
                      userName,
                      style: const TextStyle(
                  fontSize: 24,
                  fontWeight: FontWeight.bold,
                  color: darkBlue,
                ),
              ),
              const SizedBox(height: 8),
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                      decoration: BoxDecoration(
                        color: tealGreen.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(20),
                      ),
                      child: Text(
                        roleDisplay,
                        style: const TextStyle(
                  fontSize: 16,
                          color: tealGreen,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                    const SizedBox(height: 24),
                    _buildProfileItem(Icons.phone, 'Mobile', userMobile),
                  ],
                ),
              ),
              const SizedBox(height: 32),
              const Divider(),
              const SizedBox(height: 16),
              _buildSettingItem(Icons.lock, 'Change Password', _showChangePasswordDialog),
              _buildSettingItem(Icons.language, 'Language', _showLanguageDialog),
              _buildSettingItem(Icons.help, 'Help & Support', () {
                Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (context) => const HelpSupportScreen(),
                  ),
                );
              }),
              const SizedBox(height: 32),
              ElevatedButton(
                onPressed: () {
                  showDialog(
                    context: context,
                    builder: (context) => AlertDialog(
                      title: Text(AppLanguage.translate('Logout')),
                      content: Text(AppLanguage.translate('Are you sure you want to logout?')),
                      actions: [
                        TextButton(
                          onPressed: () => Navigator.pop(context),
                          child: Text(AppLanguage.translate('Cancel')),
                        ),
                        TextButton(
                          onPressed: () {
                            AdminService.clearCurrentAdmin();
                            Navigator.of(context).pushAndRemoveUntil(
                              MaterialPageRoute(builder: (context) => const LoginScreen()),
                              (route) => false,
                            );
                          },
                          child: Text(AppLanguage.translate('Logout'), style: const TextStyle(color: Colors.red)),
                        ),
                      ],
                    ),
                  );
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.red,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 16),
                ),
                child: const Text('Logout'),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildProfileItem(IconData icon, String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 12.0),
      child: Row(
        children: [
          Icon(icon, color: const Color(0xFF81CF01)),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
            Text(
                  label,
                  style: const TextStyle(
                    fontSize: 12,
                    color: Colors.grey,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  value,
                  style: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                    color: Color(0xFF1A237E),
                  ),
            ),
          ],
        ),
      ),
        ],
      ),
    );
  }

  Widget _buildSettingItem(IconData icon, String title, VoidCallback onTap) {
    return InkWell(
      onTap: onTap,
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 12.0),
        child: Row(
          children: [
            Icon(icon, color: const Color(0xFF81CF01), size: 24),
            const SizedBox(width: 16),
            Expanded(
              child: Text(
                title,
                style: const TextStyle(
                  fontSize: 16,
                  color: Color(0xFF1A237E),
                ),
              ),
            ),
            Icon(
              AppLanguage.isArabic ? Icons.arrow_back_ios : Icons.arrow_forward_ios,
              size: 16,
              color: Colors.grey,
            ),
          ],
        ),
      ),
    );
  }
}

// Beneficiary Registration Screen
class BeneficiaryRegistrationScreen extends StatefulWidget {
  final List<Queue> queues;
  final List<Beneficiary> beneficiaries;
  final List<DistributionArea> distributionAreas;
  final List<String> entities;
  final Function(Beneficiary) onBeneficiaryCreated;
  final Function(String) onEntityAdded;

  const BeneficiaryRegistrationScreen({
    super.key,
    required this.queues,
    required this.beneficiaries,
    required this.distributionAreas,
    required this.entities,
    required this.onBeneficiaryCreated,
    required this.onEntityAdded,
  });

  @override
  State<BeneficiaryRegistrationScreen> createState() => _BeneficiaryRegistrationScreenState();
}

class _BeneficiaryRegistrationScreenState extends State<BeneficiaryRegistrationScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _idNumberController = TextEditingController();
  final _mobileNumberController = TextEditingController();
  final _nfcCodeController = TextEditingController();
  final _customEntityController = TextEditingController();
  final _customUnitsController = TextEditingController();
  
  // FocusNodes for keyboard navigation
  final _nameFocusNode = FocusNode();
  final _idNumberFocusNode = FocusNode();
  final _mobileNumberFocusNode = FocusNode();
  final _customUnitsFocusNode = FocusNode();
  final _customEntityFocusNode = FocusNode();
  final _nfcCodeFocusNode = FocusNode();

  String? _selectedDistributionArea;
  String? _selectedQueuePoint; // Not used in registration, kept for compatibility
  String _type = 'Normal';
  String _gender = 'Male';
  String _status = 'Active';
  String _numberOfUnits = '1';
  bool _isEntity = false;
  String? _selectedEntity;
  bool _useCustomUnits = false;
  bool _useCustomEntity = false;
  String? _idCopyPath;
  String? _photoPath;
  DateTime? _extractedBirthDate;
  String? _duplicateIDMessage;
  String? _duplicateMobileMessage; // Track duplicate mobile number message
  String? _duplicateNFCMessage; // Track duplicate NFC tag ID message
  bool _nfcDetected = false; // Track if NFC tag was detected
  String? _originalNfcTagId; // Store original NFC tag ID for saving (not masked)

  final List<String> _typeOptions = ['Normal', 'Child', 'Widowed', 'Divorced', 'Disability', 'Sick', 'Elderly'];
  final List<String> _genderOptions = ['Male', 'Female'];
  final List<String> _statusOptions = ['Active', 'Banned'];
  final List<String> _unitsOptions = ['1', '2'];

  List<Queue> get _filteredQueues {
    if (_selectedDistributionArea == null) return [];
    // Filter queues by queue point ID
    return widget.queues.where((q) => q.distributionArea == _selectedDistributionArea).toList();
  }

  @override
  void initState() {
    super.initState();
    // Auto-start NFC detection when screen loads
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _startNFCDetection();
    });
  }

  @override
  void dispose() {
    // Stop NFC session if active
    NFCHelper.stopNFCSession();
    _nameController.dispose();
    _idNumberController.dispose();
    _mobileNumberController.dispose();
    _nfcCodeController.dispose();
    _customEntityController.dispose();
    _customUnitsController.dispose();
    // Dispose FocusNodes
    _nameFocusNode.dispose();
    _idNumberFocusNode.dispose();
    _mobileNumberFocusNode.dispose();
    _customUnitsFocusNode.dispose();
    _customEntityFocusNode.dispose();
    _nfcCodeFocusNode.dispose();
    super.dispose();
  }

  void _startNFCDetection() async {
    if (kIsWeb) return;
    
    try {
      // Check if NFC is available
      final isAvailable = await NFCHelper.isNFCAvailable();
      if (!isAvailable) {
        return;
      }

      // Start NFC session - auto-detect when card is tapped
      NFCHelper.startNFCSession(
        context: context,
        onTagDetected: (id) {
          if (mounted) {
            setState(() {
              // Display masked NFC tag ID, but we need to store original for saving
              // Store original ID in controller's value (we'll extract it when saving)
              // For now, display masked version
              _nfcCodeController.text = NFCHelper.maskNfcTagId(id);
              _nfcDetected = true; // Mark as detected
              // Store original ID in a hidden way - we'll use the original 'id' when saving
              // The masked value is only for display
            });
          }
        },
        onError: (error) {
          // Silently handle errors for auto-detection
          print('NFC auto-detection error: $error');
        },
      );
    } catch (e) {
      print('Error starting NFC detection: $e');
    }
  }

  /// Crop image to focus on ID card
  Future<CroppedFile?> _cropImage(String imagePath) async {
    try {
      final croppedFile = await ImageCropper().cropImage(
        sourcePath: imagePath,
        aspectRatio: const CropAspectRatio(ratioX: 1.6, ratioY: 1.0), // ID card aspect ratio (approximately)
        uiSettings: [
          AndroidUiSettings(
            toolbarTitle: AppLanguage.translate('Crop ID Card'),
            toolbarColor: const Color(0xFF1A237E),
            toolbarWidgetColor: Colors.white,
            initAspectRatio: CropAspectRatioPreset.original,
            lockAspectRatio: false, // Allow free-form cropping
            aspectRatioPresets: [
              CropAspectRatioPreset.original,
              CropAspectRatioPreset.ratio16x9,
              CropAspectRatioPreset.ratio4x3,
            ],
            backgroundColor: Colors.black,
            activeControlsWidgetColor: const Color(0xFF1A237E),
            dimmedLayerColor: Colors.black.withOpacity(0.8),
            cropFrameColor: Colors.white,
            cropGridColor: Colors.white.withOpacity(0.5),
            cropFrameStrokeWidth: 2,
            cropGridStrokeWidth: 1,
            showCropGrid: true,
            hideBottomControls: false,
          ),
          IOSUiSettings(
            title: AppLanguage.translate('Crop ID Card'),
            aspectRatioLockEnabled: false,
            resetAspectRatioEnabled: true,
            aspectRatioPresets: [
              CropAspectRatioPreset.original,
              CropAspectRatioPreset.square,
              CropAspectRatioPreset.ratio16x9,
            ],
            rotateButtonsHidden: false,
            rotateClockwiseButtonHidden: false,
            hidesNavigationBar: false,
            showCancelConfirmationDialog: true,
          ),
        ],
      );
      return croppedFile;
    } catch (e) {
      print('Error cropping image: $e');
      return null;
    }
  }

  Future<void> _scanID() async {
    try {
      // Show dialog to choose image source (camera or gallery)
      final source = await showDialog<ImageSource>(
        context: context,
        builder: (context) => AlertDialog(
          title: Text(AppLanguage.translate('Select Image Source')),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ListTile(
                leading: const Icon(Icons.camera_alt),
                title: Text(AppLanguage.translate('Camera')),
                onTap: () => Navigator.pop(context, ImageSource.camera),
              ),
              ListTile(
                leading: const Icon(Icons.photo_library),
                title: Text(AppLanguage.translate('Gallery')),
                onTap: () => Navigator.pop(context, ImageSource.gallery),
              ),
            ],
          ),
        ),
      );

      if (source == null) return;

      // Request permissions based on source
      bool hasPermission = false;
      if (source == ImageSource.camera) {
        hasPermission = await PermissionHelper.requestCameraPermission();
      if (!hasPermission) {
        if (context.mounted) {
          await PermissionHelper.showPermissionDeniedDialog(
            context,
            AppLanguage.translate('Camera permission is required. Please enable it in app settings.'),
          );
        }
        return;
        }
      } else {
        // For gallery, request storage permission
        hasPermission = await PermissionHelper.requestStoragePermission();
        if (!hasPermission) {
          if (context.mounted) {
            await PermissionHelper.showPermissionDeniedDialog(
              context,
              AppLanguage.translate('Storage permission is required to select images from gallery.'),
            );
          }
          return;
        }
      }

      // Show loading dialog
      if (context.mounted) {
        showDialog(
          context: context,
          barrierDismissible: false,
          builder: (context) => const Center(
            child: CircularProgressIndicator(),
          ),
        );
      }

      // Get image from selected source
      final image_picker.ImagePicker picker = image_picker.ImagePicker();
      final image_picker.XFile? image = await picker.pickImage(
        source: source == ImageSource.camera 
            ? image_picker.ImageSource.camera 
            : image_picker.ImageSource.gallery,
        imageQuality: 90,
      );

      if (image == null) {
        if (context.mounted) {
          Navigator.of(context).pop(); // Close loading dialog
        }
        return;
      }

      // Close loading dialog before showing crop screen
      if (context.mounted) {
        Navigator.of(context).pop();
      }

      // Show image cropping screen to allow user to focus on ID card
      final croppedFile = await _cropImage(image.path);
      if (croppedFile == null) {
        // User cancelled cropping
        return;
      }

      // Save the cropped image path
      setState(() {
        _idCopyPath = croppedFile.path;
      });

      // Validate image quality first (use cropped image)
      final qualityResult = await ImageQualityValidator.validateImageQuality(croppedFile.path);
      print('📸 Image Quality Check:');
      print('  Valid: ${qualityResult['isValid']}');
      print('  Score: ${qualityResult['score']}');
      print('  Issues: ${qualityResult['issues']}');
      
      // Only block if quality is very poor (score < 0.3)
      // Otherwise, just show a warning but continue with OCR
      final qualityScore = qualityResult['score'] as double;
      if (qualityScore < 0.3) {
        if (context.mounted) {
          Navigator.of(context).pop(); // Close loading dialog
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('⚠️ ${AppLanguage.translate("Image quality is very low. Please ensure good lighting and focus.")}\n${(qualityResult['recommendations'] as List).join(", ")}'),
              backgroundColor: Colors.orange,
              duration: const Duration(seconds: 5),
            ),
          );
        }
        return;
      } else if (qualityScore < 0.6 && qualityResult['issues'] != null && (qualityResult['issues'] as List).isNotEmpty) {
        // Show warning but continue - don't block OCR for moderate quality issues
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('ℹ️ ${AppLanguage.translate("Image quality could be better, but proceeding with OCR.")}\n${(qualityResult['recommendations'] as List).take(2).join(", ")}'),
              backgroundColor: Colors.blue,
              duration: const Duration(seconds: 3),
            ),
          );
        }
      }

      // Preprocess image using Python solution approach (threshold at 95 like front.py)
      // Based on: https://github.com/OlaHamdy3/National-ID-card-reader
      String? processedImagePath = await ImageQualityValidator.preprocessImage(
        croppedFile.path, 
        useThresholding: true, 
        threshold: 95  // Python solution uses thresh = 95 for front
      );
      
      // Also try region-based extraction (like Python solution)
      final regions = await ImageQualityValidator.extractRegionsFromImage(croppedFile.path);
      print('🖼️ Extracted ${regions.length} regions: ${regions.keys.join(", ")}');

      // Perform OCR using region-based approach (like Python solution)
      String combinedText = '';
      Map<String, String> ocrResults = {}; // Store results from different approaches
      
      // Strategy 1: Region-based OCR (like Python solution - most accurate)
      if (regions.isNotEmpty) {
        print('🔍 Strategy 1: Starting region-based OCR with ${regions.length} regions');
        try {
          final ocr = FlutterNativeOcr();
          
          // Extract name from name region (like Python: image_to_string(Name, lang="ara"))
          if (regions.containsKey('nameRegion')) {
            print('🔍 Processing name region: ${regions['nameRegion']}');
            try {
              final nameText = await ocr.recognizeText(regions['nameRegion']!);
              if (nameText.isNotEmpty) {
                ocrResults['name'] = nameText;
                combinedText = '${combinedText}${nameText}\n';
                print('📝 Name Region OCR: $nameText (${nameText.length} chars)');
              } else {
                print('⚠️ Name Region OCR returned empty text');
              }
            } catch (e) {
              print('❌ Error processing name region: $e');
            }
          }
          
          // Extract address from address region (like Python: image_to_string(address, lang="ara"))
          if (regions.containsKey('addressRegion')) {
            print('🔍 Processing address region: ${regions['addressRegion']}');
            try {
              final addressText = await ocr.recognizeText(regions['addressRegion']!);
              if (addressText.isNotEmpty) {
                ocrResults['address'] = addressText;
                combinedText = '${combinedText}${addressText}\n';
                print('📝 Address Region OCR: $addressText (${addressText.length} chars)');
              } else {
                print('⚠️ Address Region OCR returned empty text');
              }
            } catch (e) {
              print('❌ Error processing address region: $e');
            }
          }
          
          // Extract ID from ID region (like Python: image_to_string(ID, lang="hin"))
          // Try both thresholded and adaptive threshold versions for better results
          if (regions.containsKey('idRegion')) {
            print('🔍 Processing ID region (thresholded): ${regions['idRegion']}');
            try {
              final idText = await ocr.recognizeText(regions['idRegion']!);
              if (idText.isNotEmpty) {
                ocrResults['id'] = idText;
                combinedText = '${combinedText}${idText}\n';
                print('📝 ID Region OCR (thresholded): $idText (${idText.length} chars)');
              } else {
                print('⚠️ ID Region OCR (thresholded) returned empty text');
              }
            } catch (e) {
              print('❌ Error processing ID region (thresholded): $e');
            }
          }
          
          // Also try adaptive threshold version if available (often better for numbers)
          if (regions.containsKey('idRegionAdaptive')) {
            print('🔍 Processing ID region (adaptive): ${regions['idRegionAdaptive']}');
            try {
              final idTextAdaptive = await ocr.recognizeText(regions['idRegionAdaptive']!);
              if (idTextAdaptive.isNotEmpty) {
                // Prefer adaptive if it has more digits or is longer
                final currentId = ocrResults['id'] ?? '';
                print('🔍 Comparing ID results: thresholded="$currentId" (${currentId.length} chars, ${RegExp(r'\d').allMatches(currentId).length} digits) vs adaptive="$idTextAdaptive" (${idTextAdaptive.length} chars, ${RegExp(r'\d').allMatches(idTextAdaptive).length} digits)');
                if (idTextAdaptive.length > currentId.length || 
                    RegExp(r'\d').allMatches(idTextAdaptive).length > RegExp(r'\d').allMatches(currentId).length) {
                  ocrResults['id'] = idTextAdaptive;
                  // Update combined text if this is better
                  if (currentId.isNotEmpty) {
                    combinedText = combinedText.replaceAll(currentId, idTextAdaptive);
                  } else {
                    combinedText = '${combinedText}${idTextAdaptive}\n';
                  }
                  print('📝 ID Region OCR (adaptive, better): $idTextAdaptive');
                } else {
                  print('📝 ID Region OCR (adaptive): $idTextAdaptive (keeping thresholded version)');
                }
              } else {
                print('⚠️ ID Region OCR (adaptive) returned empty text');
              }
            } catch (e) {
              print('❌ Error processing ID region (adaptive): $e');
            }
          }
          
          print('🔍 Strategy 1 complete. Combined text length: ${combinedText.length}');
        } catch (e, stackTrace) {
          print('❌ Region-based OCR Error: $e');
          print('Stack trace: $stackTrace');
        }
      } else {
        print('⚠️ No regions extracted - skipping region-based OCR');
      }
      
      // Strategy 2: Full image OCR with thresholded image (Python solution approach)
      if (processedImagePath != null) {
        try {
          final ocr = FlutterNativeOcr();
          final fullText = await ocr.recognizeText(processedImagePath);
          if (fullText.isNotEmpty) {
            ocrResults['full'] = fullText;
            // Combine with region results
            if (combinedText.isEmpty || fullText.length > combinedText.length * 1.5) {
              combinedText = fullText;
              print('📝 Using full image OCR (${fullText.length} chars)');
            } else {
              // Merge unique content
              final fullLines = fullText.split('\n');
              for (final line in fullLines) {
                if (line.trim().isNotEmpty && !combinedText.contains(line.trim())) {
                  combinedText = '$combinedText\n${line.trim()}';
                }
              }
            }
          }
        } catch (e) {
          print('❌ Full Image OCR Error: $e');
        }
      }
      
      // Strategy 3: Original image OCR (fallback if region extraction failed)
      if (combinedText.isEmpty || !RegExp(r'[أ-ي]').hasMatch(combinedText)) {
        try {
          final ocr = FlutterNativeOcr();
          final originalText = await ocr.recognizeText(croppedFile.path);
          if (originalText.isNotEmpty) {
            final originalHasArabic = RegExp(r'[أ-ي]').hasMatch(originalText);
            if (originalHasArabic && (combinedText.isEmpty || !RegExp(r'[أ-ي]').hasMatch(combinedText))) {
              combinedText = originalText;
              print('📝 Using original image OCR (better Arabic detection)');
            } else if (combinedText.isEmpty) {
              combinedText = originalText;
            }
            print('📝 Original Image OCR Text Length: ${originalText.length}');
          }
        } catch (e) {
          print('❌ Original Image OCR Error: $e');
        }
      }
      
      // Check if OCR text is too short or doesn't contain meaningful content
      final trimmedText = combinedText.trim();
      print('🔍 Final combined text length: ${trimmedText.length}');
      print('🔍 Final combined text (first 200 chars): ${trimmedText.substring(0, trimmedText.length > 200 ? 200 : trimmedText.length)}');
      
      if (trimmedText.length < 10) {
        print('❌ OCR text too short (${trimmedText.length} chars) - blocking processing');
        if (mounted && context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('⚠️ ${AppLanguage.translate("OCR failed to detect text. Please ensure:")}\n• Good lighting\n• Card is flat and in focus\n• No glare or shadows\n• Card fills most of the frame'),
              backgroundColor: Colors.orange,
              duration: const Duration(seconds: 6),
            ),
          );
        }
        return;
      }
      
      // Check if OCR text contains Arabic characters or numbers (ID numbers are important even without Arabic)
      final hasArabic = RegExp(r'[أ-ي]').hasMatch(trimmedText);
      final hasLongNumbers = RegExp(r'\d{8,}').hasMatch(trimmedText); // Check for sequences of 8+ digits (could be ID)
      final hasAnyNumbers = RegExp(r'\d').hasMatch(trimmedText); // Check for any digits
      
      print('🔍 Text analysis: Arabic=$hasArabic, LongNumbers=$hasLongNumbers, AnyNumbers=$hasAnyNumbers, Length=${trimmedText.length}');
      
      // Even if text is short, try to extract ID if it has numbers
      // Don't block processing if we have any numbers - they might be part of the ID
      if (!hasArabic && !hasLongNumbers && !hasAnyNumbers && trimmedText.length < 50) {
        // If no Arabic and no numbers at all and text is very short, likely OCR failed
        print('⚠️ Warning: No Arabic text or numbers detected in OCR result. Text: $trimmedText');
        if (mounted && context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('⚠️ ${AppLanguage.translate("OCR did not detect Arabic text. The image may be blurry or the card may not be fully visible. Please try again with better lighting and focus.")}'),
              backgroundColor: Colors.orange,
              duration: const Duration(seconds: 6),
            ),
          );
        }
        // Still try to parse - might find something
      }
      
      // If we have numbers but no Arabic, still try to extract ID (might be partial OCR)
      if (!hasArabic && (hasLongNumbers || hasAnyNumbers)) {
        print('⚠️ Warning: No Arabic text detected, but found numbers. Attempting ID extraction anyway...');
      }
      
      try {
        // ALWAYS try to parse the extracted text - even if it's short, we might find an ID number
        print('🔍 Calling parseIDText with text length: ${combinedText.length}');
        final parsedData = IDParser.parseIDText(combinedText);
        
        // Debug: Print extracted data
        print('🔍 OCR Extracted Data:');
        print('  Full OCR Text Length: ${combinedText.length}');
        print('  Full OCR Text (first 1000 chars): ${combinedText.substring(0, combinedText.length > 1000 ? 1000 : combinedText.length)}');
        print('  ID Number: ${parsedData['idNumber']}');
        print('  Name: ${parsedData['name']}');
        print('  Birth Date: ${parsedData['birthDate']}');
        print('  Gender: ${parsedData['gender']}');
        print('  Birth Location: ${parsedData['birthLocation']}');
        print('  Confidence: ${parsedData['confidence']}');
        
        // Check if extraction was successful
        final overallConfidence = (parsedData['confidence'] as Map<String, dynamic>)['overall'] as double;
        final hasName = parsedData['name'] != null;
        final hasID = parsedData['idNumber'] != null;
        
        // Show warning if extraction quality is low
        if (overallConfidence < 0.5 || (!hasName && !hasID)) {
          if (mounted && context.mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('⚠️ ${AppLanguage.translate("Low extraction quality. Please verify the extracted data manually.")}\n${hasID ? "✓ ID Number detected" : "✗ ID Number not detected"}\n${hasName ? "✓ Name detected" : "✗ Name not detected"}'),
                backgroundColor: Colors.orange,
                duration: const Duration(seconds: 5),
              ),
            );
          }
        }

        // Auto-fill form fields with extracted data
        if (mounted) {
        setState(() {
          if (parsedData['idNumber'] != null) {
              final idNum = parsedData['idNumber'] as String;
              _idNumberController.text = idNum;
            // Check for duplicate ID
              _checkDuplicateID(idNum);
          }
          
          if (parsedData['name'] != null) {
              final name = parsedData['name'] as String;
              // Additional validation: ensure it's not an alphanumeric code
              if (!RegExp(r'^[A-Z]{1,3}\d{4,}$').hasMatch(name.trim()) && 
                  !RegExp(r'^[A-Z]{2,}\d+$').hasMatch(name.trim()) &&
                  name.length >= 3) {
                _nameController.text = name;
              } else {
                print('⚠️ Skipped invalid name (looks like code): $name');
              }
          }
          
          if (parsedData['birthDate'] != null) {
            _extractedBirthDate = parsedData['birthDate'] as DateTime;
            // Auto-detect Elderly if birth date is before January 1, 1965
            final elderlyThreshold = DateTime(1965, 1, 1);
            if (_extractedBirthDate!.isBefore(elderlyThreshold)) {
              _type = 'Elderly';
            }
          }
          
          if (parsedData['gender'] != null) {
            _gender = parsedData['gender'] as String;
          }
        });
        }

        if (mounted && context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(AppLanguage.translate('ID scanned successfully')),
              backgroundColor: Colors.green,
            ),
          );
        }
      } catch (e) {
        print('Error parsing OCR text: $e');
        if (context.mounted) {
          Navigator.of(context).pop();
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error processing image: ${e.toString()}'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    } catch (e) {
      if (context.mounted) {
        Navigator.of(context).pop(); // Close loading dialog if still open
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error scanning ID: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _extractNameFromID() async {
    if (_idCopyPath == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(AppLanguage.translate('Please scan ID first'))),
      );
      return;
    }
    
    // Simulate OCR extraction
    await Future.delayed(const Duration(milliseconds: 500));
    
    setState(() {
      _nameController.text = 'Extracted Name from ID'; // In real app, this would be OCR result
    });
    
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(AppLanguage.translate('Name extracted from ID'))),
    );
  }

  /// Extract person's name from Google Lens text, filtering out common phrases
  /// Neglects: "جمهورية مصر العربية", "بطاقة تحقيق شخصية", addresses, etc.
  String? _extractPersonNameFromGoogleLensText(String text) {
    print('🔍 Extracting person name from Google Lens text...');
    
    // Phrases to remove/ignore
    final phrasesToRemove = [
      'جمهورية مصر العربية',
      'بطاقة تحقيق شخصية',
      'بطاقة تحقيق',
      'جمهورية مصر',
      'مصر العربية',
      'الجمهورية',
      'مصر',
      'بطاقة',
      'تحقيق',
      'شخصية',
      'Arab Republic of Egypt',
      'Identity Card',
      'National ID',
      'بطاقة وطنية',
      'بطاقة مدنية',
    ];
    
    // Address keywords to help identify and skip address sections
    final addressKeywords = [
      'عنوان',
      'العنوان',
      'محل الإقامة',
      'الإقامة',
      'address',
      'residence',
      'المنوفية',
      'السادات',
      'مركز',
      'محافظة',
      'مدينة',
      'قرية',
      'شارع',
      'طريق',
    ];
    
    // Clean the text - remove unwanted phrases
    String cleanedText = text;
    for (final phrase in phrasesToRemove) {
      cleanedText = cleanedText.replaceAll(RegExp(phrase, caseSensitive: false), '');
    }
    
    // Split into lines
    final lines = cleanedText.split('\n').map((l) => l.trim()).where((l) => l.isNotEmpty).toList();
    
    print('📝 Lines after cleaning: ${lines.length}');
    for (int i = 0; i < lines.length && i < 10; i++) {
      print('  Line $i: ${lines[i]}');
    }
    
    // Find the person's name - can be on 1 or 2 lines
    // First line: first name
    // Second line: rest of name (middle name, last name, etc.)
    // We need to combine them into a full name
    
    List<String> nameLines = [];
    
    for (int i = 0; i < lines.length; i++) {
      final line = lines[i];
      
      // Skip if contains numbers (likely ID or date)
      if (RegExp(r'\d').hasMatch(line)) continue;
      
      // Skip if contains address keywords
      bool isAddress = false;
      for (final keyword in addressKeywords) {
        if (line.contains(keyword)) {
          isAddress = true;
          break;
        }
      }
      if (isAddress) continue;
      
      // Check if line is primarily Arabic text
      final arabicPattern = RegExp(r'^[أ-ي\s]+$');
      if (arabicPattern.hasMatch(line) && line.length >= 3) {
        // Check if this could be part of a name
        final words = line.split(RegExp(r'\s+')).where((w) => w.isNotEmpty).toList();
        
        // If it's a single word or short line, it might be the first name
        // If it's multiple words, it might be the full name or part of it
        if (words.length >= 1 && line.length >= 3) {
          nameLines.add(line);
          print('📝 Found potential name line $i: $line (${words.length} words)');
        }
      }
    }
    
    // Combine consecutive name lines (first name on first line, rest on second line)
    if (nameLines.isNotEmpty) {
      // Try to find 2 consecutive lines that look like a name
      for (int i = 0; i < nameLines.length - 1; i++) {
        final firstLine = nameLines[i];
        final secondLine = nameLines[i + 1];
        
        // Check if both lines are Arabic names (no numbers, no address keywords)
        final firstIsName = RegExp(r'^[أ-ي\s]+$').hasMatch(firstLine) && 
                           !RegExp(r'\d').hasMatch(firstLine) &&
                           firstLine.length >= 3;
        final secondIsName = RegExp(r'^[أ-ي\s]+$').hasMatch(secondLine) && 
                            !RegExp(r'\d').hasMatch(secondLine) &&
                            secondLine.length >= 3;
        
        if (firstIsName && secondIsName) {
          // Combine the two lines
          final fullName = '$firstLine $secondLine'.trim();
          final words = fullName.split(RegExp(r'\s+')).where((w) => w.isNotEmpty).toList();
          
          // Validate: should have at least 2 words total
          if (words.length >= 2) {
            print('✅ Found 2-line name: "$firstLine" + "$secondLine" = "$fullName"');
            return fullName;
          }
        }
      }
      
      // If no 2-line name found, try to find the longest single line name
      String? bestName;
      int maxLength = 0;
      
      for (final line in nameLines) {
        final words = line.split(RegExp(r'\s+')).where((w) => w.isNotEmpty).toList();
        if (words.length >= 2 && line.length > maxLength) {
          bestName = line;
          maxLength = line.length;
        }
      }
      
      if (bestName != null) {
        print('✅ Extracted single-line name: $bestName');
        return bestName;
      }
      
      // Last fallback: use the first name line if it's long enough
      if (nameLines.isNotEmpty) {
        final firstLine = nameLines.first;
        if (firstLine.length >= 5) {
          print('✅ Extracted name (fallback): $firstLine');
          return firstLine;
        }
      }
    }
    
    print('⚠️ Could not extract person name from text');
    return null;
  }

  /// Process text from Live Text Detection (Google Lens-like) screen
  void _processLiveTextDetectionResult(String text) {
    if (text.isEmpty) return;
    
    print('📝 Processing Google Lens text (length: ${text.length})');
    print('📝 Text preview: ${text.substring(0, text.length > 200 ? 200 : text.length)}');
    
    try {
      // Parse the text using IDParser
      final parsedData = IDParser.parseIDText(text);
      
      print('📝 Parsed data keys: ${parsedData.keys.toList()}');
      print('📝 ID Number from parser: ${parsedData['idNumber']}');
      print('📝 Name from parser: ${parsedData['name']}');
      
      // Extract 14-digit ID number
      var idNumber = parsedData['idNumber'] as String?;
      
      // If ID number is not exactly 14 digits, try to extract it directly from text
      if (idNumber == null || idNumber.length != 14) {
        print('⚠️ ID number not found or invalid length (${idNumber?.length ?? 0}). Trying direct extraction...');
        
        // First, convert all Arabic-Indic digits in the full text (including variant forms)
        // This handles both Persian (۰۱۲۳۴۵۶۷۸۹) and Arabic variant (٠١٢٣٤٥٦٧٨٩) digits
        final cleanedText = IDParser.convertArabicIndicToWestern(text);
        print('📝 Text after Arabic-Indic conversion (first 200 chars): ${cleanedText.substring(0, cleanedText.length > 200 ? 200 : cleanedText.length)}');
        
        // Also try to match Arabic-Indic digits directly and convert them
        // Pattern to match sequences that might contain Arabic-Indic digits
        final arabicIndicPattern = RegExp(r'[0-9۰-۹٠-٩]{12,14}');
        final arabicMatch = arabicIndicPattern.firstMatch(text);
        if (arabicMatch != null && arabicMatch.group(0) != null) {
          final rawId = arabicMatch.group(0)!;
          final convertedId = IDParser.convertArabicIndicToWestern(rawId);
          if (convertedId.length >= 12 && convertedId.length <= 14) {
            idNumber = convertedId;
            print('✅ Found ID with Arabic-Indic digits, converted: $idNumber');
          }
        }
        
        // If still not found, try to find 14-digit number in cleaned text directly
        if (idNumber == null || idNumber.length != 14) {
          final directIdMatch = RegExp(r'\d{14}').firstMatch(cleanedText);
          if (directIdMatch != null && directIdMatch.group(0) != null) {
            idNumber = directIdMatch.group(0)!;
            print('✅ Found 14-digit ID directly: $idNumber');
          } else {
            // Try to find numbers with spaces/dashes and clean them
            final spacedIdMatch = RegExp(r'\d{2}[\s-]?\d{2}[\s-]?\d{2}[\s-]?\d{2}[\s-]?\d{2}[\s-]?\d{2}[\s-]?\d{2}').firstMatch(cleanedText);
            if (spacedIdMatch != null && spacedIdMatch.group(0) != null) {
              idNumber = spacedIdMatch.group(0)!.replaceAll(RegExp(r'[^\d]'), '');
              print('✅ Found spaced ID and cleaned: $idNumber');
            } else {
              // Try to find any sequence of 12-14 digits (might be partial due to OCR issues)
              final partialMatch = RegExp(r'\d{12,14}').firstMatch(cleanedText);
              if (partialMatch != null && partialMatch.group(0) != null) {
                final partialId = partialMatch.group(0)!;
                if (partialId.length >= 12) {
                  idNumber = partialId;
                  print('⚠️ Found partial ID (${partialId.length} digits): $idNumber - will try to use if valid');
                }
              }
            }
          }
        }
      }
      
      // Set ID number if found (accept 12-14 digits)
      if (idNumber != null && idNumber.length >= 12) {
        // Create non-nullable variable for use inside
        final validIdNumber = idNumber;
        
        // Validate first digit (should be 2 or 3 for Egyptian IDs)
        final firstDigit = int.tryParse(validIdNumber.substring(0, 1));
        if (firstDigit == 2 || firstDigit == 3) {
          setState(() {
            _idNumberController.text = validIdNumber;
          });
          print('✅ ID Number set: $validIdNumber (${validIdNumber.length} digits)');
          
          // Extract birth date from ID number (only if we have at least 7 digits for date)
          if (validIdNumber.length >= 7) {
            // For partial IDs (less than 14 digits), we can't extract full birth date
            // But we can try if we have enough digits
            if (validIdNumber.length == 14) {
              final birthDate = IDParser.extractBirthDateFromIDNumber(validIdNumber);
              
              // Check if birth date is older than 1-1-1965
              if (birthDate != null) {
                final cutoffDate = DateTime(1965, 1, 1);
                if (birthDate.isBefore(cutoffDate)) {
                  setState(() {
                    _type = 'Elderly';
                  });
                  print('✅ Type set to Elderly (birth date: $birthDate)');
                }
              }
            } else {
              print('⚠️ Partial ID (${validIdNumber.length} digits) - cannot extract birth date');
            }
          }
        } else {
          print('⚠️ Invalid ID number first digit: $firstDigit');
        }
      } else {
        print('⚠️ ID number not found or invalid length: ${idNumber?.length ?? 0}');
      }
      
      // Extract name - improved extraction for Google Lens results
      String? extractedName = _extractPersonNameFromGoogleLensText(text);
      
      // Fallback to parsed data if direct extraction didn't work
      if (extractedName == null || extractedName.isEmpty) {
        extractedName = parsedData['name'] as String?;
      }
      
      if (extractedName != null && extractedName.isNotEmpty) {
        // Clean the name - remove extra whitespace
        extractedName = extractedName.trim().replaceAll(RegExp(r'\s+'), ' ');
        
        // Validate that name is not just numbers or alphanumeric codes
        final namePattern = RegExp(r'^[أ-ي\s]+$|^[A-Za-z\s]+$');
        if (namePattern.hasMatch(extractedName)) {
          setState(() {
            _nameController.text = extractedName!;
          });
          print('✅ Name set: $extractedName');
        } else {
          print('⚠️ Name validation failed: $extractedName');
        }
      } else {
        print('⚠️ Name not found in text');
      }
      
      // Show success message
      if (mounted) {
        final hasId = idNumber != null && idNumber.length >= 12;
        final hasName = extractedName != null && extractedName.isNotEmpty;
        
        if (hasId || hasName) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(AppLanguage.translate('Data extracted from Google Lens and filled automatically')),
              backgroundColor: Colors.green,
              duration: const Duration(seconds: 3),
            ),
          );
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(AppLanguage.translate('Could not extract ID number or name from text. Please check the text and try again.')),
              backgroundColor: Colors.orange,
              duration: const Duration(seconds: 4),
            ),
          );
        }
      }
    } catch (e, stackTrace) {
      print('❌ Error processing live text detection result: $e');
      print('Stack trace: $stackTrace');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(AppLanguage.translate('Could not parse data from Google Lens. Please enter manually.')),
            backgroundColor: Colors.orange,
            duration: const Duration(seconds: 3),
          ),
        );
      }
    }
  }

  Future<void> _takePhoto() async {
    // Show dialog to choose between camera and gallery
    final source = await showDialog<ImageSource>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(AppLanguage.translate('Select Photo Source')),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.camera_alt),
              title: Text(AppLanguage.translate('Camera')),
              onTap: () => Navigator.pop(context, ImageSource.camera),
            ),
            ListTile(
              leading: const Icon(Icons.photo_library),
              title: Text(AppLanguage.translate('Gallery')),
              onTap: () => Navigator.pop(context, ImageSource.gallery),
            ),
          ],
        ),
      ),
    );

    if (source == null) return;

    try {
      // Request permissions based on source
      bool hasPermission = false;
      if (source == ImageSource.camera) {
        hasPermission = await PermissionHelper.requestCameraPermission();
        if (!hasPermission) {
          if (context.mounted) {
            await PermissionHelper.showPermissionDeniedDialog(
              context,
              AppLanguage.translate('Camera permission is required. Please enable it in app settings.'),
            );
          }
          return;
        }
      } else {
        hasPermission = await PermissionHelper.requestStoragePermission();
        if (!hasPermission) {
          if (context.mounted) {
            await PermissionHelper.showPermissionDeniedDialog(
              context,
              AppLanguage.translate('Storage permission is required. Please enable it in app settings.'),
            );
          }
          return;
        }
      }

      // Use image_picker to get the image
      final image_picker.ImagePicker picker = image_picker.ImagePicker();
      final image_picker.XFile? image = await picker.pickImage(
        source: source == ImageSource.camera 
            ? image_picker.ImageSource.camera 
            : image_picker.ImageSource.gallery,
        imageQuality: 85,
      );

      // Check if widget is still mounted after async operation
      if (!mounted) return;

      if (image != null) {
        try {
          // Validate that the file path exists (skip check on web)
          if (!kIsWeb) {
            final file = File(image.path);
            final fileExists = await file.exists();
            
            if (!fileExists) {
              if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text(AppLanguage.translate('Error: Image file not found')),
                    backgroundColor: Colors.red,
                  ),
                );
              }
              return;
            }
          }
          
          // Set the photo path
          if (mounted) {
            setState(() {
              _photoPath = image.path;
            });
          }
          
          // Show success message
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(AppLanguage.translate(
                  source == ImageSource.camera ? 'Photo taken successfully' : 'Photo selected successfully'
                )),
                backgroundColor: Colors.green,
              ),
            );
          }
        } catch (fileError) {
          // If file check fails, still try to set the path (might work on some platforms)
          print('File check error (non-critical): $fileError');
          if (mounted) {
            setState(() {
              _photoPath = image.path;
            });
            
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(AppLanguage.translate(
                  source == ImageSource.camera ? 'Photo taken successfully' : 'Photo selected successfully'
                )),
                backgroundColor: Colors.green,
              ),
            );
          }
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _scanNFCCard() async {
    try {
      // Check if NFC is available
      final isAvailable = await NFCHelper.isNFCAvailable();
      if (!isAvailable) {
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(AppLanguage.translate('NFC is not available on this device')),
              backgroundColor: Colors.orange,
            ),
          );
        }
        return;
      }

      // Start NFC session
      NFCHelper.startNFCSession(
        context: context,
        onTagDetected: (id) {
          if (mounted) {
            setState(() {
              // Store original NFC tag ID for saving
              _originalNfcTagId = id;
              // Display masked NFC tag ID to user
              _nfcCodeController.text = NFCHelper.maskNfcTagId(id);
              _nfcDetected = true; // Mark as detected
            });
            
            // Check for duplicate NFC tag ID
            _checkDuplicateNFC(id);
            
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(AppLanguage.translate('NFC card detected')),
                backgroundColor: Colors.green,
              ),
            );
          }
        },
        onError: (error) {
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(error),
                backgroundColor: Colors.red,
              ),
            );
          }
        },
      );
    } catch (e, stackTrace) {
      print('Error scanning NFC: $e');
      print('Stack trace: $stackTrace');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _checkDuplicateID(String idNumber) async {
    // Check if ID already exists in Firestore
    try {
      final existingBeneficiary = await BeneficiaryService.getBeneficiaryByIdNumber(idNumber);
      
      if (existingBeneficiary != null) {
        setState(() {
          _duplicateIDMessage = 'This National ID is already registered with another beneficiary (Name: ${existingBeneficiary.name}, Distribution Area: ${existingBeneficiary.distributionArea}). Cannot register this beneficiary with the same National ID.';
        });
      } else {
        // Also check local list as fallback
        try {
          final localBeneficiary = widget.beneficiaries.firstWhere(
            (b) => b.idNumber == idNumber,
          );
          setState(() {
            _duplicateIDMessage = 'This National ID is already registered with another beneficiary (Name: ${localBeneficiary.name}, Initial assigned queue: ${localBeneficiary.initialAssignedQueuePoint}). Cannot register this beneficiary with the same National ID.';
          });
        } catch (e) {
          // ID not found - no duplicate
          setState(() {
            _duplicateIDMessage = null;
          });
        }
      }
    } catch (e) {
      print('Error checking duplicate ID: $e');
      // On error, also check local list
      try {
        final localBeneficiary = widget.beneficiaries.firstWhere(
          (b) => b.idNumber == idNumber,
        );
        setState(() {
          _duplicateIDMessage = 'This National ID is already registered with another beneficiary (Name: ${localBeneficiary.name}, Initial assigned queue: ${localBeneficiary.initialAssignedQueuePoint}). Cannot register this beneficiary with the same National ID.';
        });
      } catch (e2) {
        setState(() {
          _duplicateIDMessage = null;
        });
      }
    }
  }

  Future<void> _checkDuplicateMobile(String mobileNumber) async {
    if (mobileNumber.isEmpty) {
      setState(() {
        _duplicateMobileMessage = null;
      });
      return;
    }

    // Clean the mobile number (remove spaces, dashes)
    final cleanMobile = mobileNumber.replaceAll(RegExp(r'[\s\-]'), '');
    
    // Check if mobile number already exists in Firestore
    try {
      final existingBeneficiary = await BeneficiaryService.getBeneficiaryByMobile(cleanMobile);
      
      if (existingBeneficiary != null) {
        setState(() {
          _duplicateMobileMessage = 'This Mobile Number is already registered with another beneficiary (Name: ${existingBeneficiary.name}, National ID: ${existingBeneficiary.idNumber}, Distribution Area: ${existingBeneficiary.distributionArea}). Cannot register this beneficiary with the same Mobile Number.';
        });
      } else {
        // Also check local list as fallback
        try {
          final localBeneficiary = widget.beneficiaries.firstWhere(
            (b) => b.mobileNumber != null && b.mobileNumber!.replaceAll(RegExp(r'[\s\-]'), '') == cleanMobile,
          );
          setState(() {
            _duplicateMobileMessage = 'This Mobile Number is already registered with another beneficiary (Name: ${localBeneficiary.name}, National ID: ${localBeneficiary.idNumber}, Initial assigned queue: ${localBeneficiary.initialAssignedQueuePoint}). Cannot register this beneficiary with the same Mobile Number.';
          });
        } catch (e) {
          // Mobile number not found - no duplicate
          setState(() {
            _duplicateMobileMessage = null;
          });
        }
      }
    } catch (e) {
      print('Error checking duplicate mobile: $e');
      // On error, also check local list
      try {
        final localBeneficiary = widget.beneficiaries.firstWhere(
          (b) => b.mobileNumber != null && b.mobileNumber!.replaceAll(RegExp(r'[\s\-]'), '') == cleanMobile,
        );
        setState(() {
          _duplicateMobileMessage = 'This Mobile Number is already registered with another beneficiary (Name: ${localBeneficiary.name}, National ID: ${localBeneficiary.idNumber}, Initial assigned queue: ${localBeneficiary.initialAssignedQueuePoint}). Cannot register this beneficiary with the same Mobile Number.';
        });
      } catch (e2) {
        setState(() {
          _duplicateMobileMessage = null;
        });
      }
    }
  }

  Future<void> _checkDuplicateNFC(String nfcCode) async {
    if (nfcCode.isEmpty) {
      setState(() {
        _duplicateNFCMessage = null;
      });
      return;
    }

    // Check if NFC code already exists in Firestore
    try {
      final existingBeneficiary = await BeneficiaryService.getBeneficiaryByNFC(nfcCode);
      
      if (existingBeneficiary != null) {
        setState(() {
          _duplicateNFCMessage = 'This NFC card is already registered to: ${existingBeneficiary.name} (ID: ${existingBeneficiary.idNumber})';
        });
      } else {
        // Also check local list as fallback
        try {
          final localBeneficiary = widget.beneficiaries.firstWhere(
            (b) => b.nfcPreprintedCode != null && b.nfcPreprintedCode == nfcCode,
          );
          setState(() {
            _duplicateNFCMessage = 'This NFC card is already registered to: ${localBeneficiary.name} (ID: ${localBeneficiary.idNumber})';
          });
        } catch (e) {
          // NFC code not found - no duplicate
          setState(() {
            _duplicateNFCMessage = null;
          });
        }
      }
    } catch (e) {
      print('Error checking duplicate NFC: $e');
      // On error, also check local list
      try {
        final localBeneficiary = widget.beneficiaries.firstWhere(
          (b) => b.nfcPreprintedCode != null && b.nfcPreprintedCode == nfcCode,
        );
        setState(() {
          _duplicateNFCMessage = 'This NFC card is already registered to: ${localBeneficiary.name} (ID: ${localBeneficiary.idNumber})';
        });
      } catch (e2) {
        setState(() {
          _duplicateNFCMessage = null;
        });
      }
    }
  }

  Future<void> _handleRegister() async {
    if (_formKey.currentState!.validate()) {
      if (_selectedDistributionArea == null) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(AppLanguage.translate('Please select a distribution area'))),
        );
        return;
      }

      // Prevent saving if there's a duplicate NFC message
      if (_duplicateNFCMessage != null) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(_duplicateNFCMessage!),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 4),
          ),
        );
        return;
      }

      // Check for duplicate ID in Firestore before proceeding
      if (_idNumberController.text.isNotEmpty) {
        final existingBeneficiary = await BeneficiaryService.getBeneficiaryByIdNumber(_idNumberController.text);
        if (existingBeneficiary != null) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('This ID number is already registered in the system.'),
              backgroundColor: Colors.red,
            ),
          );
          return;
        }
      }

      // Check for duplicate NFC tag ID before proceeding
      // First check if there's already a duplicate message set
      if (_duplicateNFCMessage != null) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(_duplicateNFCMessage!),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 4),
          ),
        );
        return;
      }

      // Get NFC code to check - prefer original, but if manually entered, use the text field value
      // Note: If manually entered, the text might be masked, so we need to handle that
      String? nfcCodeToCheck = _originalNfcTagId;
      if (nfcCodeToCheck == null || nfcCodeToCheck.isEmpty) {
        final textFieldValue = _nfcCodeController.text.trim();
        if (textFieldValue.isNotEmpty) {
          // If the text contains asterisks, it's masked - we can't validate it properly
          // In this case, we should ask user to scan the card again
          if (textFieldValue.contains('*')) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Please scan the NFC card again. Manual entry of masked NFC codes is not allowed.'),
                backgroundColor: Colors.orange,
                duration: Duration(seconds: 3),
              ),
            );
            return;
          }
          nfcCodeToCheck = textFieldValue;
        }
      }

      if (nfcCodeToCheck != null && nfcCodeToCheck.isNotEmpty) {
        final existingNfcBeneficiary = await BeneficiaryService.getBeneficiaryByNFC(nfcCodeToCheck);
        if (existingNfcBeneficiary != null) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('This NFC card is already registered to: ${existingNfcBeneficiary.name} (ID: ${existingNfcBeneficiary.idNumber})'),
              backgroundColor: Colors.red,
              duration: const Duration(seconds: 4),
            ),
          );
          return;
        }
      }

      String entityName = '';
      if (_isEntity) {
        if (_useCustomEntity) {
          if (_customEntityController.text.isEmpty) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text(AppLanguage.translate('Please enter entity name'))),
            );
            return;
          }
          entityName = _customEntityController.text;
          widget.onEntityAdded(entityName);
        } else {
          if (_selectedEntity == null) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text(AppLanguage.translate('Please select an entity'))),
            );
            return;
          }
          entityName = _selectedEntity!;
        }
      }

      String units = _numberOfUnits;
      if (_useCustomUnits) {
        if (_customUnitsController.text.isEmpty) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(AppLanguage.translate('Please enter number of units'))),
          );
          return;
        }
        units = _customUnitsController.text;
      }

      // Show loading dialog
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => const Center(
          child: CircularProgressIndicator(),
        ),
      );

      try {
        // Get the current admin ID for createdBy field
        final createdBy = AdminService.currentAdminId ?? 'system';
        
        // Create beneficiary object
        final beneficiary = Beneficiary(
          id: DateTime.now().millisecondsSinceEpoch.toString(), // Temporary ID, will be replaced by Firestore ID
          distributionArea: _selectedDistributionArea!, // This is the distribution area ID selected from dropdown
          initialAssignedQueuePoint: '', // Not required in registration screen
          type: _type,
          idCopyPath: _idCopyPath,
          gender: _gender,
          name: _nameController.text,
          idNumber: _idNumberController.text.replaceAll(RegExp(r'[\s\-]'), ''), // Clean ID number
          mobileNumber: _mobileNumberController.text.isNotEmpty ? _mobileNumberController.text.replaceAll(RegExp(r'[\s\-]'), '') : null, // Clean mobile number
          isEntity: _isEntity,
          entityName: _isEntity ? entityName : null,
          numberOfUnits: units,
          nfcPreprintedCode: _originalNfcTagId ?? (_nfcCodeController.text.isNotEmpty ? _nfcCodeController.text : null),
          photoPath: _photoPath,
          status: _status,
          birthDate: _extractedBirthDate,
        );

        // Save to Firestore
        final beneficiaryId = await BeneficiaryService.createBeneficiary(beneficiary, createdBy);
        
        // Update beneficiary with Firestore ID
        final savedBeneficiary = beneficiary.copyWith(id: beneficiaryId);

        // Close loading dialog
        if (mounted) {
          Navigator.of(context).pop();
        }

        // Call the callback with the saved beneficiary
        widget.onBeneficiaryCreated(savedBeneficiary);

        // Show success message
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(AppLanguage.translate('Beneficiary registered successfully')),
              backgroundColor: Colors.green,
            ),
          );
        }
      } catch (e) {
        // Close loading dialog
        if (mounted) {
          Navigator.of(context).pop();
        }
        
        print('Error creating beneficiary: $e');
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error registering beneficiary: $e'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    const darkBlue = Color(0xFF1A237E);
    const tealGreen = Color(0xFF81CF01);

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Color(0xFFE8F5E9), Colors.white],
          ),
        ),
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(20.0),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  AppLanguage.translate('Beneficiary Registration'),
                  style: const TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                    color: darkBlue,
                  ),
                ),
                const SizedBox(height: 32),
                _buildLabel('Distribution Area *'),
                const SizedBox(height: 8),
                _buildDistributionAreaDropdown(),
                const SizedBox(height: 24),
                _buildLabel('ID Copy *'),
                const SizedBox(height: 8),
                Row(
                  children: [
                    Expanded(
                      child: ElevatedButton.icon(
                        onPressed: () async {
                          final result = await Navigator.push<String>(
                            context,
                            MaterialPageRoute(
                              builder: (context) => const LiveTextDetectionScreen(),
                            ),
                          );
                          
                          // Handle the returned text from Live Text Detection
                          if (result != null && result.isNotEmpty) {
                            _processLiveTextDetectionResult(result);
                          }
                        },
                        icon: const Icon(Icons.camera_alt, size: 18),
                        label: Text(
                          AppLanguage.translate('Scan National ID'),
                          style: const TextStyle(fontSize: 11),
                        ),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.blue,
                          foregroundColor: Colors.white,
                          padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 6),
                        ),
                      ),
                    ),
                    if (_idCopyPath != null) ...[
                      const SizedBox(width: 8),
                      const Icon(Icons.check_circle, color: Colors.green, size: 24),
                    ],
                  ],
                ),
                const SizedBox(height: 24),
                _buildLabel('Type *'),
                const SizedBox(height: 8),
                _buildDropdown(_type, _typeOptions, (value) => setState(() => _type = value ?? 'Normal')),
                const SizedBox(height: 24),
                _buildLabel('Gender *'),
                const SizedBox(height: 8),
                Row(
                  children: [
                    Expanded(
                      child: RadioListTile<String>(
                        title: Text(AppLanguage.translate('Male')),
                        value: 'Male',
                        groupValue: _gender,
                        onChanged: (value) => setState(() => _gender = value ?? 'Male'),
                        contentPadding: EdgeInsets.zero,
                        dense: true,
                      ),
                    ),
                    Expanded(
                      child: RadioListTile<String>(
                        title: Text(AppLanguage.translate('Female')),
                        value: 'Female',
                        groupValue: _gender,
                        onChanged: (value) => setState(() => _gender = value ?? 'Female'),
                        contentPadding: EdgeInsets.zero,
                        dense: true,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 24),
                _buildLabel('Name *'),
                const SizedBox(height: 8),
                Row(
                  children: [
                    Expanded(
                      child: TextFormField(
                        controller: _nameController,
                        focusNode: _nameFocusNode,
                        textInputAction: TextInputAction.next,
                        decoration: _buildInputDecoration(AppLanguage.translate('Enter name or extract from ID')),
                        validator: (value) => value?.isEmpty ?? true ? AppLanguage.translate('Please enter name') : null,
                        onFieldSubmitted: (_) => _idNumberFocusNode.requestFocus(),
                      ),
                    ),
                    if (_idCopyPath != null) ...[
                      const SizedBox(width: 8),
                      IconButton(
                        icon: const Icon(Icons.auto_fix_high),
                        tooltip: AppLanguage.translate('Extract name from ID using OCR'),
                        onPressed: _extractNameFromID,
                      ),
                    ],
                  ],
                ),
                const SizedBox(height: 24),
                _buildLabel('ID Number *'),
                const SizedBox(height: 8),
                TextFormField(
                  controller: _idNumberController,
                  focusNode: _idNumberFocusNode,
                  keyboardType: TextInputType.number,
                  textInputAction: TextInputAction.next,
                  decoration: _buildInputDecoration('Enter National ID (14 digits)'),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return AppLanguage.translate('Please enter National ID number');
                    }
                    // Remove any spaces or dashes for validation
                    final cleanValue = value.replaceAll(RegExp(r'[\s\-]'), '');
                    // Check if it's exactly 14 digits
                    if (cleanValue.length != 14) {
                      return 'National ID must be exactly 14 digits';
                    }
                    // Check if all characters are digits
                    if (!RegExp(r'^\d{14}$').hasMatch(cleanValue)) {
                      return 'National ID must contain only digits';
                    }
                    // Check if first digit is 2 or 3 (Egyptian ID format)
                    final firstDigit = int.tryParse(cleanValue.substring(0, 1));
                    if (firstDigit != 2 && firstDigit != 3) {
                      return 'Invalid National ID format (must start with 2 or 3)';
                    }
                    return null;
                  },
                  onFieldSubmitted: (_) => _mobileNumberFocusNode.requestFocus(),
                  onChanged: (value) {
                    if (value.isNotEmpty) {
                      // Clean the value before checking
                      final cleanValue = value.replaceAll(RegExp(r'[\s\-]'), '');
                      if (cleanValue.length == 14) {
                        _checkDuplicateID(cleanValue);
                      } else {
                        setState(() {
                          _duplicateIDMessage = null;
                        });
                      }
                    } else {
                      setState(() {
                        _duplicateIDMessage = null;
                      });
                    }
                  },
                ),
                if (_duplicateIDMessage != null) ...[
                  const SizedBox(height: 8),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: Colors.orange.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(color: Colors.orange),
                    ),
                    child: Row(
                      children: [
                        const Icon(Icons.warning, color: Colors.orange),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            _duplicateIDMessage!,
                            style: const TextStyle(color: Colors.orange),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
                const SizedBox(height: 24),
                _buildLabel('Mobile Number *'),
                const SizedBox(height: 8),
                TextFormField(
                  controller: _mobileNumberController,
                  focusNode: _mobileNumberFocusNode,
                  keyboardType: TextInputType.phone,
                  textInputAction: TextInputAction.next,
                  decoration: _buildInputDecoration('Enter mobile number (01XXXXXXXXX)'),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return AppLanguage.translate('Please enter mobile number');
                    }
                    // Remove any spaces or dashes for validation
                    final cleanValue = value.replaceAll(RegExp(r'[\s\-]'), '');
                    // Check Egyptian mobile number format: 01[0-2,5][0-9]{8}
                    final regex = RegExp(r'^01[0-2,5][0-9]{8}$');
                    if (!regex.hasMatch(cleanValue)) {
                      return 'Invalid Egyptian mobile number format. Must be 11 digits starting with 01 (e.g., 01012345678, 01123456789, 01234567890, 01512345678)';
                    }
                    return null;
                  },
                  onFieldSubmitted: (_) {
                    // Move to custom units if visible, otherwise to NFC code
                    if (_useCustomUnits && _customUnitsFocusNode.canRequestFocus) {
                      _customUnitsFocusNode.requestFocus();
                    } else if (_useCustomEntity && _customEntityFocusNode.canRequestFocus) {
                      _customEntityFocusNode.requestFocus();
                    } else {
                      _nfcCodeFocusNode.requestFocus();
                    }
                  },
                  onChanged: (value) {
                    if (value.isNotEmpty) {
                      // Clean the value before checking
                      final cleanValue = value.replaceAll(RegExp(r'[\s\-]'), '');
                      // Only check if it's a valid format (11 digits starting with 01)
                      if (RegExp(r'^01[0-2,5][0-9]{8}$').hasMatch(cleanValue)) {
                        _checkDuplicateMobile(cleanValue);
                      } else {
                        setState(() {
                          _duplicateMobileMessage = null;
                        });
                      }
                    } else {
                      setState(() {
                        _duplicateMobileMessage = null;
                      });
                    }
                  },
                ),
                if (_duplicateMobileMessage != null) ...[
                  const SizedBox(height: 8),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: Colors.orange.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(color: Colors.orange),
                    ),
                    child: Row(
                      children: [
                        const Icon(Icons.warning, color: Colors.orange),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            _duplicateMobileMessage!,
                            style: const TextStyle(color: Colors.orange),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
                const SizedBox(height: 24),
                _buildLabel('Number of Units *'),
                const SizedBox(height: 8),
                Row(
                  children: [
                    Expanded(
                      child: _buildDropdown(
                        _numberOfUnits,
                        _unitsOptions,
                        (value) => setState(() {
                          _numberOfUnits = value ?? '1';
                          _useCustomUnits = false;
                        }),
                      ),
                    ),
                    Checkbox(
                      value: _useCustomUnits,
                      onChanged: (value) => setState(() => _useCustomUnits = value ?? false),
                    ),
                    const Text('Custom'),
                  ],
                ),
                if (_useCustomUnits) ...[
                  const SizedBox(height: 12),
                  TextFormField(
                    controller: _customUnitsController,
                    keyboardType: TextInputType.number,
                    decoration: _buildInputDecoration('Enter custom number of units'),
                  ),
                ],
                const SizedBox(height: 24),
                CheckboxListTile(
                  title: Text(AppLanguage.translate('Entity')),
                  value: _isEntity,
                  onChanged: (value) => setState(() => _isEntity = value ?? false),
                ),
                if (_isEntity) ...[
                  const SizedBox(height: 8),
                  Row(
                    children: [
                      Expanded(
                        child: Container(
                          padding: const EdgeInsets.symmetric(horizontal: 16),
                          decoration: BoxDecoration(
                            border: Border.all(color: const Color(0xFFE0E0E0)),
                            borderRadius: BorderRadius.circular(8),
                            color: Colors.white,
                          ),
                          child: DropdownButtonHideUnderline(
                            child: DropdownButton<String>(
                              value: _selectedEntity,
                              isExpanded: true,
                              hint: const Text('Select entity'),
                              items: [...widget.entities, 'Other'].map((entity) {
                                return DropdownMenuItem(
                                  value: entity,
                                  child: Text(entity),
                                );
                              }).toList(),
                              onChanged: (value) => setState(() {
                                _selectedEntity = value;
                                _useCustomEntity = value == 'Other';
                              }),
                            ),
                          ),
                        ),
                      ),
                    ],
                  ),
                  if (_useCustomEntity) ...[
                    const SizedBox(height: 12),
                    TextFormField(
                      controller: _customEntityController,
                      decoration: _buildInputDecoration('Enter custom entity name'),
                    ),
                  ],
                ],
                const SizedBox(height: 24),
                _buildLabel('Photo (Optional)'),
                const SizedBox(height: 8),
                Row(
                  children: [
                    if (_photoPath != null)
                      Container(
                        width: 80,
                        height: 80,
                        decoration: BoxDecoration(
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.grey.withOpacity(0.3)),
                          color: Colors.grey[200],
                        ),
                        child: Stack(
                          children: [
                            ClipRRect(
                              borderRadius: BorderRadius.circular(8),
                              child: _photoPath!.startsWith('http://') || _photoPath!.startsWith('https://')
                                ? Image.network(
                                    _photoPath!,
                                    width: 80,
                                    height: 80,
                                    fit: BoxFit.cover,
                                    errorBuilder: (context, error, stackTrace) {
                                      return Icon(
                                        Icons.person,
                                        size: 40,
                                        color: Colors.grey[600],
                                      );
                                    },
                                  )
                                : _photoPath!.startsWith('assets/')
                                  ? Image.asset(
                                      _photoPath!,
                                      width: 80,
                                      height: 80,
                                      fit: BoxFit.cover,
                                      errorBuilder: (context, error, stackTrace) {
                                        return Icon(
                                          Icons.person,
                                          size: 40,
                                          color: Colors.grey[600],
                                        );
                                      },
                                    )
                                  : kIsWeb
                                    ? Icon(
                                        Icons.person,
                                        size: 40,
                                        color: Colors.grey[600],
                                      )
                                    : Image.file(
                                        File(_photoPath!),
                                        width: 80,
                                        height: 80,
                                        fit: BoxFit.cover,
                                        errorBuilder: (context, error, stackTrace) {
                                          return Icon(
                                            Icons.person,
                                            size: 40,
                                            color: Colors.grey[600],
                                          );
                                        },
                                      ),
                            ),
                            Positioned(
                              right: 0,
                              top: 0,
                              child: IconButton(
                                icon: const Icon(Icons.close, size: 20, color: Colors.red),
                                onPressed: () {
                                  setState(() {
                                    _photoPath = null;
                                  });
                                },
                              ),
                            ),
                          ],
                        ),
                      )
                    else
                      Container(
                        width: 80,
                        height: 80,
                        decoration: BoxDecoration(
                          color: Colors.grey[200],
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.grey.withOpacity(0.3)),
                        ),
                        child: const Icon(Icons.person, size: 40, color: Colors.grey),
                      ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: ElevatedButton.icon(
                        onPressed: _takePhoto,
                        icon: const Icon(Icons.camera_alt),
                        label: Text(_photoPath != null ? 'Retake Photo' : 'Take Photo'),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: tealGreen,
                          foregroundColor: Colors.white,
                          padding: const EdgeInsets.symmetric(vertical: 12),
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 24),
                Row(
                  children: [
                    _buildLabel('NFC Code'),
                    const SizedBox(width: 8),
                    Expanded(
                      child: TextFormField(
                        controller: _nfcCodeController,
                        decoration: InputDecoration(
                          hintText: AppLanguage.translate('Enter NFC code'),
                          border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          filled: true,
                          fillColor: Colors.white,
                          contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
                          isDense: true,
                          suffixIcon: _nfcDetected
                              ? const Icon(Icons.check_circle, color: Colors.green, size: 24)
                              : IconButton(
                            icon: const Icon(Icons.nfc, color: Color(0xFF81CF01)),
                            onPressed: _scanNFCCard,
                            tooltip: AppLanguage.translate('Scan NFC Card'),
                          ),
                        ),
                        onChanged: (value) {
                          // Reset detection status if user manually edits the field
                          if (mounted && _nfcDetected) {
                            setState(() {
                              _nfcDetected = false;
                              _originalNfcTagId = null; // Clear original ID when manually edited
                            });
                          }
                          // Clear duplicate message when field is cleared
                          if (value.isEmpty) {
                            setState(() {
                              _duplicateNFCMessage = null;
                            });
                          }
                        },
                      ),
                    ),
                  ],
                ),
                if (_duplicateNFCMessage != null) ...[
                  const SizedBox(height: 8),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: Colors.red.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(color: Colors.red),
                    ),
                    child: Row(
                      children: [
                        const Icon(Icons.error, color: Colors.red),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            _duplicateNFCMessage!,
                            style: const TextStyle(color: Colors.red),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
                const SizedBox(height: 24),
                ElevatedButton(
                  onPressed: () => _handleRegister(),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: tealGreen,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    minimumSize: const Size(double.infinity, 0),
                  ),
                  child: Text(AppLanguage.translate('Register Beneficiary')),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildLabel(String text) {
    return Text(
      AppLanguage.translate(text),
      style: const TextStyle(fontSize: 14, fontWeight: FontWeight.w500, color: Color(0xFF1A237E)),
    );
  }

  InputDecoration _buildInputDecoration(String hint) {
    return InputDecoration(
      hintText: AppLanguage.translate(hint),
      border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
      filled: true,
      fillColor: Colors.white,
    );
  }

  Widget _buildDropdown(String value, List<String> items, Function(String?) onChanged) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        border: Border.all(color: const Color(0xFFE0E0E0)),
        borderRadius: BorderRadius.circular(8),
        color: Colors.white,
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: value,
          isExpanded: true,
          items: items.map((item) => DropdownMenuItem(value: item, child: Text(AppLanguage.translate(item)))).toList(),
          onChanged: onChanged,
        ),
      ),
    );
  }

  Widget _buildDistributionAreaDropdown() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        border: Border.all(color: const Color(0xFFE0E0E0)),
        borderRadius: BorderRadius.circular(8),
        color: Colors.white,
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: _selectedDistributionArea,
          isExpanded: true,
          hint: const Text('Select distribution area'),
          items: widget.distributionAreas.map((area) {
            return DropdownMenuItem(
              value: area.id,
              child: Text(
                area.fullName,
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            );
          }).toList(),
          selectedItemBuilder: (context) {
            return widget.distributionAreas.map((area) {
              return Text(
                area.fullName,
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              );
            }).toList();
          },
          onChanged: (value) {
            setState(() {
              _selectedDistributionArea = value;
            });
          },
        ),
      ),
    );
  }
}

// Beneficiaries List Screen
class BeneficiariesListScreen extends StatefulWidget {
  final List<Beneficiary> beneficiaries;
  final List<Queue> queues;
  final List<DistributionArea> distributionAreas;
  final List<String> entities;
  final Function(Beneficiary) onBeneficiaryUpdated;
  final Function(String) onEntityAdded;

  const BeneficiariesListScreen({
    super.key,
    required this.beneficiaries,
    required this.queues,
    required this.distributionAreas,
    required this.entities,
    required this.onBeneficiaryUpdated,
    required this.onEntityAdded,
  });

  @override
  State<BeneficiariesListScreen> createState() => _BeneficiariesListScreenState();
}

class _BeneficiariesListScreenState extends State<BeneficiariesListScreen> {
  String? _selectedDistributionArea;
  final TextEditingController _searchController = TextEditingController();
  bool _isExpanded = true; // Make dropdown visible by default
  List<String> _adminDistributionAreaIds = [];
  final ValueNotifier<int> _progressNotifier = ValueNotifier<int>(0);
  
  // Performance optimizations
  Timer? _searchDebounce;
  static const int _initialLoadLimit = 100; // Load first 100 beneficiaries
  static const int _loadMoreLimit = 50; // Load 50 more when scrolling
  final ScrollController _scrollController = ScrollController();
  List<Beneficiary> _loadedBeneficiaries = [];
  bool _isLoadingMore = false;
  bool _hasMoreData = true;
  DocumentSnapshot? _lastDocument;

  @override
  void initState() {
    super.initState();
    // Setup scroll listener for pagination
    _scrollController.addListener(_onScroll);
    // Setup search debouncing
    _searchController.addListener(_onSearchChanged);
    // Get admin's distribution areas
    final currentAdmin = AdminService.currentAdmin;
    if (currentAdmin != null && currentAdmin.distributionPoint.isNotEmpty) {
      // Super Admin or admin with distributionPoint == "All" can see all areas
      if (currentAdmin.isSuperAdmin || currentAdmin.distributionPoint.toLowerCase() == 'all') {
        _adminDistributionAreaIds = widget.distributionAreas.map((area) => area.id).toList();
      } else {
      // Match admin's distribution point with distribution areas
      _adminDistributionAreaIds = widget.distributionAreas
          .where((area) {
            final adminPoint = currentAdmin.distributionPoint.toLowerCase();
            final areaName = area.areaName.toLowerCase();
            return areaName.contains(adminPoint) || adminPoint.contains(areaName);
          })
          .map((area) => area.id)
          .toList();
      
      // Set default selected area if only one area matches
      if (_adminDistributionAreaIds.length == 1) {
        _selectedDistributionArea = _adminDistributionAreaIds.first;
        }
      }
    } else {
      // If no admin or no distribution point, show all areas
      _adminDistributionAreaIds = widget.distributionAreas.map((area) => area.id).toList();
    }
  }

  @override
  void dispose() {
    _searchController.removeListener(_onSearchChanged);
    _searchController.dispose();
    _progressNotifier.dispose();
    _scrollController.removeListener(_onScroll);
    _scrollController.dispose();
    _searchDebounce?.cancel();
    super.dispose();
  }
  
  void _onSearchChanged() {
    _searchDebounce?.cancel();
    _searchDebounce = Timer(const Duration(milliseconds: 500), () {
      if (mounted) {
        setState(() {});
      }
    });
  }
  
  void _onScroll() {
    if (_scrollController.position.pixels >= _scrollController.position.maxScrollExtent * 0.8) {
      _loadMoreBeneficiaries();
    }
  }
  
  Future<void> _loadMoreBeneficiaries() async {
    if (_isLoadingMore || !_hasMoreData || _searchController.text.isNotEmpty) {
      return; // Don't load more if searching or already loading
    }
    
    setState(() {
      _isLoadingMore = true;
    });
    
    try {
      List<Beneficiary> moreBeneficiaries;
      if (_selectedDistributionArea != null) {
        moreBeneficiaries = await BeneficiaryService.getBeneficiariesByAreaPaginated(
          areaId: _selectedDistributionArea!,
          limit: _loadMoreLimit,
          startAfter: _lastDocument,
          activeOnly: true, // Only load Active beneficiaries
        );
      } else {
        moreBeneficiaries = await BeneficiaryService.getBeneficiariesPaginated(
          limit: _loadMoreLimit,
          startAfter: _lastDocument,
          activeOnly: true, // Only load Active beneficiaries
        );
      }
      
      if (moreBeneficiaries.isEmpty) {
        _hasMoreData = false;
      } else {
        _loadedBeneficiaries.addAll(moreBeneficiaries);
        // Update last document for next pagination
        // Note: We'd need to track the last document from the query
        // For now, we'll use the length as a simple check
      }
    } catch (e) {
      print('Error loading more beneficiaries: $e');
    } finally {
      if (mounted) {
        setState(() {
          _isLoadingMore = false;
        });
      }
    }
  }

  List<Beneficiary> _filterBeneficiaries(List<Beneficiary> beneficiaries) {
    var filtered = beneficiaries;

    // If a specific area is selected, the StreamBuilder already filtered by that area in Firestore
    // So we only need to apply admin area filtering if no area is selected (showing all areas)
    if (_selectedDistributionArea == null) {
      // Filter by admin's distribution areas only when showing all areas
      // (This ensures we only show beneficiaries from areas the admin has access to)
      if (_adminDistributionAreaIds.isNotEmpty) {
        filtered = filtered.where((b) => _adminDistributionAreaIds.contains(b.distributionArea)).toList();
      }
      // If _adminDistributionAreaIds is empty (no matching areas), show all beneficiaries
      // This handles the case where admin's distributionPoint doesn't match any area names
    }
    // When a specific area is selected, we trust the Firestore query and don't filter further

    // Filter by search query (name, ID, or mobile number)
    if (_searchController.text.isNotEmpty) {
      final query = _searchController.text.trim();
      // For Arabic text, we need to search without case conversion as toLowerCase() may not work correctly
      // We'll do case-insensitive search for English and direct search for Arabic
      filtered = filtered.where((b) {
        final name = b.name;
        final idNumber = b.idNumber;
        final mobileNumber = b.mobileNumber ?? '';
        
        // Check if query contains Arabic characters
        final hasArabic = RegExp(r'[\u0600-\u06FF]').hasMatch(query);
        
        if (hasArabic) {
          // For Arabic text, search directly (Arabic is case-insensitive by nature)
          return name.contains(query) ||
                 idNumber.contains(query) ||
                 mobileNumber.contains(query);
        } else {
          // For non-Arabic (English/numbers), do case-insensitive search
          final queryLower = query.toLowerCase();
          return name.toLowerCase().contains(queryLower) ||
                 idNumber.toLowerCase().contains(queryLower) ||
                 mobileNumber.toLowerCase().contains(queryLower);
        }
      }).toList();
    }

    return filtered;
  }

  // Generate test beneficiaries
  Future<void> _generateTestBeneficiaries() async {
    // Show confirmation dialog
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Generate Test Data'),
        content: const Text('This will create 9000 test beneficiaries with Active status. This may take several minutes. Continue?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(backgroundColor: Colors.orange),
            child: const Text('Generate'),
          ),
        ],
      ),
    );

    if (confirm != true) return;

    // Show loading dialog with progress
    final loadingContext = context;
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => StatefulBuilder(
        builder: (context, setDialogState) {
          return AlertDialog(
            content: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const CircularProgressIndicator(),
                const SizedBox(height: 20),
                ValueListenableBuilder<int>(
                  valueListenable: _progressNotifier,
                  builder: (context, progress, child) {
                    return Text('Generating test data...\n$progress/9000 created');
                  },
                ),
              ],
            ),
          );
        },
      ),
    );

    try {
      final random = math.Random();
      final firstNames = ['Ahmed', 'Mohamed', 'Ali', 'Hassan', 'Omar', 'Khaled', 'Youssef', 'Mahmoud', 'Ibrahim', 'Said', 'Fatima', 'Aisha', 'Mariam', 'Zainab', 'Khadija', 'Salma', 'Nour', 'Layla', 'Hana', 'Sara', 'Nadia', 'Rania', 'Dina', 'Yasmin', 'Reem', 'Lina', 'Rana', 'Heba', 'Doha', 'Mona'];
      final lastNames = ['Ali', 'Hassan', 'Ibrahim', 'Mohamed', 'Ahmed', 'Omar', 'Khaled', 'Mahmoud', 'Youssef', 'Said', 'Abdullah', 'Hussein', 'Salem', 'Farid', 'Nasser', 'Tariq', 'Rashid', 'Malik', 'Karim', 'Bakr', 'Zaki', 'Fouad', 'Adel', 'Samir', 'Waleed', 'Tamer', 'Sherif', 'Amr', 'Hany', 'Mostafa'];
      final genders = ['Male', 'Female'];
      final types = ['Normal', 'VIP', 'Special'];
      final status = 'Active'; // All beneficiaries will have Active status
      final unitsOptions = ['1', '2', '3', '4', '5'];
      
      // Get available distribution areas and entities
      final availableAreas = widget.distributionAreas.isNotEmpty 
          ? widget.distributionAreas 
          : await DistributionAreaService.getAllAreas().first;
      final availableEntities = widget.entities.isNotEmpty 
          ? widget.entities 
          : ['Individual', 'Family', 'Organization', 'Other'];
      
      if (availableAreas.isEmpty) {
        if (mounted) {
          Navigator.pop(loadingContext); // Close loading
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('No distribution areas available. Please create at least one area first.')),
          );
        }
        return;
      }

      final currentAdminId = AdminService.currentAdminId ?? 'system';
      int created = 0;
      _progressNotifier.value = 0;
      
      for (int i = 0; i < 9000; i++) {
        final firstName = firstNames[random.nextInt(firstNames.length)];
        final lastName = lastNames[random.nextInt(lastNames.length)];
        final name = '$firstName $lastName';
        final gender = genders[random.nextInt(genders.length)];
        
        // Generate valid Egyptian National ID (14 digits, starts with 2 or 3)
        // Use index and timestamp to ensure uniqueness
        final idPrefix = random.nextBool() ? '2' : '3';
        final uniquePart = (i * 1000000 + DateTime.now().millisecondsSinceEpoch % 1000000).toString().padLeft(13, '0');
        final paddedId = '$idPrefix${uniquePart.substring(0, 13)}';
        
        // Generate valid Egyptian mobile number (11 digits, starts with 01, third digit is 0,1,2, or 5)
        // Use index to ensure uniqueness
        final mobilePrefix = '01';
        final mobileThirdDigit = ['0', '1', '2', '5'][random.nextInt(4)];
        final uniqueSuffix = (90000000 + i).toString().padLeft(8, '0');
        final mobileNumber = '$mobilePrefix$mobileThirdDigit$uniqueSuffix';
        
        // Generate NFC code (optional, 30% chance)
        final String? nfcCode = random.nextDouble() < 0.3 
            ? 'NFC_${(i * 1000 + DateTime.now().millisecondsSinceEpoch % 1000).toRadixString(16).toUpperCase().padLeft(10, '0')}'
            : null;
        
        final distributionArea = availableAreas[random.nextInt(availableAreas.length)];
        final isEntity = random.nextDouble() < 0.1; // 10% chance of being an entity
        final entityName = isEntity ? availableEntities[random.nextInt(availableEntities.length)] : null;
        
        // Generate birth date (between 18 and 80 years ago)
        final yearsAgo = 18 + random.nextInt(62);
        final birthDate = DateTime.now().subtract(Duration(days: yearsAgo * 365 + random.nextInt(365)));
        
        final beneficiary = Beneficiary(
          id: '', // Will be generated by Firestore
          distributionArea: distributionArea.id,
          initialAssignedQueuePoint: '', // No initial queue assignment
          type: types[random.nextInt(types.length)],
          gender: gender,
          name: name,
          idNumber: paddedId,
          mobileNumber: mobileNumber,
          isEntity: isEntity,
          entityName: entityName,
          numberOfUnits: unitsOptions[random.nextInt(unitsOptions.length)],
          nfcPreprintedCode: nfcCode,
          status: status, // All Active
          birthDate: birthDate,
          isServed: false,
          unitsTaken: 0,
          createdBy: currentAdminId,
        );
        
        await BeneficiaryService.createBeneficiary(beneficiary, currentAdminId);
        created++;
        _progressNotifier.value = created;
        
        // Update progress every 500 beneficiaries
        if (created % 500 == 0) {
          print('✅ Created $created/9000 test beneficiaries...');
        }
      }
      
      if (mounted) {
        Navigator.pop(loadingContext); // Close loading
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Successfully created $created test beneficiaries with Active status!'),
            backgroundColor: Colors.green,
            duration: const Duration(seconds: 5),
          ),
        );
      }
    } catch (e) {
      print('Error generating test beneficiaries: $e');
      if (mounted) {
        Navigator.pop(loadingContext); // Close loading
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error generating test data: $e'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 5),
          ),
        );
      }
    } finally {
      _progressNotifier.value = 0;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          // Header
          Container(
            padding: const EdgeInsets.all(20.0),
            color: Colors.white,
            child: Row(
              children: [
                Expanded(
                  child: Text(
                    AppLanguage.translate('Beneficiaries'),
                    style: const TextStyle(
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                      color: Color(0xFF1A237E),
                    ),
                  ),
                ),
                // Test Data Generation Button
                IconButton(
                  icon: const Icon(Icons.science, color: Colors.orange),
                  tooltip: 'Generate 1000 Test Beneficiaries',
                  onPressed: _generateTestBeneficiaries,
                ),
              ],
            ),
          ),
          // Distribution Area Dropdown (Collapsible)
          Container(
            padding: const EdgeInsets.all(16.0),
            color: Colors.white,
            child: Column(
              children: [
                InkWell(
                  onTap: () {
                    setState(() {
                      _isExpanded = !_isExpanded;
                    });
                  },
                  child: Row(
                    children: [
                      Text(
                        AppLanguage.translate('Distribution Area'),
                        style: const TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.w600,
                          color: Color(0xFF1A237E),
                        ),
                      ),
                      const Spacer(),
                      Icon(
                        _isExpanded ? Icons.expand_less : Icons.expand_more,
                        color: const Color(0xFF81CF01),
                      ),
                    ],
                  ),
                ),
                if (_isExpanded) ...[
                  const SizedBox(height: 12),
                  StreamBuilder<List<DistributionArea>>(
                    stream: DistributionAreaService.getAllAreas(),
                    builder: (context, snapshot) {
                      List<DistributionArea> displayAreas = [];
                      
                      if (snapshot.connectionState == ConnectionState.waiting && snapshot.data == null) {
                        // Still loading and no data yet - use local list
                        displayAreas = widget.distributionAreas;
                      } else if (snapshot.hasError) {
                        // Error occurred - use local list
                        print('StreamBuilder error: ${snapshot.error}');
                        displayAreas = widget.distributionAreas;
                      } else {
                        // Use Firestore data if available, otherwise fall back to local
                        final firestoreAreas = snapshot.data ?? [];
                        displayAreas = firestoreAreas.isNotEmpty ? firestoreAreas : widget.distributionAreas;
                      }
                      
                      // Filter by admin's distribution areas
                      // Match admin's distributionPoint with area names (same logic as initState)
                      final currentAdmin = AdminService.currentAdmin;
                      if (currentAdmin != null && currentAdmin.distributionPoint.isNotEmpty && displayAreas.isNotEmpty) {
                        // Super Admin or admin with distributionPoint == "All" can see all areas
                        if (currentAdmin.isSuperAdmin || currentAdmin.distributionPoint.toLowerCase() == 'all') {
                          // Show all areas for Super Admin
                          displayAreas = displayAreas;
                        } else {
                        final adminPoint = currentAdmin.distributionPoint.toLowerCase();
                        final filtered = displayAreas.where((area) {
                          final areaName = area.areaName.toLowerCase();
                          final matches = areaName.contains(adminPoint) || adminPoint.contains(areaName);
                          if (matches) {
                            print('✅ Matched area: ${area.areaName} with admin point: ${currentAdmin.distributionPoint}');
                          }
                          return matches;
                        }).toList();
                        
                        // If filtered list is not empty, use it; otherwise show all areas as fallback
                        if (filtered.isNotEmpty) {
                          displayAreas = filtered;
                          print('📊 Using filtered areas: ${displayAreas.length}');
                        } else {
                          print('⚠️ No areas matched admin point "${currentAdmin.distributionPoint}" - showing all ${displayAreas.length} areas as fallback');
                          }
                        }
                        
                        print('📊 Admin distribution point: ${currentAdmin.distributionPoint}');
                        print('📊 Total areas from Firestore: ${snapshot.data?.length ?? 0}');
                        print('📊 Final display areas count: ${displayAreas.length}');
                      } else {
                        if (currentAdmin == null) {
                          print('⚠️ No admin logged in - showing all areas');
                        } else if (currentAdmin.distributionPoint.isEmpty) {
                          print('⚠️ Admin has no distribution point - showing all areas');
                        } else {
                          print('⚠️ No areas loaded - displayAreas is empty');
                        }
                      }
                      // If no admin or no distribution point, show all areas (no filtering)
                      
                      return DropdownButtonFormField<String>(
                        value: _selectedDistributionArea,
                        isExpanded: true,
                        decoration: InputDecoration(
                          border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          filled: true,
                          fillColor: Colors.white,
                          hintText: displayAreas.isEmpty 
                              ? AppLanguage.translate('No areas available')
                              : AppLanguage.translate('Select Distribution Area'),
                        ),
                        items: displayAreas.isEmpty
                            ? [
                                DropdownMenuItem(
                                  value: null,
                                  enabled: false,
                                  child: Text(
                                    AppLanguage.translate('No areas available'),
                                    style: TextStyle(color: Colors.grey[600]),
                                  ),
                                ),
                              ]
                            : [
                                if (displayAreas.length > 1)
                                  DropdownMenuItem<String>(
                                    value: null,
                                    child: Text(AppLanguage.translate('All Areas')),
                                  ),
                                ...displayAreas.map((area) {
                                  return DropdownMenuItem<String>(
                                    value: area.id,
                                    child: Text(
                                      area.fullName,
                                      overflow: TextOverflow.ellipsis,
                                      maxLines: 1,
                                    ),
                                  );
                                }).toList(),
                              ],
                        selectedItemBuilder: (context) {
                          if (displayAreas.isEmpty) {
                            return [
                              Text(
                                AppLanguage.translate('No areas available'),
                                style: TextStyle(color: Colors.grey[600]),
                              ),
                            ];
                          }
                          return [
                            if (displayAreas.length > 1)
                              Text(AppLanguage.translate('All Areas')),
                            ...displayAreas.map((area) {
                              return Text(
                                area.fullName,
                                overflow: TextOverflow.ellipsis,
                                maxLines: 1,
                              );
                            }).toList(),
                          ];
                        },
                        onChanged: displayAreas.isEmpty ? null : (value) {
                          print('🔄 Distribution area changed to: $value');
                          setState(() {
                            _selectedDistributionArea = value;
                          });
                        },
                      );
                    },
                  ),
                ],
              ],
            ),
          ),
          // Search Field
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
            color: Colors.white,
            child: TextField(
              controller: _searchController,
              textDirection: TextDirection.ltr, // Allow both LTR and RTL
              keyboardType: TextInputType.text, // Use text input to support all characters including Arabic
              decoration: InputDecoration(
                hintText: AppLanguage.translate('Search by name or ID'),
                prefixIcon: const Icon(Icons.search),
                suffixIcon: _searchController.text.isNotEmpty
                    ? IconButton(
                        icon: const Icon(Icons.clear),
                        onPressed: () {
                          setState(() {
                            _searchController.clear();
                          });
                        },
                      )
                    : null,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                  borderSide: const BorderSide(color: Color(0xFFE0E0E0)),
                ),
                filled: true,
                fillColor: Colors.grey[50],
                contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
              ),
              onChanged: (value) {
                setState(() {});
              },
            ),
          ),
          // Beneficiaries List - Load from Firebase filtered by selected area with pagination
          Expanded(
            child: StreamBuilder<List<Beneficiary>>(
              key: ValueKey<String?>('${_selectedDistributionArea}_${_searchController.text}'), // Force rebuild when area or search changes
              stream: _selectedDistributionArea != null
                  ? BeneficiaryService.getBeneficiariesByArea(
                      _selectedDistributionArea!, 
                      limit: _searchController.text.isNotEmpty ? null : _initialLoadLimit, // Load all when searching, paginated otherwise
                      activeOnly: true,
                    )
                  : BeneficiaryService.getAllBeneficiaries(
                      limit: _searchController.text.isNotEmpty ? null : _initialLoadLimit, // Load all when searching, paginated otherwise
                      activeOnly: true,
                    ),
              builder: (context, snapshot) {
                if (snapshot.connectionState == ConnectionState.waiting && !snapshot.hasData) {
                  return const Center(child: CircularProgressIndicator());
                }

                if (snapshot.hasError) {
                  return Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        const Icon(Icons.error_outline, color: Colors.red, size: 48),
                        const SizedBox(height: 16),
                        Text(
                          'Error loading beneficiaries: ${snapshot.error}',
                          style: const TextStyle(color: Colors.red),
                          textAlign: TextAlign.center,
                        ),
                      ],
                    ),
                  );
                }

                final allBeneficiaries = snapshot.data ?? [];
                // Filter by admin's areas and search query (area filtering is already done by Firestore if area is selected)
                final filtered = _filterBeneficiaries(allBeneficiaries);

                if (filtered.isEmpty) {
                  return Center(
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(
                          Icons.people_outline,
                          size: 64,
                          color: Colors.grey[400],
                        ),
                        const SizedBox(height: 16),
                        Text(
                          _selectedDistributionArea == null && _searchController.text.isEmpty
                              ? AppLanguage.translate('No beneficiaries yet')
                              : AppLanguage.translate('No beneficiaries found'),
                          style: TextStyle(color: Colors.grey[700], fontSize: 16),
                          textAlign: TextAlign.center,
                        ),
                      ],
                    ),
                  );
                }

                return ListView.builder(
                  controller: _scrollController,
                  itemCount: filtered.length + (_isLoadingMore ? 1 : 0),
                  cacheExtent: 500, // Cache more items for smoother scrolling
                  itemBuilder: (context, index) {
                    if (index >= filtered.length) {
                      return const Center(
                        child: Padding(
                          padding: EdgeInsets.all(16.0),
                          child: CircularProgressIndicator(),
                        ),
                      );
                    }
                    final beneficiary = filtered[index];
                    return Card(
                      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
                      child: ListTile(
                        title: Text(
                          beneficiary.name,
                          style: const TextStyle(fontWeight: FontWeight.w500),
                        ),
                        subtitle: Column(
                          mainAxisSize: MainAxisSize.min,
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              'ID: ${beneficiary.idNumber}',
                              style: const TextStyle(fontSize: 12),
                            ),
                            if (beneficiary.mobileNumber != null)
                              Text(
                                'Mobile: ${beneficiary.mobileNumber}',
                                style: const TextStyle(fontSize: 12),
                              ),
                            Text(
                              'Status: ${beneficiary.status}',
                              style: const TextStyle(fontSize: 12),
                            ),
                            if (beneficiary.createdBy != null && beneficiary.createdBy!.isNotEmpty)
                              FutureBuilder<Admin?>(
                                future: AdminService.getAdminById(beneficiary.createdBy!),
                                builder: (context, snapshot) {
                                  if (snapshot.connectionState == ConnectionState.waiting) {
                                    return const SizedBox.shrink();
                                  }
                                  final admin = snapshot.data;
                                  final createdByText = admin != null 
                                      ? 'Created by: ${admin.fullName}'
                                      : beneficiary.createdBy == 'guest' 
                                          ? 'Created by: Guest'
                                          : beneficiary.createdBy == 'system'
                                              ? 'Created by: System'
                                              : 'Created by: ${beneficiary.createdBy}';
                                  return Text(
                                    createdByText,
                                    style: TextStyle(
                                      fontSize: 11,
                                      color: Colors.grey[600],
                                      fontStyle: FontStyle.italic,
                                    ),
                                    maxLines: 1,
                                    overflow: TextOverflow.ellipsis,
                                  );
                                },
                              ),
                          ],
                        ),
                        trailing: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            if (beneficiary.queueNumber != null)
                              Chip(
                                label: Text('Q#${beneficiary.queueNumber}'),
                                backgroundColor: const Color(0xFF81CF01).withOpacity(0.2),
                                labelStyle: const TextStyle(fontSize: 12),
                              ),
                            IconButton(
                              icon: const Icon(Icons.edit, color: Colors.orange),
                              tooltip: 'Update',
                              onPressed: () {
                                Navigator.of(context).push(
                                  MaterialPageRoute(
                                    builder: (context) => BeneficiaryDetailsScreen(
                                      beneficiary: beneficiary,
                                      beneficiaryIndex: -1,
                                      availableQueues: widget.queues,
                                      distributionAreas: widget.distributionAreas,
                                      entities: widget.entities,
                                      onBeneficiaryUpdated: (updatedBeneficiary) async {
                                        // Update in Firebase
                                        await BeneficiaryService.updateBeneficiary(
                                          updatedBeneficiary.id,
                                          updatedBeneficiary,
                                        );
                                        // Call the callback
                                        widget.onBeneficiaryUpdated(updatedBeneficiary);
                                        if (mounted) {
                                          ScaffoldMessenger.of(context).showSnackBar(
                                            const SnackBar(
                                              content: Text('Beneficiary updated successfully'),
                                              backgroundColor: Colors.green,
                                            ),
                                          );
                                        }
                                      },
                                      onBeneficiaryDeleted: () {},
                                      onEntityAdded: widget.onEntityAdded,
                                    ),
                                  ),
                                );
                              },
                            ),
                            IconButton(
                              icon: const Icon(Icons.delete, color: Colors.red),
                              tooltip: 'Delete',
                              onPressed: () {
                                // Store parent context before showing dialog
                                final parentContext = context;
                                
                                // Show confirmation dialog
                                showDialog(
                                  context: context,
                                  builder: (dialogContext) => AlertDialog(
                                    title: const Text('Confirm Delete'),
                                    content: Text(
                                      'Are you sure you want to delete ${beneficiary.name}? This action cannot be undone.',
                                    ),
                                    actions: [
                                      TextButton(
                                        onPressed: () => Navigator.pop(dialogContext),
                                        child: const Text('Cancel'),
                                      ),
                                      ElevatedButton(
                                        onPressed: () async {
                                          // Close confirmation dialog first
                                          Navigator.pop(dialogContext);
                                          
                                          // Show loading indicator using parent context
                                          showDialog(
                                            context: parentContext,
                                            barrierDismissible: false,
                                            builder: (loadingContext) => const Center(
                                              child: CircularProgressIndicator(),
                                            ),
                                          );
                                          
                                          try {
                                            // Delete from Firebase
                                            await BeneficiaryService.deleteBeneficiary(beneficiary.id);
                                            
                                            // Close loading dialog
                                            if (mounted && Navigator.of(parentContext).canPop()) {
                                              Navigator.of(parentContext).pop();
                                            }
                                            
                                            // Show success message
                                            if (mounted) {
                                              ScaffoldMessenger.of(parentContext).showSnackBar(
                                                const SnackBar(
                                                  content: Text('Beneficiary deleted successfully'),
                                                  backgroundColor: Colors.green,
                                                ),
                                              );
                                            }
                                          } catch (e) {
                                            // Close loading dialog
                                            if (mounted && Navigator.of(parentContext).canPop()) {
                                              Navigator.of(parentContext).pop();
                                            }
                                            
                                            // Show error message
                                            if (mounted) {
                                              ScaffoldMessenger.of(parentContext).showSnackBar(
                                                SnackBar(
                                                  content: Text('Error deleting beneficiary: $e'),
                                                  backgroundColor: Colors.red,
                                                ),
                                              );
                                            }
                                          }
                                        },
                                        style: ElevatedButton.styleFrom(
                                          backgroundColor: Colors.red,
                                          foregroundColor: Colors.white,
                                        ),
                                        child: const Text('Delete'),
                                      ),
                                    ],
                                  ),
                                );
                              },
                            ),
                          ],
                        ),
                      ),
                    );
                  },
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}

// Beneficiary Details Screen
class BeneficiaryDetailsScreen extends StatefulWidget {
  final Beneficiary beneficiary;
  final int beneficiaryIndex;
  final List<Queue> availableQueues;
  final List<DistributionArea> distributionAreas;
  final List<String> entities;
  final Function(Beneficiary) onBeneficiaryUpdated;
  final VoidCallback onBeneficiaryDeleted;
  final Function(String) onEntityAdded;

  const BeneficiaryDetailsScreen({
    super.key,
    required this.beneficiary,
    required this.beneficiaryIndex,
    required this.availableQueues,
    required this.distributionAreas,
    required this.entities,
    required this.onBeneficiaryUpdated,
    required this.onBeneficiaryDeleted,
    required this.onEntityAdded,
  });

  @override
  State<BeneficiaryDetailsScreen> createState() => _BeneficiaryDetailsScreenState();
}

class _BeneficiaryDetailsScreenState extends State<BeneficiaryDetailsScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _idNumberController = TextEditingController();
  final _mobileNumberController = TextEditingController();
  final _nfcCodeController = TextEditingController();
  final _customEntityController = TextEditingController();
  final _customUnitsController = TextEditingController();
  
  String? _selectedDistributionArea;
  String? _selectedQueuePoint;
  String _type = 'Normal';
  String _gender = 'Male';
  String _status = 'Active';
  String _numberOfUnits = '1';
  bool _isEntity = false;
  String? _selectedEntity;
  bool _useCustomUnits = false;
  bool _useCustomEntity = false;
  String? _idCopyPath;
  String? _photoPath;
  DateTime? _birthDate;
  bool _nfcDetected = false; // Track if NFC tag was detected
  String? _originalNfcTagId; // Store original NFC tag ID for saving (not masked)
  String? _duplicateNFCMessage; // Track duplicate NFC tag ID message

  final List<String> _typeOptions = ['Normal', 'Child', 'Widowed', 'Divorced', 'Disability', 'Sick', 'Elderly'];
  final List<String> _genderOptions = ['Male', 'Female'];
  final List<String> _statusOptions = ['Active', 'Banned'];
  final List<String> _unitsOptions = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'];

  List<Queue> get _filteredQueues {
    if (_selectedDistributionArea == null) return [];
    return widget.availableQueues.where((q) => q.distributionArea == _selectedDistributionArea).toList();
  }

  /// Build unique queue names for dropdown, handling duplicates
  List<String> get _uniqueQueueNames {
    final queues = _filteredQueues;
    final seen = <String>{};
    final uniqueNames = <String>[];
    
    for (final queue in queues) {
      final name = queue.name;
      if (!seen.contains(name)) {
        seen.add(name);
        uniqueNames.add(name);
      }
    }
    
    return uniqueNames;
  }

  @override
  void initState() {
    super.initState();
    _nameController.text = widget.beneficiary.name;
    _idNumberController.text = widget.beneficiary.idNumber;
    _mobileNumberController.text = widget.beneficiary.mobileNumber ?? '';
    // Load existing NFC code - if it exists, store it as original and display masked
    final existingNfcCode = widget.beneficiary.nfcPreprintedCode ?? '';
    if (existingNfcCode.isNotEmpty) {
      _originalNfcTagId = existingNfcCode;
      _nfcCodeController.text = NFCHelper.maskNfcTagId(existingNfcCode);
    } else {
      _nfcCodeController.text = '';
    }
    // Validate distribution area exists in the list
    final beneficiaryAreaId = widget.beneficiary.distributionArea;
    if (widget.distributionAreas.isNotEmpty && beneficiaryAreaId.isNotEmpty) {
      final areaExists = widget.distributionAreas.any((area) => area.id == beneficiaryAreaId);
      _selectedDistributionArea = areaExists ? beneficiaryAreaId : null;
    } else {
      _selectedDistributionArea = null;
    }
    // Set selected queue point, but validate it will be unique in dropdown
    final beneficiaryQueuePoint = widget.beneficiary.initialAssignedQueuePoint;
    if (beneficiaryQueuePoint.isNotEmpty) {
      // We'll validate this in the dropdown builder to ensure it's unique
      _selectedQueuePoint = beneficiaryQueuePoint;
    } else {
      _selectedQueuePoint = null;
    }
    // Add null safety checks for enum-like fields
    _type = _typeOptions.contains(widget.beneficiary.type) ? widget.beneficiary.type : 'Normal';
    _gender = _genderOptions.contains(widget.beneficiary.gender) ? widget.beneficiary.gender : 'Male';
    _status = _statusOptions.contains(widget.beneficiary.status) ? widget.beneficiary.status : 'Active';
    // Ensure numberOfUnits is valid - if not in options, use '1' as default
    final beneficiaryUnits = widget.beneficiary.numberOfUnits;
    _numberOfUnits = (beneficiaryUnits.isNotEmpty && _unitsOptions.contains(beneficiaryUnits)) ? beneficiaryUnits : '1';
    _isEntity = widget.beneficiary.isEntity;
    _selectedEntity = widget.beneficiary.entityName;
    _idCopyPath = widget.beneficiary.idCopyPath;
    _photoPath = widget.beneficiary.photoPath;
    _birthDate = widget.beneficiary.birthDate;
  }

  @override
  void dispose() {
    // Stop NFC session if active
    NFCHelper.stopNFCSession();
    _nameController.dispose();
    _idNumberController.dispose();
    _mobileNumberController.dispose();
    _nfcCodeController.dispose();
    _customEntityController.dispose();
    _customUnitsController.dispose();
    super.dispose();
  }

  Future<void> _handleUpdate() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }

    if (_selectedDistributionArea == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select a distribution area')),
      );
      return;
    }

    // Prevent saving if there's a duplicate NFC message
    if (_duplicateNFCMessage != null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(_duplicateNFCMessage!),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 4),
        ),
      );
      return;
    }

    // Check for duplicate NFC tag ID before proceeding (exclude current beneficiary)
    // Get NFC code to check - prefer original, but if manually entered, use the text field value
    String? nfcCodeToCheck = _originalNfcTagId;
    if (nfcCodeToCheck == null || nfcCodeToCheck.isEmpty) {
      final textFieldValue = _nfcCodeController.text.trim();
      if (textFieldValue.isNotEmpty) {
        // If the text contains asterisks, it's masked - we can't validate it properly
        // In this case, we should ask user to scan the card again
        if (textFieldValue.contains('*')) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Please scan the NFC card again. Manual entry of masked NFC codes is not allowed.'),
              backgroundColor: Colors.orange,
              duration: Duration(seconds: 3),
            ),
          );
          return;
        }
        nfcCodeToCheck = textFieldValue;
      }
    }

    if (nfcCodeToCheck != null && nfcCodeToCheck.isNotEmpty) {
      final existingNfcBeneficiary = await BeneficiaryService.getBeneficiaryByNFC(nfcCodeToCheck);
      // Only show error if it's a different beneficiary (not the one being updated)
      if (existingNfcBeneficiary != null && existingNfcBeneficiary.id != widget.beneficiary.id) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('This NFC card is already registered to: ${existingNfcBeneficiary.name} (ID: ${existingNfcBeneficiary.idNumber})'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 4),
          ),
        );
        return;
      }
    }

    String entityName = '';
    if (_isEntity) {
      if (_useCustomEntity) {
        if (_customEntityController.text.isEmpty) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Please enter entity name')),
          );
          return;
        }
        entityName = _customEntityController.text;
        widget.onEntityAdded(entityName);
      } else {
        entityName = _selectedEntity ?? '';
      }
    }

    String units = _numberOfUnits;
    if (_useCustomUnits) {
      if (_customUnitsController.text.isEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Please enter number of units')),
        );
        return;
      }
      units = _customUnitsController.text;
    }

    // Show loading dialog
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const Center(child: CircularProgressIndicator()),
    );

    try {
      final updated = widget.beneficiary.copyWith(
        distributionArea: _selectedDistributionArea!,
        initialAssignedQueuePoint: _selectedQueuePoint ?? '',
        name: _nameController.text,
        idNumber: _idNumberController.text,
        mobileNumber: _mobileNumberController.text, // Required field - validated by form
        type: _type,
        gender: _gender,
        status: _status,
        numberOfUnits: units,
        isEntity: _isEntity,
        entityName: _isEntity ? entityName : null,
        nfcPreprintedCode: _originalNfcTagId ?? (_nfcCodeController.text.isNotEmpty ? _nfcCodeController.text : null),
        idCopyPath: _idCopyPath,
        photoPath: _photoPath,
        birthDate: _birthDate,
      );

      // Update in Firebase
      await BeneficiaryService.updateBeneficiary(widget.beneficiary.id, updated);

      // Close loading dialog safely
      if (mounted && Navigator.of(context).canPop()) {
        Navigator.of(context).pop(); // Close loading dialog
      }

      // Call callback safely
      try {
        widget.onBeneficiaryUpdated(updated);
      } catch (e, stackTrace) {
        print('Error in onBeneficiaryUpdated callback: $e');
        print('Stack trace: $stackTrace');
        // Don't crash - continue with success message
      }

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Beneficiary updated successfully'),
            backgroundColor: Colors.green,
          ),
        );
        // Close edit screen safely
        if (Navigator.of(context).canPop()) {
          Navigator.of(context).pop(); // Close edit screen
        }
      }
    } catch (e, stackTrace) {
      // Close loading dialog safely
      if (mounted && Navigator.of(context).canPop()) {
        Navigator.of(context).pop(); // Close loading dialog
      }
      
      print('Error updating beneficiary: $e');
      print('Stack trace: $stackTrace');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error updating beneficiary: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _checkDuplicateNFC(String nfcCode) async {
    if (nfcCode.isEmpty) {
      setState(() {
        _duplicateNFCMessage = null;
      });
      return;
    }

    // Check if NFC code already exists in Firestore
    try {
      final existingBeneficiary = await BeneficiaryService.getBeneficiaryByNFC(nfcCode);
      
      if (existingBeneficiary != null) {
        // Only show error if it's a different beneficiary (not the one being edited)
        if (existingBeneficiary.id != widget.beneficiary.id) {
          setState(() {
            _duplicateNFCMessage = 'This NFC card is already registered to: ${existingBeneficiary.name} (ID: ${existingBeneficiary.idNumber})';
          });
        } else {
          // Same beneficiary - no duplicate
          setState(() {
            _duplicateNFCMessage = null;
          });
        }
      } else {
        // NFC code not found - no duplicate
        setState(() {
          _duplicateNFCMessage = null;
        });
      }
    } catch (e) {
      print('Error checking duplicate NFC: $e');
      setState(() {
        _duplicateNFCMessage = null;
      });
    }
  }

  Widget _buildLabel(String text) {
    return Text(
      AppLanguage.translate(text),
      style: const TextStyle(fontSize: 14, fontWeight: FontWeight.w500, color: Color(0xFF1A237E)),
    );
  }

  InputDecoration _buildInputDecoration(String hint) {
    return InputDecoration(
      hintText: AppLanguage.translate(hint),
      border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
      filled: true,
      fillColor: Colors.white,
    );
  }

  Widget _buildDropdown(String value, List<String> items, Function(String?) onChanged) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        border: Border.all(color: const Color(0xFFE0E0E0)),
        borderRadius: BorderRadius.circular(8),
        color: Colors.white,
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: items.contains(value) ? value : (items.isNotEmpty ? items.first : null),
          isExpanded: true,
          items: items.map((item) => DropdownMenuItem(value: item, child: Text(AppLanguage.translate(item)))).toList(),
          onChanged: onChanged,
        ),
      ),
    );
  }

  Widget _buildDistributionAreaDropdown() {
    return StreamBuilder<List<DistributionArea>>(
      stream: DistributionAreaService.getAllAreas(),
      builder: (context, snapshot) {
        List<DistributionArea> displayAreas = [];
        
        if (snapshot.connectionState == ConnectionState.waiting && snapshot.data == null) {
          displayAreas = widget.distributionAreas;
        } else if (snapshot.hasError) {
          print('StreamBuilder error: ${snapshot.error}');
          displayAreas = widget.distributionAreas;
        } else {
          final firestoreAreas = snapshot.data ?? [];
          displayAreas = firestoreAreas.isNotEmpty ? firestoreAreas : widget.distributionAreas;
        }
        
        // Validate selected area exists in the list
        String? validSelectedArea = _selectedDistributionArea;
        if (validSelectedArea != null) {
          final exists = displayAreas.any((area) => area.id == validSelectedArea);
          if (!exists) {
            // Selected area doesn't exist, reset it
            WidgetsBinding.instance.addPostFrameCallback((_) {
              if (mounted) {
                setState(() {
                  _selectedDistributionArea = null;
                });
              }
            });
            validSelectedArea = null;
          }
        }
        
        return Container(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          decoration: BoxDecoration(
            border: Border.all(color: const Color(0xFFE0E0E0)),
            borderRadius: BorderRadius.circular(8),
            color: Colors.white,
          ),
          child: DropdownButtonHideUnderline(
            child: DropdownButton<String>(
              value: validSelectedArea,
              isExpanded: true,
              hint: const Text('Select distribution area'),
              items: displayAreas.map((area) {
                return DropdownMenuItem(
                  value: area.id,
                  child: Text(
                    area.fullName,
                    overflow: TextOverflow.ellipsis,
                    maxLines: 1,
                  ),
                );
              }).toList(),
              onChanged: (value) {
                setState(() {
                  _selectedDistributionArea = value;
                  _selectedQueuePoint = null;
                });
              },
            ),
          ),
        );
      },
    );
  }

  Widget _buildQueuePointDropdown() {
    final queues = _filteredQueues;
    // Get unique queue names to avoid duplicates - use Set to guarantee uniqueness
    final uniqueQueueNames = _uniqueQueueNames.toSet().toList();
    
    // Ensure no duplicate values in dropdown items
    final dropdownItems = <DropdownMenuItem<String>>[];
    final usedValues = <String>{};
    
    for (final queueName in uniqueQueueNames) {
      if (!usedValues.contains(queueName)) {
        usedValues.add(queueName);
        dropdownItems.add(
          DropdownMenuItem(
            value: queueName,
            child: Text(
              queueName,
              overflow: TextOverflow.ellipsis,
              maxLines: 1,
            ),
          ),
        );
      }
    }
    
    // Validate selected queue point exists exactly once in the items list
    String? validSelectedQueuePoint = _selectedQueuePoint;
    if (validSelectedQueuePoint != null && validSelectedQueuePoint.isNotEmpty) {
      // Count how many items have this value
      final matchingItems = dropdownItems.where((item) => item.value == validSelectedQueuePoint).toList();
      if (matchingItems.length != 1) {
        // Value doesn't exist or appears multiple times, reset it immediately
        // Use a synchronous check to prevent the error
        validSelectedQueuePoint = null;
        // Also update the state asynchronously to prevent future issues
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (mounted) {
            setState(() {
              _selectedQueuePoint = null;
            });
          }
        });
      }
    } else {
      validSelectedQueuePoint = null;
    }
    
    // Final safety check: ensure the value exists in items exactly once
    if (validSelectedQueuePoint != null) {
      final count = dropdownItems.where((item) => item.value == validSelectedQueuePoint).length;
      if (count != 1) {
        validSelectedQueuePoint = null;
      }
    }
    
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        border: Border.all(color: const Color(0xFFE0E0E0)),
        borderRadius: BorderRadius.circular(8),
        color: Colors.white,
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: validSelectedQueuePoint,
          isExpanded: true,
          hint: const Text('Select queue point'),
          items: dropdownItems,
          onChanged: (value) {
            setState(() {
              _selectedQueuePoint = value;
            });
          },
        ),
      ),
    );
  }

  /// Crop image to focus on ID card
  Future<CroppedFile?> _cropImage(String imagePath) async {
    try {
      final croppedFile = await ImageCropper().cropImage(
        sourcePath: imagePath,
        aspectRatio: const CropAspectRatio(ratioX: 1.6, ratioY: 1.0), // ID card aspect ratio (approximately)
        uiSettings: [
          AndroidUiSettings(
            toolbarTitle: AppLanguage.translate('Crop ID Card'),
            toolbarColor: const Color(0xFF1A237E),
            toolbarWidgetColor: Colors.white,
            initAspectRatio: CropAspectRatioPreset.original,
            lockAspectRatio: false, // Allow free-form cropping
            aspectRatioPresets: [
              CropAspectRatioPreset.original,
              CropAspectRatioPreset.ratio16x9,
              CropAspectRatioPreset.ratio4x3,
            ],
            backgroundColor: Colors.black,
            activeControlsWidgetColor: const Color(0xFF1A237E),
            dimmedLayerColor: Colors.black.withOpacity(0.8),
            cropFrameColor: Colors.white,
            cropGridColor: Colors.white.withOpacity(0.5),
            cropFrameStrokeWidth: 2,
            cropGridStrokeWidth: 1,
            showCropGrid: true,
            hideBottomControls: false,
          ),
          IOSUiSettings(
            title: AppLanguage.translate('Crop ID Card'),
            aspectRatioLockEnabled: false,
            resetAspectRatioEnabled: true,
            aspectRatioPresets: [
              CropAspectRatioPreset.original,
              CropAspectRatioPreset.square,
              CropAspectRatioPreset.ratio16x9,
            ],
            rotateButtonsHidden: false,
            rotateClockwiseButtonHidden: false,
            hidesNavigationBar: false,
            showCancelConfirmationDialog: true,
          ),
        ],
      );
      return croppedFile;
    } catch (e) {
      print('Error cropping image: $e');
      return null;
    }
  }

  Future<void> _scanID() async {
    try {
      // Show dialog to choose image source (camera or gallery)
      final source = await showDialog<ImageSource>(
        context: context,
        builder: (context) => AlertDialog(
          title: Text(AppLanguage.translate('Select Image Source')),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ListTile(
                leading: const Icon(Icons.camera_alt),
                title: Text(AppLanguage.translate('Camera')),
                onTap: () => Navigator.pop(context, ImageSource.camera),
              ),
              ListTile(
                leading: const Icon(Icons.photo_library),
                title: Text(AppLanguage.translate('Gallery')),
                onTap: () => Navigator.pop(context, ImageSource.gallery),
              ),
            ],
          ),
        ),
      );

      if (source == null) return;

      // Request permissions based on source
      bool hasPermission = false;
      if (source == ImageSource.camera) {
        hasPermission = await PermissionHelper.requestCameraPermission();
      if (!hasPermission) {
        if (context.mounted) {
          await PermissionHelper.showPermissionDeniedDialog(
            context,
            AppLanguage.translate('Camera permission is required. Please enable it in app settings.'),
          );
        }
        return;
        }
      } else {
        // For gallery, request storage permission
        hasPermission = await PermissionHelper.requestStoragePermission();
        if (!hasPermission) {
          if (context.mounted) {
            await PermissionHelper.showPermissionDeniedDialog(
              context,
              AppLanguage.translate('Storage permission is required to select images from gallery.'),
            );
          }
          return;
        }
      }

      // Show loading dialog
      if (context.mounted) {
        showDialog(
          context: context,
          barrierDismissible: false,
          builder: (context) => const Center(
            child: CircularProgressIndicator(),
          ),
        );
      }

      // Get image from selected source
      final image_picker.ImagePicker picker = image_picker.ImagePicker();
      final image_picker.XFile? image = await picker.pickImage(
        source: source == ImageSource.camera 
            ? image_picker.ImageSource.camera 
            : image_picker.ImageSource.gallery,
        imageQuality: 90,
      );

      if (image == null) {
        if (context.mounted) {
          Navigator.of(context).pop(); // Close loading dialog
        }
        return;
      }

      // Close loading dialog before showing crop screen
      if (context.mounted) {
        Navigator.of(context).pop();
      }

      // Show image cropping screen to allow user to focus on ID card
      final croppedFile = await _cropImage(image.path);
      if (croppedFile == null) {
        // User cancelled cropping
        return;
      }

      // Save the cropped image path
      setState(() {
        _idCopyPath = croppedFile.path;
      });

      // Validate image quality first (use cropped image)
      final qualityResult = await ImageQualityValidator.validateImageQuality(croppedFile.path);
      print('📸 Image Quality Check:');
      print('  Valid: ${qualityResult['isValid']}');
      print('  Score: ${qualityResult['score']}');
      print('  Issues: ${qualityResult['issues']}');
      
      // Only block if quality is very poor (score < 0.3)
      // Otherwise, just show a warning but continue with OCR
      final qualityScore = qualityResult['score'] as double;
      if (qualityScore < 0.3) {
        if (context.mounted) {
          Navigator.of(context).pop(); // Close loading dialog
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('⚠️ ${AppLanguage.translate("Image quality is very low. Please ensure good lighting and focus.")}\n${(qualityResult['recommendations'] as List).join(", ")}'),
              backgroundColor: Colors.orange,
              duration: const Duration(seconds: 5),
            ),
          );
        }
        return;
      } else if (qualityScore < 0.6 && qualityResult['issues'] != null && (qualityResult['issues'] as List).isNotEmpty) {
        // Show warning but continue - don't block OCR for moderate quality issues
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('ℹ️ ${AppLanguage.translate("Image quality could be better, but proceeding with OCR.")}\n${(qualityResult['recommendations'] as List).take(2).join(", ")}'),
              backgroundColor: Colors.blue,
              duration: const Duration(seconds: 3),
            ),
          );
        }
      }

      // Preprocess image using Python solution approach (threshold at 95 like front.py)
      // Based on: https://github.com/OlaHamdy3/National-ID-card-reader
      String? processedImagePath = await ImageQualityValidator.preprocessImage(
        croppedFile.path, 
        useThresholding: true, 
        threshold: 95  // Python solution uses thresh = 95 for front
      );
      
      // Also try region-based extraction (like Python solution)
      final regions = await ImageQualityValidator.extractRegionsFromImage(croppedFile.path);
      print('🖼️ Extracted ${regions.length} regions: ${regions.keys.join(", ")}');

      // Perform OCR using region-based approach (like Python solution)
      String combinedText = '';
      Map<String, String> ocrResults = {}; // Store results from different approaches
      
      // Strategy 1: Region-based OCR (like Python solution - most accurate)
      if (regions.isNotEmpty) {
        print('🔍 Strategy 1: Starting region-based OCR with ${regions.length} regions');
        try {
          final ocr = FlutterNativeOcr();
          
          // Extract name from name region (like Python: image_to_string(Name, lang="ara"))
          if (regions.containsKey('nameRegion')) {
            print('🔍 Processing name region: ${regions['nameRegion']}');
            try {
              final nameText = await ocr.recognizeText(regions['nameRegion']!);
              if (nameText.isNotEmpty) {
                ocrResults['name'] = nameText;
                combinedText = '${combinedText}${nameText}\n';
                print('📝 Name Region OCR: $nameText (${nameText.length} chars)');
              } else {
                print('⚠️ Name Region OCR returned empty text');
              }
            } catch (e) {
              print('❌ Error processing name region: $e');
            }
          }
          
          // Extract address from address region (like Python: image_to_string(address, lang="ara"))
          if (regions.containsKey('addressRegion')) {
            print('🔍 Processing address region: ${regions['addressRegion']}');
            try {
              final addressText = await ocr.recognizeText(regions['addressRegion']!);
              if (addressText.isNotEmpty) {
                ocrResults['address'] = addressText;
                combinedText = '${combinedText}${addressText}\n';
                print('📝 Address Region OCR: $addressText (${addressText.length} chars)');
              } else {
                print('⚠️ Address Region OCR returned empty text');
              }
            } catch (e) {
              print('❌ Error processing address region: $e');
            }
          }
          
          // Extract ID from ID region (like Python: image_to_string(ID, lang="hin"))
          // Try both thresholded and adaptive threshold versions for better results
          if (regions.containsKey('idRegion')) {
            print('🔍 Processing ID region (thresholded): ${regions['idRegion']}');
            try {
              final idText = await ocr.recognizeText(regions['idRegion']!);
              if (idText.isNotEmpty) {
                ocrResults['id'] = idText;
                combinedText = '${combinedText}${idText}\n';
                print('📝 ID Region OCR (thresholded): $idText (${idText.length} chars)');
              } else {
                print('⚠️ ID Region OCR (thresholded) returned empty text');
              }
            } catch (e) {
              print('❌ Error processing ID region (thresholded): $e');
            }
          }
          
          // Also try adaptive threshold version if available (often better for numbers)
          if (regions.containsKey('idRegionAdaptive')) {
            print('🔍 Processing ID region (adaptive): ${regions['idRegionAdaptive']}');
            try {
              final idTextAdaptive = await ocr.recognizeText(regions['idRegionAdaptive']!);
              if (idTextAdaptive.isNotEmpty) {
                // Prefer adaptive if it has more digits or is longer
                final currentId = ocrResults['id'] ?? '';
                print('🔍 Comparing ID results: thresholded="$currentId" (${currentId.length} chars, ${RegExp(r'\d').allMatches(currentId).length} digits) vs adaptive="$idTextAdaptive" (${idTextAdaptive.length} chars, ${RegExp(r'\d').allMatches(idTextAdaptive).length} digits)');
                if (idTextAdaptive.length > currentId.length || 
                    RegExp(r'\d').allMatches(idTextAdaptive).length > RegExp(r'\d').allMatches(currentId).length) {
                  ocrResults['id'] = idTextAdaptive;
                  // Update combined text if this is better
                  if (currentId.isNotEmpty) {
                    combinedText = combinedText.replaceAll(currentId, idTextAdaptive);
                  } else {
                    combinedText = '${combinedText}${idTextAdaptive}\n';
                  }
                  print('📝 ID Region OCR (adaptive, better): $idTextAdaptive');
                } else {
                  print('📝 ID Region OCR (adaptive): $idTextAdaptive (keeping thresholded version)');
                }
              } else {
                print('⚠️ ID Region OCR (adaptive) returned empty text');
              }
            } catch (e) {
              print('❌ Error processing ID region (adaptive): $e');
            }
          }
          
          print('🔍 Strategy 1 complete. Combined text length: ${combinedText.length}');
        } catch (e, stackTrace) {
          print('❌ Region-based OCR Error: $e');
          print('Stack trace: $stackTrace');
        }
      } else {
        print('⚠️ No regions extracted - skipping region-based OCR');
      }
      
      // Strategy 2: Full image OCR with thresholded image (Python solution approach)
      if (processedImagePath != null) {
        try {
          final ocr = FlutterNativeOcr();
          final fullText = await ocr.recognizeText(processedImagePath);
          if (fullText.isNotEmpty) {
            ocrResults['full'] = fullText;
            // Combine with region results
            if (combinedText.isEmpty || fullText.length > combinedText.length * 1.5) {
              combinedText = fullText;
              print('📝 Using full image OCR (${fullText.length} chars)');
            } else {
              // Merge unique content
              final fullLines = fullText.split('\n');
              for (final line in fullLines) {
                if (line.trim().isNotEmpty && !combinedText.contains(line.trim())) {
                  combinedText = '$combinedText\n${line.trim()}';
                }
              }
            }
          }
        } catch (e) {
          print('❌ Full Image OCR Error: $e');
        }
      }
      
      // Strategy 3: Original image OCR (fallback if region extraction failed)
      if (combinedText.isEmpty || !RegExp(r'[أ-ي]').hasMatch(combinedText)) {
        try {
          final ocr = FlutterNativeOcr();
          final originalText = await ocr.recognizeText(croppedFile.path);
          if (originalText.isNotEmpty) {
            final originalHasArabic = RegExp(r'[أ-ي]').hasMatch(originalText);
            if (originalHasArabic && (combinedText.isEmpty || !RegExp(r'[أ-ي]').hasMatch(combinedText))) {
              combinedText = originalText;
              print('📝 Using original image OCR (better Arabic detection)');
            } else if (combinedText.isEmpty) {
              combinedText = originalText;
            }
            print('📝 Original Image OCR Text Length: ${originalText.length}');
          }
        } catch (e) {
          print('❌ Original Image OCR Error: $e');
        }
      }
      
      // Check if OCR text is too short or doesn't contain meaningful content
      final trimmedText = combinedText.trim();
      print('🔍 Final combined text length: ${trimmedText.length}');
      print('🔍 Final combined text (first 200 chars): ${trimmedText.substring(0, trimmedText.length > 200 ? 200 : trimmedText.length)}');
      
      if (trimmedText.length < 10) {
        print('❌ OCR text too short (${trimmedText.length} chars) - blocking processing');
        if (mounted && context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('⚠️ ${AppLanguage.translate("OCR failed to detect text. Please ensure:")}\n• Good lighting\n• Card is flat and in focus\n• No glare or shadows\n• Card fills most of the frame'),
              backgroundColor: Colors.orange,
              duration: const Duration(seconds: 6),
            ),
          );
        }
        return;
      }
      
      // Check if OCR text contains Arabic characters or numbers (ID numbers are important even without Arabic)
      final hasArabic = RegExp(r'[أ-ي]').hasMatch(trimmedText);
      final hasLongNumbers = RegExp(r'\d{8,}').hasMatch(trimmedText); // Check for sequences of 8+ digits (could be ID)
      final hasAnyNumbers = RegExp(r'\d').hasMatch(trimmedText); // Check for any digits
      
      print('🔍 Text analysis: Arabic=$hasArabic, LongNumbers=$hasLongNumbers, AnyNumbers=$hasAnyNumbers, Length=${trimmedText.length}');
      
      // Even if text is short, try to extract ID if it has numbers
      // Don't block processing if we have any numbers - they might be part of the ID
      if (!hasArabic && !hasLongNumbers && !hasAnyNumbers && trimmedText.length < 50) {
        // If no Arabic and no numbers at all and text is very short, likely OCR failed
        print('⚠️ Warning: No Arabic text or numbers detected in OCR result. Text: $trimmedText');
        if (mounted && context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('⚠️ ${AppLanguage.translate("OCR did not detect Arabic text. The image may be blurry or the card may not be fully visible. Please try again with better lighting and focus.")}'),
              backgroundColor: Colors.orange,
              duration: const Duration(seconds: 6),
            ),
          );
        }
        // Still try to parse - might find something
      }
      
      // If we have numbers but no Arabic, still try to extract ID (might be partial OCR)
      if (!hasArabic && (hasLongNumbers || hasAnyNumbers)) {
        print('⚠️ Warning: No Arabic text detected, but found numbers. Attempting ID extraction anyway...');
      }
      
      try {
        // ALWAYS try to parse the extracted text - even if it's short, we might find an ID number
        print('🔍 Calling parseIDText with text length: ${combinedText.length}');
        final parsedData = IDParser.parseIDText(combinedText);

        // Auto-fill form fields with extracted data
        if (mounted) {
        setState(() {
          if (parsedData['idNumber'] != null) {
            _idNumberController.text = parsedData['idNumber'] as String;
          }
          
          if (parsedData['name'] != null) {
              final name = parsedData['name'] as String;
              // Additional validation: ensure it's not an alphanumeric code
              if (!RegExp(r'^[A-Z]{1,3}\d{4,}$').hasMatch(name.trim()) && 
                  !RegExp(r'^[A-Z]{2,}\d+$').hasMatch(name.trim()) &&
                  name.length >= 3) {
                _nameController.text = name;
              } else {
                print('⚠️ Skipped invalid name (looks like code): $name');
              }
          }
          
          if (parsedData['birthDate'] != null) {
            _birthDate = parsedData['birthDate'] as DateTime;
            // Auto-detect Elderly if birth date is before January 1, 1965
            final elderlyThreshold = DateTime(1965, 1, 1);
            if (_birthDate!.isBefore(elderlyThreshold)) {
              _type = 'Elderly';
            }
          }
          
          if (parsedData['gender'] != null) {
            _gender = parsedData['gender'] as String;
          }
        });
        }

        if (mounted && context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(AppLanguage.translate('ID scanned successfully')),
              backgroundColor: Colors.green,
            ),
          );
        }
      } catch (e, stackTrace) {
        print('Error parsing OCR text: $e');
        print('Stack trace: $stackTrace');
        if (mounted && context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error processing image: ${e.toString()}'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    } catch (e, stackTrace) {
      print('Error scanning ID: $e');
      print('Stack trace: $stackTrace');
      if (mounted && context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error scanning ID: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _takePhoto() async {
    final source = await showDialog<ImageSource>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(AppLanguage.translate('Select Photo Source')),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.camera_alt),
              title: Text(AppLanguage.translate('Camera')),
              onTap: () => Navigator.pop(context, ImageSource.camera),
            ),
            ListTile(
              leading: const Icon(Icons.photo_library),
              title: Text(AppLanguage.translate('Gallery')),
              onTap: () => Navigator.pop(context, ImageSource.gallery),
            ),
          ],
        ),
      ),
    );
    if (source == null) return;

    try {
      // Request permissions based on source
      bool hasPermission = false;
      if (source == ImageSource.camera) {
        hasPermission = await PermissionHelper.requestCameraPermission();
        if (!hasPermission) {
          if (context.mounted) {
            await PermissionHelper.showPermissionDeniedDialog(
              context,
              AppLanguage.translate('Camera permission is required. Please enable it in app settings.'),
            );
          }
          return;
        }
      } else {
        hasPermission = await PermissionHelper.requestStoragePermission();
        if (!hasPermission) {
          if (context.mounted) {
            await PermissionHelper.showPermissionDeniedDialog(
              context,
              AppLanguage.translate('Storage permission is required. Please enable it in app settings.'),
            );
          }
          return;
        }
      }

      // Use image_picker to get the image
      final image_picker.ImagePicker picker = image_picker.ImagePicker();
      final image_picker.XFile? image = await picker.pickImage(
        source: source == ImageSource.camera 
            ? image_picker.ImageSource.camera 
            : image_picker.ImageSource.gallery,
        imageQuality: 85,
      );

      // Check if widget is still mounted after async operation
      if (!mounted) return;

      if (image != null) {
        try {
          // Validate that the file path exists (skip check on web)
          if (!kIsWeb) {
            final file = File(image.path);
            final fileExists = await file.exists();
            
            if (!fileExists) {
              if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text(AppLanguage.translate('Error: Image file not found')),
                    backgroundColor: Colors.red,
                  ),
                );
              }
              return;
            }
          }
          
          // Set the photo path
          if (mounted) {
            setState(() {
              _photoPath = image.path;
            });
          }
          
          // Show success message
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(AppLanguage.translate(
                  source == ImageSource.camera ? 'Photo taken successfully' : 'Photo selected successfully'
                )),
                backgroundColor: Colors.green,
              ),
            );
          }
        } catch (fileError) {
          // If file check fails, still try to set the path (might work on some platforms)
          print('File check error (non-critical): $fileError');
          if (mounted) {
            setState(() {
              _photoPath = image.path;
            });
            
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(AppLanguage.translate(
                  source == ImageSource.camera ? 'Photo taken successfully' : 'Photo selected successfully'
                )),
                backgroundColor: Colors.green,
              ),
            );
          }
        }
      }
    } catch (e, stackTrace) {
      print('Error taking/selecting photo: $e');
      print('Stack trace: $stackTrace');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: ${e.toString()}'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 3),
          ),
        );
      }
    }
  }

  Future<void> _scanNFCCard() async {
    try {
      // Check if NFC is available
      final isAvailable = await NFCHelper.isNFCAvailable();
      if (!isAvailable) {
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(AppLanguage.translate('NFC is not available on this device')),
              backgroundColor: Colors.orange,
            ),
          );
        }
        return;
      }

      // Start NFC session
      NFCHelper.startNFCSession(
        context: context,
        onTagDetected: (id) {
          if (mounted) {
            setState(() {
              // Store original NFC tag ID for saving
              _originalNfcTagId = id;
              // Display masked NFC tag ID to user
              _nfcCodeController.text = NFCHelper.maskNfcTagId(id);
              _nfcDetected = true; // Mark as detected
            });
            
            // Check for duplicate NFC tag ID
            _checkDuplicateNFC(id);
            
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(AppLanguage.translate('NFC card detected')),
                backgroundColor: Colors.green,
              ),
            );
          }
        },
        onError: (error) {
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(error),
                backgroundColor: Colors.red,
              ),
            );
          }
        },
      );
    } catch (e, stackTrace) {
      print('Error scanning NFC: $e');
      print('Stack trace: $stackTrace');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    const darkBlue = Color(0xFF1A237E);
    const tealGreen = Color(0xFF81CF01);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Edit Beneficiary'),
        backgroundColor: tealGreen,
        foregroundColor: Colors.white,
      ),
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Color(0xFFE8F5E9), Colors.white],
          ),
        ),
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(20.0),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Edit Beneficiary',
                  style: TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                    color: darkBlue,
                  ),
                ),
                const SizedBox(height: 32),
                _buildLabel('Distribution Area *'),
                const SizedBox(height: 8),
                _buildDistributionAreaDropdown(),
                if (_selectedDistributionArea != null) ...[
                  const SizedBox(height: 24),
                  _buildLabel('Initial Assigned Queue Point'),
                  const SizedBox(height: 8),
                  _buildQueuePointDropdown(),
                ],
                const SizedBox(height: 24),
                _buildLabel('ID Copy'),
                const SizedBox(height: 8),
                Row(
                  children: [
                    Expanded(
                      child: ElevatedButton.icon(
                        onPressed: () async {
                          final result = await Navigator.push<String>(
                            context,
                            MaterialPageRoute(
                              builder: (context) => const LiveTextDetectionScreen(),
                            ),
                          );
                          
                          // Handle the returned text from Live Text Detection
                          if (result != null && result.isNotEmpty) {
                            _processLiveTextDetectionResult(result);
                          }
                        },
                        icon: const Icon(Icons.camera_alt, size: 18),
                        label: Text(
                          AppLanguage.translate('Scan National ID'),
                          style: const TextStyle(fontSize: 11),
                        ),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.blue,
                          foregroundColor: Colors.white,
                          padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 6),
                        ),
                      ),
                    ),
                    if (_idCopyPath != null) ...[
                      const SizedBox(width: 8),
                      const Icon(Icons.check_circle, color: Colors.green, size: 24),
                    ],
                  ],
                ),
                const SizedBox(height: 24),
                _buildLabel('Type *'),
                const SizedBox(height: 8),
                _buildDropdown(_type, _typeOptions, (value) => setState(() => _type = value ?? 'Normal')),
                const SizedBox(height: 24),
                _buildLabel('Gender *'),
                const SizedBox(height: 8),
                Row(
                  children: [
                    Expanded(
                      child: RadioListTile<String>(
                        title: Text(AppLanguage.translate('Male')),
                        value: 'Male',
                        groupValue: _gender,
                        onChanged: (value) => setState(() => _gender = value ?? 'Male'),
                        contentPadding: EdgeInsets.zero,
                        dense: true,
                      ),
                    ),
                    Expanded(
                      child: RadioListTile<String>(
                        title: Text(AppLanguage.translate('Female')),
                        value: 'Female',
                        groupValue: _gender,
                        onChanged: (value) => setState(() => _gender = value ?? 'Female'),
                        contentPadding: EdgeInsets.zero,
                        dense: true,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 24),
                _buildLabel('Name *'),
                const SizedBox(height: 8),
                TextFormField(
                  controller: _nameController,
                  decoration: _buildInputDecoration('Enter name'),
                  validator: (value) => value?.isEmpty ?? true ? AppLanguage.translate('Please enter name') : null,
                ),
                const SizedBox(height: 24),
                _buildLabel('ID Number *'),
                const SizedBox(height: 8),
                TextFormField(
                  controller: _idNumberController,
                  decoration: _buildInputDecoration('Enter ID number'),
                  validator: (value) => value?.isEmpty ?? true ? AppLanguage.translate('Please enter ID number') : null,
                ),
                const SizedBox(height: 24),
                _buildLabel('Mobile Number *'),
                const SizedBox(height: 8),
                TextFormField(
                  controller: _mobileNumberController,
                  keyboardType: TextInputType.phone,
                  decoration: _buildInputDecoration('Enter mobile number'),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return AppLanguage.translate('Please enter mobile number');
                    }
                    final regex = RegExp(r'^01[0-2,5]{1}[0-9]{8}$');
                    if (!regex.hasMatch(value)) {
                      return AppLanguage.translate('Invalid Egyptian mobile number');
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 24),
                _buildLabel('Number of Units *'),
                const SizedBox(height: 8),
                Row(
                  children: [
                    Expanded(
                      child: _buildDropdown(
                        _numberOfUnits,
                        _unitsOptions,
                        (value) => setState(() {
                          _numberOfUnits = value ?? '1';
                          _useCustomUnits = false;
                        }),
                      ),
                    ),
                    Checkbox(
                      value: _useCustomUnits,
                      onChanged: (value) => setState(() => _useCustomUnits = value ?? false),
                    ),
                    const Text('Custom'),
                  ],
                ),
                if (_useCustomUnits) ...[
                  const SizedBox(height: 12),
                  TextFormField(
                    controller: _customUnitsController,
                    keyboardType: TextInputType.number,
                    decoration: _buildInputDecoration('Enter custom number of units'),
                  ),
                ],
                const SizedBox(height: 24),
                CheckboxListTile(
                  title: Text(AppLanguage.translate('Entity')),
                  value: _isEntity,
                  onChanged: (value) => setState(() => _isEntity = value ?? false),
                ),
                if (_isEntity) ...[
                  const SizedBox(height: 8),
                  Row(
                    children: [
                      Expanded(
                        child: Container(
                          padding: const EdgeInsets.symmetric(horizontal: 16),
                          decoration: BoxDecoration(
                            border: Border.all(color: const Color(0xFFE0E0E0)),
                            borderRadius: BorderRadius.circular(8),
                            color: Colors.white,
                          ),
                          child: DropdownButtonHideUnderline(
                            child: DropdownButton<String>(
                              value: _selectedEntity,
                              isExpanded: true,
                              hint: const Text('Select entity'),
                              items: [...widget.entities, 'Other'].map((entity) {
                                return DropdownMenuItem(
                                  value: entity,
                                  child: Text(entity),
                                );
                              }).toList(),
                              onChanged: (value) => setState(() {
                                _selectedEntity = value;
                                _useCustomEntity = value == 'Other';
                              }),
                            ),
                          ),
                        ),
                      ),
                    ],
                  ),
                  if (_useCustomEntity) ...[
                    const SizedBox(height: 12),
                    TextFormField(
                      controller: _customEntityController,
                      decoration: _buildInputDecoration('Enter custom entity name'),
                    ),
                  ],
                ],
                const SizedBox(height: 24),
                _buildLabel('Status *'),
                const SizedBox(height: 8),
                _buildDropdown(_status, _statusOptions, (value) => setState(() => _status = value ?? 'Active')),
                const SizedBox(height: 24),
                _buildLabel('Photo (Optional)'),
                const SizedBox(height: 8),
                Row(
                  children: [
                    if (_photoPath != null)
                      Container(
                        width: 80,
                        height: 80,
                        decoration: BoxDecoration(
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.grey.withOpacity(0.3)),
                          color: Colors.grey[200],
                        ),
                        child: Stack(
                          children: [
                            ClipRRect(
                              borderRadius: BorderRadius.circular(8),
                              child: _photoPath!.startsWith('http://') || _photoPath!.startsWith('https://')
                                ? Image.network(
                                    _photoPath!,
                                    width: 80,
                                    height: 80,
                                    fit: BoxFit.cover,
                                    errorBuilder: (context, error, stackTrace) {
                                      return Icon(
                                        Icons.person,
                                        size: 40,
                                        color: Colors.grey[600],
                                      );
                                    },
                                    loadingBuilder: (context, child, loadingProgress) {
                                      if (loadingProgress == null) return child;
                                      return Center(
                                        child: CircularProgressIndicator(
                                          value: loadingProgress.expectedTotalBytes != null
                                              ? loadingProgress.cumulativeBytesLoaded / loadingProgress.expectedTotalBytes!
                                              : null,
                                        ),
                                      );
                                    },
                                  )
                                : _photoPath!.startsWith('assets/')
                                  ? Image.asset(
                                      _photoPath!,
                                      width: 80,
                                      height: 80,
                                      fit: BoxFit.cover,
                                      errorBuilder: (context, error, stackTrace) {
                                        return Icon(
                                          Icons.person,
                                          size: 40,
                                          color: Colors.grey[600],
                                        );
                                      },
                                    )
                                  : Image.file(
                                      File(_photoPath!),
                                      width: 80,
                                      height: 80,
                                      fit: BoxFit.cover,
                                      errorBuilder: (context, error, stackTrace) {
                                        return Icon(
                                          Icons.person,
                                          size: 40,
                                          color: Colors.grey[600],
                                        );
                                      },
                                    ),
                            ),
                            Positioned(
                              right: 0,
                              top: 0,
                              child: IconButton(
                                icon: const Icon(Icons.close, size: 20, color: Colors.red),
                                onPressed: () {
                                  setState(() {
                                    _photoPath = null;
                                  });
                                },
                              ),
                            ),
                          ],
                        ),
                      )
                    else
                      Container(
                        width: 80,
                        height: 80,
                        decoration: BoxDecoration(
                          color: Colors.grey[200],
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.grey.withOpacity(0.3)),
                        ),
                        child: const Icon(Icons.person, size: 40, color: Colors.grey),
                      ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: ElevatedButton.icon(
                        onPressed: _takePhoto,
                        icon: const Icon(Icons.camera_alt),
                        label: Text(_photoPath != null ? 'Retake Photo' : 'Take Photo'),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: tealGreen,
                          foregroundColor: Colors.white,
                          padding: const EdgeInsets.symmetric(vertical: 12),
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 24),
                Row(
                  children: [
                    _buildLabel('NFC Code'),
                    const SizedBox(width: 8),
                    Expanded(
                      child: TextFormField(
                        controller: _nfcCodeController,
                        decoration: InputDecoration(
                          hintText: AppLanguage.translate('Enter NFC code'),
                          border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          filled: true,
                          fillColor: Colors.white,
                          contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
                          isDense: true,
                          suffixIcon: _nfcDetected
                              ? const Icon(Icons.check_circle, color: Colors.green, size: 24)
                              : IconButton(
                            icon: const Icon(Icons.nfc, color: Color(0xFF81CF01)),
                            onPressed: _scanNFCCard,
                            tooltip: AppLanguage.translate('Scan NFC Card'),
                          ),
                        ),
                        onChanged: (value) {
                          // Reset detection status if user manually edits the field
                          if (mounted && _nfcDetected) {
                            setState(() {
                              _nfcDetected = false;
                              _originalNfcTagId = null; // Clear original ID when manually edited
                            });
                          }
                          // Clear duplicate message when field is cleared
                          if (value.isEmpty) {
                            setState(() {
                              _duplicateNFCMessage = null;
                            });
                          } else {
                            // If user manually enters NFC code, check for duplicates
                            // Only check if it doesn't contain asterisks (not masked)
                            if (!value.contains('*') && value.trim().isNotEmpty) {
                              _checkDuplicateNFC(value.trim());
                            }
                          }
                        },
                      ),
                    ),
                  ],
                ),
                if (_duplicateNFCMessage != null) ...[
                  const SizedBox(height: 8),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: Colors.red.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(color: Colors.red),
                    ),
                    child: Row(
                      children: [
                        const Icon(Icons.error, color: Colors.red),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            _duplicateNFCMessage!,
                            style: const TextStyle(color: Colors.red),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
                const SizedBox(height: 32),
                ElevatedButton(
                  onPressed: () => _handleUpdate(),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: tealGreen,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    minimumSize: const Size(double.infinity, 0),
                  ),
                  child: const Text('Update Beneficiary'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  /// Extract person's name from Google Lens text, filtering out common phrases
  /// Neglects: "جمهورية مصر العربية", "بطاقة تحقيق شخصية", addresses, etc.
  String? _extractPersonNameFromGoogleLensText(String text) {
    print('🔍 Extracting person name from Google Lens text...');
    
    // Phrases to remove/ignore
    final phrasesToRemove = [
      'جمهورية مصر العربية',
      'بطاقة تحقيق شخصية',
      'بطاقة تحقيق',
      'جمهورية مصر',
      'مصر العربية',
      'الجمهورية',
      'مصر',
      'بطاقة',
      'تحقيق',
      'شخصية',
      'Arab Republic of Egypt',
      'Identity Card',
      'National ID',
      'بطاقة وطنية',
      'بطاقة مدنية',
    ];
    
    // Address keywords to help identify and skip address sections
    final addressKeywords = [
      'عنوان',
      'العنوان',
      'محل الإقامة',
      'الإقامة',
      'address',
      'residence',
      'المنوفية',
      'السادات',
      'مركز',
      'محافظة',
      'مدينة',
      'قرية',
      'شارع',
      'طريق',
    ];
    
    // Clean the text - remove unwanted phrases
    String cleanedText = text;
    for (final phrase in phrasesToRemove) {
      cleanedText = cleanedText.replaceAll(RegExp(phrase, caseSensitive: false), '');
    }
    
    // Split into lines
    final lines = cleanedText.split('\n').map((l) => l.trim()).where((l) => l.isNotEmpty).toList();
    
    print('📝 Lines after cleaning: ${lines.length}');
    for (int i = 0; i < lines.length && i < 10; i++) {
      print('  Line $i: ${lines[i]}');
    }
    
    // Find the person's name - can be on 1 or 2 lines
    // First line: first name
    // Second line: rest of name (middle name, last name, etc.)
    // We need to combine them into a full name
    
    List<String> nameLines = [];
    
    for (int i = 0; i < lines.length; i++) {
      final line = lines[i];
      
      // Skip if contains numbers (likely ID or date)
      if (RegExp(r'\d').hasMatch(line)) continue;
      
      // Skip if contains address keywords
      bool isAddress = false;
      for (final keyword in addressKeywords) {
        if (line.contains(keyword)) {
          isAddress = true;
          break;
        }
      }
      if (isAddress) continue;
      
      // Check if line is primarily Arabic text
      final arabicPattern = RegExp(r'^[أ-ي\s]+$');
      if (arabicPattern.hasMatch(line) && line.length >= 3) {
        // Check if this could be part of a name
        final words = line.split(RegExp(r'\s+')).where((w) => w.isNotEmpty).toList();
        
        // If it's a single word or short line, it might be the first name
        // If it's multiple words, it might be the full name or part of it
        if (words.length >= 1 && line.length >= 3) {
          nameLines.add(line);
          print('📝 Found potential name line $i: $line (${words.length} words)');
        }
      }
    }
    
    // Combine consecutive name lines (first name on first line, rest on second line)
    if (nameLines.isNotEmpty) {
      // Try to find 2 consecutive lines that look like a name
      for (int i = 0; i < nameLines.length - 1; i++) {
        final firstLine = nameLines[i];
        final secondLine = nameLines[i + 1];
        
        // Check if both lines are Arabic names (no numbers, no address keywords)
        final firstIsName = RegExp(r'^[أ-ي\s]+$').hasMatch(firstLine) && 
                           !RegExp(r'\d').hasMatch(firstLine) &&
                           firstLine.length >= 3;
        final secondIsName = RegExp(r'^[أ-ي\s]+$').hasMatch(secondLine) && 
                            !RegExp(r'\d').hasMatch(secondLine) &&
                            secondLine.length >= 3;
        
        if (firstIsName && secondIsName) {
          // Combine the two lines
          final fullName = '$firstLine $secondLine'.trim();
          final words = fullName.split(RegExp(r'\s+')).where((w) => w.isNotEmpty).toList();
          
          // Validate: should have at least 2 words total
          if (words.length >= 2) {
            print('✅ Found 2-line name: "$firstLine" + "$secondLine" = "$fullName"');
            return fullName;
          }
        }
      }
      
      // If no 2-line name found, try to find the longest single line name
      String? bestName;
      int maxLength = 0;
      
      for (final line in nameLines) {
        final words = line.split(RegExp(r'\s+')).where((w) => w.isNotEmpty).toList();
        if (words.length >= 2 && line.length > maxLength) {
          bestName = line;
          maxLength = line.length;
        }
      }
      
      if (bestName != null) {
        print('✅ Extracted single-line name: $bestName');
        return bestName;
      }
      
      // Last fallback: use the first name line if it's long enough
      if (nameLines.isNotEmpty) {
        final firstLine = nameLines.first;
        if (firstLine.length >= 5) {
          print('✅ Extracted name (fallback): $firstLine');
          return firstLine;
        }
      }
    }
    
    print('⚠️ Could not extract person name from text');
    return null;
  }

  /// Process text from Live Text Detection (Google Lens-like) screen
  void _processLiveTextDetectionResult(String text) {
    if (text.isEmpty) return;
    
    print('📝 Processing Google Lens text (length: ${text.length})');
    print('📝 Text preview: ${text.substring(0, text.length > 200 ? 200 : text.length)}');
    
    try {
      // Parse the text using IDParser
      final parsedData = IDParser.parseIDText(text);
      
      print('📝 Parsed data keys: ${parsedData.keys.toList()}');
      print('📝 ID Number from parser: ${parsedData['idNumber']}');
      print('📝 Name from parser: ${parsedData['name']}');
      
      // Extract 14-digit ID number
      var idNumber = parsedData['idNumber'] as String?;
      
      // If ID number is not exactly 14 digits, try to extract it directly from text
      if (idNumber == null || idNumber.length != 14) {
        print('⚠️ ID number not found or invalid length (${idNumber?.length ?? 0}). Trying direct extraction...');
        
        // First, convert all Arabic-Indic digits in the full text (including variant forms)
        // This handles both Persian (۰۱۲۳۴۵۶۷۸۹) and Arabic variant (٠١٢٣٤٥٦٧٨٩) digits
        final cleanedText = IDParser.convertArabicIndicToWestern(text);
        print('📝 Text after Arabic-Indic conversion (first 200 chars): ${cleanedText.substring(0, cleanedText.length > 200 ? 200 : cleanedText.length)}');
        
        // Also try to match Arabic-Indic digits directly and convert them
        // Pattern to match sequences that might contain Arabic-Indic digits
        final arabicIndicPattern = RegExp(r'[0-9۰-۹٠-٩]{12,14}');
        final arabicMatch = arabicIndicPattern.firstMatch(text);
        if (arabicMatch != null && arabicMatch.group(0) != null) {
          final rawId = arabicMatch.group(0)!;
          final convertedId = IDParser.convertArabicIndicToWestern(rawId);
          if (convertedId.length >= 12 && convertedId.length <= 14) {
            idNumber = convertedId;
            print('✅ Found ID with Arabic-Indic digits, converted: $idNumber');
          }
        }
        
        // If still not found, try to find 14-digit number in cleaned text directly
        if (idNumber == null || idNumber.length != 14) {
          final directIdMatch = RegExp(r'\d{14}').firstMatch(cleanedText);
          if (directIdMatch != null && directIdMatch.group(0) != null) {
            idNumber = directIdMatch.group(0)!;
            print('✅ Found 14-digit ID directly: $idNumber');
          } else {
            // Try to find numbers with spaces/dashes and clean them
            final spacedIdMatch = RegExp(r'\d{2}[\s-]?\d{2}[\s-]?\d{2}[\s-]?\d{2}[\s-]?\d{2}[\s-]?\d{2}[\s-]?\d{2}').firstMatch(cleanedText);
            if (spacedIdMatch != null && spacedIdMatch.group(0) != null) {
              idNumber = spacedIdMatch.group(0)!.replaceAll(RegExp(r'[^\d]'), '');
              print('✅ Found spaced ID and cleaned: $idNumber');
            } else {
              // Try to find any sequence of 12-14 digits (might be partial due to OCR issues)
              final partialMatch = RegExp(r'\d{12,14}').firstMatch(cleanedText);
              if (partialMatch != null && partialMatch.group(0) != null) {
                final partialId = partialMatch.group(0)!;
                if (partialId.length >= 12) {
                  idNumber = partialId;
                  print('⚠️ Found partial ID (${partialId.length} digits): $idNumber - will try to use if valid');
                }
              }
            }
          }
        }
      }
      
      // Set ID number if found (accept 12-14 digits)
      if (idNumber != null && idNumber.length >= 12) {
        // Create non-nullable variable for use inside
        final validIdNumber = idNumber;
        
        // Validate first digit (should be 2 or 3 for Egyptian IDs)
        final firstDigit = int.tryParse(validIdNumber.substring(0, 1));
        if (firstDigit == 2 || firstDigit == 3) {
          setState(() {
            _idNumberController.text = validIdNumber;
          });
          print('✅ ID Number set: $validIdNumber (${validIdNumber.length} digits)');
          
          // Extract birth date from ID number (only if we have at least 7 digits for date)
          if (validIdNumber.length >= 7) {
            // For partial IDs (less than 14 digits), we can't extract full birth date
            // But we can try if we have enough digits
            if (validIdNumber.length == 14) {
              final birthDate = IDParser.extractBirthDateFromIDNumber(validIdNumber);
              
              // Check if birth date is older than 1-1-1965
              if (birthDate != null) {
                final cutoffDate = DateTime(1965, 1, 1);
                if (birthDate.isBefore(cutoffDate)) {
                  setState(() {
                    _type = 'Elderly';
                  });
                  print('✅ Type set to Elderly (birth date: $birthDate)');
                }
                _birthDate = birthDate;
              }
            } else {
              print('⚠️ Partial ID (${validIdNumber.length} digits) - cannot extract birth date');
            }
          }
        } else {
          print('⚠️ Invalid ID number first digit: $firstDigit');
        }
      } else {
        print('⚠️ ID number not found or invalid length: ${idNumber?.length ?? 0}');
      }
      
      // Extract name - improved extraction for Google Lens results
      String? extractedName = _extractPersonNameFromGoogleLensText(text);
      
      // Fallback to parsed data if direct extraction didn't work
      if (extractedName == null || extractedName.isEmpty) {
        extractedName = parsedData['name'] as String?;
      }
      
      if (extractedName != null && extractedName.isNotEmpty) {
        // Clean the name - remove extra whitespace
        extractedName = extractedName.trim().replaceAll(RegExp(r'\s+'), ' ');
        
        // Validate that name is not just numbers or alphanumeric codes
        final namePattern = RegExp(r'^[أ-ي\s]+$|^[A-Za-z\s]+$');
        if (namePattern.hasMatch(extractedName)) {
          setState(() {
            _nameController.text = extractedName!;
          });
          print('✅ Name set: $extractedName');
        } else {
          print('⚠️ Name validation failed: $extractedName');
        }
      } else {
        print('⚠️ Name not found in text');
      }
      
      // Show success message
      if (mounted) {
        final hasId = idNumber != null && idNumber.length >= 12;
        final hasName = extractedName != null && extractedName.isNotEmpty;
        
        if (hasId || hasName) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(AppLanguage.translate('Data extracted from Google Lens and filled automatically')),
              backgroundColor: Colors.green,
              duration: const Duration(seconds: 3),
            ),
          );
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(AppLanguage.translate('Could not extract ID number or name from text. Please check the text and try again.')),
              backgroundColor: Colors.orange,
              duration: const Duration(seconds: 4),
            ),
          );
        }
      }
    } catch (e, stackTrace) {
      print('❌ Error processing live text detection result: $e');
      print('Stack trace: $stackTrace');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(AppLanguage.translate('Could not parse data from Google Lens. Please enter manually.')),
            backgroundColor: Colors.orange,
            duration: const Duration(seconds: 3),
          ),
        );
      }
    }
  }
}

// Queue View Screen
class QueueViewScreen extends StatelessWidget {
  final Queue queue;
  final List<Beneficiary> beneficiaries;
  final Function(Queue) onQueueUpdated;
  final Function(Beneficiary) onBeneficiaryUpdated;

  const QueueViewScreen({
    super.key,
    required this.queue,
    required this.beneficiaries,
    required this.onQueueUpdated,
    required this.onBeneficiaryUpdated,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(queue.name),
        backgroundColor: const Color(0xFF81CF01),
        foregroundColor: Colors.white,
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text('Queue Point: ${queue.queuePoint}', style: const TextStyle(fontWeight: FontWeight.bold)),
                    const SizedBox(height: 8),
                    Text('Type: ${queue.queueType}'),
                    Text('Date Range: ${queue.displayDateRange}'),
                    Text('Time Range: ${queue.displayTimeRange}'),
                    Text('Status: ${queue.status}'),
                    Text('Available Units: ${queue.numberOfAvailableUnits}'),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 24),
            if (!queue.isStarted && !queue.isCompleted)
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: () {
                    onQueueUpdated(queue.copyWith(isStarted: true));
                    Navigator.of(context).push(
                      MaterialPageRoute(
                        builder: (context) => QueueServingScreen(
                          queue: queue.copyWith(isStarted: true),
                          beneficiaries: [], // Will be loaded from Firebase in the screen
                          onQueueUpdated: (updatedQueue) {
                            // Handle queue update
                          },
                          onBeneficiaryUpdated: (beneficiary) {
                            // Handle beneficiary update
                          },
                        ),
                      ),
                    );
                  },
                  style: ElevatedButton.styleFrom(
                    backgroundColor: const Color(0xFF81CF01),
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(vertical: 16),
                  ),
                  child: const Text('Start Queue'),
                ),
              ),
            const SizedBox(height: 24),
            const Text('Beneficiaries:', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
            const SizedBox(height: 8),
            // For multi-day queues, check queueHistory to find beneficiaries for this specific day
            queue.isMultiDay && queue.fromDate.year == queue.toDate.year &&
                queue.fromDate.month == queue.toDate.month &&
                queue.fromDate.day == queue.toDate.day
                ? Builder(
                    builder: (context) {
                      // Calculate day-specific queue name once
                      final dayStr = '${queue.fromDate.year}-${queue.fromDate.month.toString().padLeft(2, '0')}-${queue.fromDate.day.toString().padLeft(2, '0')}';
                      final dayQueueName = '${queue.name}_$dayStr';
                      
                      return StreamBuilder<QuerySnapshot>(
                        stream: FirebaseService.firestore
                            .collection('queueHistory')
                            .where('dayQueueName', isEqualTo: dayQueueName)
                            .where('action', isEqualTo: 'issued')
                            .snapshots(),
                        builder: (context, historySnapshot) {
                          // Get beneficiary IDs from queueHistory for this day
                          final beneficiaryIdsFromHistory = historySnapshot.hasData
                              ? historySnapshot.data!.docs
                                  .map((doc) => doc.data() as Map<String, dynamic>)
                                  .map((data) => data['beneficiaryId'] as String?)
                                  .where((id) => id != null)
                                  .cast<String>()
                                  .toSet()
                              : <String>{};
                          
                          // Get served beneficiary IDs for this day
                          return StreamBuilder<QuerySnapshot>(
                            stream: FirebaseService.firestore
                                .collection('queueHistory')
                                .where('dayQueueName', isEqualTo: dayQueueName)
                                .where('action', isEqualTo: 'served')
                                .snapshots(),
                            builder: (context, servedSnapshot) {
                              // Calculate day-specific units served for each beneficiary
                              final dayUnitsTakenMap = <String, int>{};
                              if (servedSnapshot.hasData) {
                                for (var doc in servedSnapshot.data!.docs) {
                                  final data = doc.data() as Map<String, dynamic>;
                                  final beneficiaryId = data['beneficiaryId'] as String?;
                                  final unitsServed = data['unitsServed'] as int? ?? 0;
                                  if (beneficiaryId != null) {
                                    dayUnitsTakenMap[beneficiaryId] = 
                                        (dayUnitsTakenMap[beneficiaryId] ?? 0) + unitsServed;
                                  }
                                }
                              }
                              
                              return StreamBuilder<List<Beneficiary>>(
              stream: BeneficiaryService.getAllBeneficiaries(),
              builder: (context, snapshot) {
                if (snapshot.connectionState == ConnectionState.waiting && !snapshot.hasData) {
                  return const Center(child: CircularProgressIndicator());
                }

                if (snapshot.hasError) {
                  return Text('Error loading beneficiaries: ${snapshot.error}');
                }

                final allBeneficiaries = snapshot.data ?? [];
                
                // For multi-day queues, calculate the day-specific queue name
                String effectiveQueueName = queue.name;
                if (queue.isMultiDay && queue.fromDate.year == queue.toDate.year &&
                    queue.fromDate.month == queue.toDate.month &&
                    queue.fromDate.day == queue.toDate.day) {
                  final dayStr = '${queue.fromDate.year}-${queue.fromDate.month.toString().padLeft(2, '0')}-${queue.fromDate.day.toString().padLeft(2, '0')}';
                  effectiveQueueName = '${queue.name}_$dayStr';
                }
                                  
                                  // Filter beneficiaries: either assigned directly OR in queueHistory for this day
                                  final beneficiariesForQueue = allBeneficiaries.where((b) {
                                    if (b.initialAssignedQueuePoint == effectiveQueueName) {
                                      return true;
                                    }
                                    // Check if they have a queue number in history for this day
                                    if (beneficiaryIdsFromHistory.contains(b.id)) {
                                      return true;
                                    }
                                    return false;
                                  }).toList();

                                  if (beneficiariesForQueue.isEmpty) {
                                    return const Text('No beneficiaries assigned to this queue');
                                  }

                                  return Column(
                                    children: beneficiariesForQueue.map((b) {
                                      // Eligibility is based on beneficiary.numberOfUnits set during registration
                                      final eligibleUnits = int.tryParse(b.numberOfUnits) ?? 1;
                                      final dayUnitsTaken = dayUnitsTakenMap[b.id] ?? 0;
                                      // Only mark as served if they've received full eligible units
                                      final isServedForDay = dayUnitsTaken >= eligibleUnits;
                                      return Card(
                                        child: ListTile(
                                          title: Text(b.name),
                                          subtitle: Text('ID: ${b.idNumber}${b.queueNumber != null ? '\nQueue #${b.queueNumber}' : ''}'),
                                          trailing: Text(
                                            isServedForDay ? 'Served' : 'Not Served',
                                            style: TextStyle(color: isServedForDay ? Colors.green : Colors.grey),
                                          ),
                                        ),
                                      );
                                    }).toList(),
                                  );
                                },
                              );
                            },
                          );
                        },
                      );
                    },
                  )
                : StreamBuilder<List<Beneficiary>>(
                    stream: BeneficiaryService.getAllBeneficiaries(),
                    builder: (context, snapshot) {
                      if (snapshot.connectionState == ConnectionState.waiting && !snapshot.hasData) {
                        return const Center(child: CircularProgressIndicator());
                      }

                      if (snapshot.hasError) {
                        return Text('Error loading beneficiaries: ${snapshot.error}');
                      }

                      final allBeneficiaries = snapshot.data ?? [];
                      
                      // For single-day queues, use simple filtering
                      String effectiveQueueName = queue.name;
                
                final beneficiariesForQueue = allBeneficiaries
                    .where((b) => b.initialAssignedQueuePoint == effectiveQueueName)
                    .toList();

                if (beneficiariesForQueue.isEmpty) {
                  return const Text('No beneficiaries assigned to this queue');
                }

                return Column(
                  children: beneficiariesForQueue.map((b) => Card(
                    child: ListTile(
                      title: Text(b.name),
                      subtitle: Text('ID: ${b.idNumber}${b.queueNumber != null ? '\nQueue #${b.queueNumber}' : ''}'),
                      trailing: Text(b.isServed ? 'Served' : 'Not Served', style: TextStyle(color: b.isServed ? Colors.green : Colors.grey)),
                    ),
                  )).toList(),
                );
              },
            ),
          ],
        ),
      ),
    );
  }
}

// Add Queue Point Screen
class AddDistributionAreaScreen extends StatefulWidget {
  final Function(DistributionArea) onAreaCreated;
  final VoidCallback? onCancel;

  const AddDistributionAreaScreen({
    super.key,
    required this.onAreaCreated,
    this.onCancel,
  });

  @override
  State<AddDistributionAreaScreen> createState() => _AddDistributionAreaScreenState();
}

class _AddDistributionAreaScreenState extends State<AddDistributionAreaScreen> {
  final _formKey = GlobalKey<FormState>();
  final _areaNameController = TextEditingController();
  String? _selectedGovernorate;
  String? _selectedCity;

  final Map<String, List<String>> _egyptGovernoratesCities = {
    'Cairo': ['Cairo', 'Nasr City', 'Heliopolis', 'Maadi', 'Zamalek', 'New Cairo', '6th of October City'],
    'Giza': ['Giza', '6th of October', 'Sheikh Zayed', 'Dokki', 'Mohandessin', 'Agouza', 'Faisal', 'Haram'],
    'Alexandria': ['Alexandria', 'Montaza', 'Sidi Bishr', 'Stanley', 'Smouha'],
    'Qalyubia': ['Banha', 'Qalyub', 'Shubra El Kheima', 'Tukh'],
    'Port Said': ['Port Said', 'Port Fouad'],
    'Suez': ['Suez', 'Arish'],
    'Dakahlia': ['Mansoura', 'Talkha', 'Mit Ghamr', 'Aga'],
    'Sharqia': ['Zagazig', '10th of Ramadan', 'Belbeis', 'Abu Hammad'],
    'Monufia': ['Shibin El Kom', 'Menouf', 'Tala', 'Ashmoun'],
    'Beheira': ['Damanhur', 'Kafr El Dawwar', 'Rashid', 'Edku'],
    'Gharbia': ['Tanta', 'Mahalla', 'Kafr El Zayat', 'Zefta'],
    'Kafr El Sheikh': ['Kafr El Sheikh', 'Desouk', 'Fuwa', 'Bilqas'],
    'Damietta': ['Damietta', 'New Damietta', 'Ras El Bar'],
    'Ismailia': ['Ismailia', 'Fayed', 'Abu Suwayr'],
    'North Sinai': ['Arish', 'Sheikh Zuweid', 'Rafah'],
    'South Sinai': ['Sharm El Sheikh', 'Dahab', 'Nuweiba', 'Taba'],
    'Red Sea': ['Hurghada', 'Marsa Alam', 'Safaga', 'El Gouna'],
    'New Valley': ['Kharga', 'Dakhla', 'Farafra'],
    'Matruh': ['Marsa Matruh', 'El Alamein', 'Sidi Barrani'],
    'Luxor': ['Luxor', 'Esna', 'Armant'],
    'Aswan': ['Aswan', 'Kom Ombo', 'Edfu'],
    'Qena': ['Qena', 'Luxor', 'Nag Hammadi'],
    'Sohag': ['Sohag', 'Akhmim', 'Girga'],
    'Assiut': ['Assiut', 'Abnoub', 'Manfalut'],
    'Minya': ['Minya', 'Malawi', 'Abu Qurqas'],
    'Beni Suef': ['Beni Suef', 'Biba', 'Al Fashn'],
    'Faiyum': ['Faiyum', 'Tamiya', 'Sinnuris'],
  };

  // Helper method to get governorate display name based on current language
  String _getGovernorateDisplayName(String governorate) {
    const Map<String, Map<String, String>> governorateNames = {
      'Cairo': {'ar': 'القاهرة', 'en': 'Cairo'},
      'Alexandria': {'ar': 'الإسكندرية', 'en': 'Alexandria'},
      'Giza': {'ar': 'الجيزة', 'en': 'Giza'},
      'Qalyubia': {'ar': 'القليوبية', 'en': 'Qalyubia'},
      'Sharqia': {'ar': 'الشرقية', 'en': 'Sharqia'},
      'Dakahlia': {'ar': 'الدقهلية', 'en': 'Dakahlia'},
      'Beheira': {'ar': 'البحيرة', 'en': 'Beheira'},
      'Kafr El Sheikh': {'ar': 'كفر الشيخ', 'en': 'Kafr El Sheikh'},
      'Monufia': {'ar': 'المنوفية', 'en': 'Monufia'},
      'Gharbia': {'ar': 'الغربية', 'en': 'Gharbia'},
      'Damietta': {'ar': 'دمياط', 'en': 'Damietta'},
      'Port Said': {'ar': 'بورسعيد', 'en': 'Port Said'},
      'Ismailia': {'ar': 'الإسماعيلية', 'en': 'Ismailia'},
      'Suez': {'ar': 'السويس', 'en': 'Suez'},
      'Faiyum': {'ar': 'الفيوم', 'en': 'Fayoum'},
      'Beni Suef': {'ar': 'بني سويف', 'en': 'Beni Suef'},
      'Minya': {'ar': 'المنيا', 'en': 'Minya'},
      'Assiut': {'ar': 'أسيوط', 'en': 'Assiut'},
      'Sohag': {'ar': 'سوهاج', 'en': 'Sohag'},
      'Qena': {'ar': 'قنا', 'en': 'Qena'},
      'Luxor': {'ar': 'الأقصر', 'en': 'Luxor'},
      'Aswan': {'ar': 'أسوان', 'en': 'Aswan'},
      'Red Sea': {'ar': 'البحر الأحمر', 'en': 'Red Sea'},
      'New Valley': {'ar': 'الوادي الجديد', 'en': 'New Valley'},
      'Matruh': {'ar': 'مطروح', 'en': 'Matrouh'},
      'North Sinai': {'ar': 'شمال سيناء', 'en': 'North Sinai'},
      'South Sinai': {'ar': 'جنوب سيناء', 'en': 'South Sinai'},
    };
    final names = governorateNames[governorate];
    if (names == null) return governorate;
    return AppLanguage.isArabic ? names['ar']! : names['en']!;
  }

  @override
  void dispose() {
    _areaNameController.dispose();
    super.dispose();
  }

  bool _isLoading = false;

  Future<void> _handleCreate() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }
    
    if (_selectedGovernorate == null || _selectedCity == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select governorate and city')),
      );
      return;
    }

    setState(() {
      _isLoading = true;
    });

    try {
      final area = DistributionArea(
        id: '', // Will be set by Firestore
        country: 'Egypt',
        governorate: _selectedGovernorate!,
        city: _selectedCity!,
        areaName: _areaNameController.text,
      );

      // Save to Firestore
      final areaId = await DistributionAreaService.createArea(area);
      
      // Create area with Firestore ID
      final createdArea = DistributionArea(
        id: areaId,
        country: area.country,
        governorate: area.governorate,
        city: area.city,
        areaName: area.areaName,
      );

      // Also call the callback for local state management
      widget.onAreaCreated(createdArea);
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(AppLanguage.translate('Area created successfully'))),
        );
        
        if (widget.onCancel != null) {
          widget.onCancel!();
        } else {
          Navigator.of(context).pop();
        }
      }
    } catch (e) {
      print('Error creating area: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to create area: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    const darkBlue = Color(0xFF1A237E);
    const tealGreen = Color(0xFF81CF01);

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Color(0xFFE8F5E9), Colors.white],
          ),
        ),
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(20.0),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  AppLanguage.translate('Add Distribution Area'),
                  style: TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                    color: darkBlue,
                  ),
                ),
                const SizedBox(height: 32),
                _buildLabel('Country'),
                const SizedBox(height: 8),
                TextFormField(
                  initialValue: 'Egypt',
                  enabled: false,
                  decoration: _buildInputDecoration('Egypt'),
                ),
                const SizedBox(height: 24),
                _buildLabel('Governorate *'),
                const SizedBox(height: 8),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  decoration: BoxDecoration(
                    border: Border.all(color: const Color(0xFFE0E0E0)),
                    borderRadius: BorderRadius.circular(8),
                    color: Colors.white,
                  ),
                  child: DropdownButtonHideUnderline(
                    child: DropdownButton<String>(
                      value: _selectedGovernorate,
                      isExpanded: true,
                      hint: const Text('Select governorate'),
                      items: _egyptGovernoratesCities.keys.map((gov) {
                        final displayName = _getGovernorateDisplayName(gov);
                        return DropdownMenuItem(value: gov, child: Text(displayName));
                      }).toList(),
                      onChanged: (value) {
                        setState(() {
                          _selectedGovernorate = value;
                          _selectedCity = null;
                        });
                      },
                    ),
                  ),
                ),
                const SizedBox(height: 24),
                _buildLabel('City *'),
                const SizedBox(height: 8),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  decoration: BoxDecoration(
                    border: Border.all(color: const Color(0xFFE0E0E0)),
                    borderRadius: BorderRadius.circular(8),
                    color: Colors.white,
                  ),
                  child: DropdownButtonHideUnderline(
                    child: DropdownButton<String>(
                      value: _selectedCity,
                      isExpanded: true,
                      hint: Text(_selectedGovernorate == null ? 'Select governorate first' : 'Select city'),
                      items: _selectedGovernorate != null
                          ? _egyptGovernoratesCities[_selectedGovernorate]!.map((city) {
                              return DropdownMenuItem(value: city, child: Text(city));
                            }).toList()
                          : [],
                      onChanged: _selectedGovernorate == null ? null : (value) => setState(() => _selectedCity = value),
                    ),
                  ),
                ),
                const SizedBox(height: 24),
                _buildLabel('Distribution Area Name *'),
                const SizedBox(height: 8),
                TextFormField(
                  controller: _areaNameController,
                  decoration: _buildInputDecoration('Enter distribution area name'),
                  validator: (value) => value?.isEmpty ?? true ? AppLanguage.translate('Please enter distribution area name') : null,
                ),
                const SizedBox(height: 32),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton(
                    onPressed: _isLoading ? null : _handleCreate,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: tealGreen,
                      foregroundColor: Colors.white,
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                      disabledBackgroundColor: Colors.grey,
                    ),
                    child: _isLoading
                        ? const SizedBox(
                            width: 20,
                            height: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                            ),
                          )
                        : Text(
                            AppLanguage.translate('Create Area'),
                            style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                          ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildLabel(String text) {
    return Text(
      text,
      style: const TextStyle(
        fontSize: 14,
        fontWeight: FontWeight.w500,
        color: Color(0xFF1A237E),
      ),
    );
  }

  InputDecoration _buildInputDecoration(String hint) {
    const tealGreen = Color(0xFF81CF01);
    return InputDecoration(
      hintText: hint,
      border: OutlineInputBorder(
        borderRadius: BorderRadius.circular(8),
        borderSide: const BorderSide(color: Color(0xFFE0E0E0)),
      ),
      filled: true,
      fillColor: Colors.white,
      focusedBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(8),
        borderSide: const BorderSide(color: tealGreen, width: 2),
      ),
    );
  }
}

// Queue Serving Screen
class QueueServingScreen extends StatefulWidget {
  final Queue queue;
  final List<Beneficiary> beneficiaries;
  final Function(Queue) onQueueUpdated;
  final Function(Beneficiary) onBeneficiaryUpdated;

  const QueueServingScreen({
    super.key,
    required this.queue,
    required this.beneficiaries,
    required this.onQueueUpdated,
    required this.onBeneficiaryUpdated,
  });

  @override
  State<QueueServingScreen> createState() => _QueueServingScreenState();
}

class _QueueServingScreenState extends State<QueueServingScreen> {
  late int _availableUnits;
  bool _isQueueDetailsExpanded = false;
  String? _servingOption;
  late List<Beneficiary> _localBeneficiaries;
  Beneficiary? _selectedBeneficiary;
  final TextEditingController _searchController = TextEditingController();
  String? _nfcCode; // Original NFC code for searching
  String? _originalNfcTagId; // Store original tag ID for searching
  bool _isNFCScanning = false;
  final FocusNode _searchFocusNode = FocusNode();
  final ScrollController _scrollController = ScrollController();
  String? _lastProcessedTagId; // Track last processed tag to prevent duplicate searches
  DateTime? _lastTagDetectionTime; // Track last tag detection time
  static const Duration _tagDetectionCooldown = Duration(milliseconds: 1500); // Cooldown period
  final Map<String, int> _unitsToServe = {}; // Track units to serve for each beneficiary

  late final String _effectiveQueueName; // Day-specific key for Multi Day queues


  @override
  void initState() {
    super.initState();
    _availableUnits = widget.queue.numberOfAvailableUnits;
    _servingOption = 'queueOrder'; // Default to Queue order sequence

    // Multi Day beneficiaries are saved under a day-specific queue key:
    //   <queue.name>_YYYY-MM-DD
    // Multi Day navigation creates a "dayQueue" with fromDate/toDate set to that day,
    // so we can derive the correct key from widget.queue.fromDate.
    if (widget.queue.isMultiDay) {
      final day = DateTime(widget.queue.fromDate.year, widget.queue.fromDate.month, widget.queue.fromDate.day);
      final dayStr =
          '${day.year}-${day.month.toString().padLeft(2, '0')}-${day.day.toString().padLeft(2, '0')}';
      _effectiveQueueName = '${widget.queue.name}_$dayStr';
    } else {
      _effectiveQueueName = widget.queue.name;
    }

    // Filter initial beneficiaries to only include those assigned to this queue
    _localBeneficiaries = widget.beneficiaries
        .where((b) => b.initialAssignedQueuePoint == _effectiveQueueName)
        .toList();

    // Load beneficiaries from Firebase assigned to this queue (async, non-blocking)
    _loadQueueBeneficiaries();
    
    // Listen to search controller changes to clear last processed tag when user manually edits
    _searchController.addListener(() {
      // Clear last processed tag ID if user manually edits the field
      // This allows re-searching for the same tag if needed
      if (_lastProcessedTagId != null) {
        final currentText = _searchController.text.trim();
        if (currentText != _lastProcessedTagId) {
          _lastProcessedTagId = null;
          _lastTagDetectionTime = null;
        }
      }
    });
    
    // Auto-focus search field and start NFC detection
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _searchFocusNode.requestFocus();
      _startNFCDetection();
    });
  }

  Future<void> _loadQueueBeneficiaries() async {
    try {
      // Use a more efficient query: load by distribution area with limit and activeOnly
      // This is much faster than loading all beneficiaries
      final allAreaBeneficiaries = await BeneficiaryService.getBeneficiariesByArea(
        widget.queue.distributionArea,
        limit: 1000, // Reasonable limit for a distribution area
        activeOnly: true, // Only active beneficiaries
      ).first;
      
      // For multi-day queues, also check queueHistory to find beneficiaries with queue numbers for this day
      Set<String> beneficiaryIdsFromHistory = {};
      if (widget.queue.isMultiDay) {
        try {
          final historyQuery = await FirebaseService.firestore
              .collection('queueHistory')
              .where('dayQueueName', isEqualTo: _effectiveQueueName)
              .where('action', isEqualTo: 'issued')
              .limit(500) // Limit to avoid loading too much
              .get();
          
          beneficiaryIdsFromHistory = historyQuery.docs
              .map((doc) => doc.data()['beneficiaryId'] as String?)
              .where((id) => id != null)
              .cast<String>()
              .toSet();
        } catch (e) {
          print('Warning: Could not check queueHistory: $e');
        }
      }
      
      // Filter by queue name OR by queueHistory
      final queueBeneficiaries = allAreaBeneficiaries.where((b) {
        // Direct assignment to this queue/day
        if (b.initialAssignedQueuePoint == _effectiveQueueName) {
          return true;
        }
        // For multi-day queues, check if they have a queue number in history for this day
        if (widget.queue.isMultiDay && beneficiaryIdsFromHistory.contains(b.id)) {
          return true;
        }
        return false;
      }).toList();
      
      if (mounted) {
        setState(() {
          _localBeneficiaries = queueBeneficiaries;
        });
      }
    } catch (e) {
      print('Error loading queue beneficiaries: $e');
      // Keep existing beneficiaries if loading fails
    }
  }

  @override
  void dispose() {
    // Stop NFC session when screen is disposed
    NFCHelper.stopNFCSession();
    _searchController.dispose();
    _searchFocusNode.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  void _startNFCDetection() async {
    if (kIsWeb) return;
    
    try {
      // Check if NFC is available
      final isAvailable = await NFCHelper.isNFCAvailable();
      if (!isAvailable) {
        print('NFC: NFC not available on this device');
        return;
      }
      
      print('NFC: Starting NFC detection for serving screen...');
      
      // Start NFC session with callback to handle detected tags
      await NFCHelper.startNFCSession(
        context: context,
        onTagDetected: (String tagId) {
          print('NFC: Tag detected in serving screen: $tagId');
          
          // Check for duplicate detection within cooldown period
          final now = DateTime.now();
          if (_lastProcessedTagId == tagId) {
            if (_lastTagDetectionTime != null && 
                now.difference(_lastTagDetectionTime!) < _tagDetectionCooldown) {
              print('NFC: ⏭️ Same tag detected within cooldown, ignoring: $tagId');
              return; // Ignore duplicate detection
            }
          }
          
          // Update tracking
          _lastProcessedTagId = tagId;
          _lastTagDetectionTime = now;
          
          // Store original tag ID for searching
          _originalNfcTagId = tagId;
          
          // Search for beneficiary by NFC code (use original value)
          _findBeneficiaryByNFC(tagId);
        },
        onError: (String error) {
          print('NFC: Error in serving screen: $error');
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('NFC Error: $error'),
                backgroundColor: Colors.orange,
                duration: const Duration(seconds: 2),
              ),
            );
          }
        },
      );
    } catch (e) {
      print('NFC: Error starting NFC detection: $e');
    }
  }

  Future<void> _handleSearchInput(String value) async {
    if (value.isEmpty) {
      setState(() {
        _selectedBeneficiary = null;
      });
      return;
    }

    // Normalize the search value (trim and uppercase for comparison)
    final normalizedValue = value.trim();
    Beneficiary? foundBeneficiary;
    
    // Get the list to search in - if "without tickets" or "no order" mode, search all beneficiaries from distribution area
    List<Beneficiary> searchList = _localBeneficiaries;
    if (_servingOption == 'withoutTickets' || _servingOption == 'noOrder') {
      try {
        // Load all beneficiaries from the queue's distribution area
        final allAreaBeneficiaries = await BeneficiaryService.getBeneficiariesByArea(widget.queue.distributionArea).first;
        searchList = allAreaBeneficiaries;
      } catch (e) {
        print('Error loading area beneficiaries: $e');
        // Fall back to local list
        searchList = _localBeneficiaries;
      }
    }

    // Try to find beneficiary by different methods - check all possibilities
    // 1. Try NFC code (case-insensitive, with or without "NFC_" prefix)
    try {
      final nfcMatches = searchList.where((b) {
        if (b.nfcPreprintedCode == null) return false;
        final nfcCode = b.nfcPreprintedCode!.toUpperCase().trim();
        final searchValue = normalizedValue.toUpperCase();
        // Match exact or with/without NFC_ prefix
        return nfcCode == searchValue || 
               nfcCode == 'NFC_$searchValue' || 
               nfcCode.replaceFirst('NFC_', '') == searchValue;
      }).toList();
      
      if (nfcMatches.length == 1) {
        foundBeneficiary = nfcMatches.first;
      }
    } catch (e) {
      // Continue to other methods
    }

    // 2. Try mobile number (flexible matching - exact or partial)
    if (foundBeneficiary == null) {
      try {
        // Remove any spaces or dashes from mobile number
        final cleanValue = normalizedValue.replaceAll(RegExp(r'[\s\-]'), '');
        
        // Check if it looks like a mobile number (starts with 01 and has 11 digits)
        if (RegExp(r'^01[0-2,5]?[0-9]{0,9}$').hasMatch(cleanValue)) {
          final mobileMatches = searchList.where((b) {
            final mobileNumber = b.mobileNumber;
            if (mobileNumber == null || mobileNumber.isEmpty) return false;
            final mobile = mobileNumber.replaceAll(RegExp(r'[\s\-]'), '');
            // Exact match or starts with the entered value
            return mobile == cleanValue || 
                   (cleanValue.length >= 3 && mobile.startsWith(cleanValue));
          }).toList();
          
          if (mobileMatches.length == 1) {
            foundBeneficiary = mobileMatches.first;
          } else if (mobileMatches.length > 1 && cleanValue.length == 11) {
            // If multiple matches but we have full 11 digits, try exact match
            final exactMatch = mobileMatches.firstWhere(
              (b) {
                final mobileNumber = b.mobileNumber;
                return mobileNumber != null && 
                       mobileNumber.replaceAll(RegExp(r'[\s\-]'), '') == cleanValue;
              },
              orElse: () => mobileMatches.first,
            );
            foundBeneficiary = exactMatch;
          }
        }
      } catch (e) {
        // Continue to ID
      }
    }

    // 3. Try national ID (exact match or partial if long enough)
    if (foundBeneficiary == null) {
      try {
        // Remove any spaces or dashes from ID
        final cleanValue = normalizedValue.replaceAll(RegExp(r'[\s\-]'), '');
        
        // Check if it looks like an ID (all digits, at least 11 characters)
        if (RegExp(r'^[0-9]{11,}$').hasMatch(cleanValue)) {
          final idMatches = searchList.where((b) {
            final idNumber = b.idNumber;
            if (idNumber == null || idNumber.isEmpty) return false;
            final id = idNumber.replaceAll(RegExp(r'[\s\-]'), '');
            // Exact match or starts with the entered value (if at least 11 digits entered)
            return id == cleanValue || 
                   (cleanValue.length >= 11 && id.startsWith(cleanValue));
          }).toList();
          
          if (idMatches.length == 1) {
            foundBeneficiary = idMatches.first;
          } else if (idMatches.length > 1 && cleanValue.length >= 11) {
            // If multiple matches but we have full ID, try exact match
            final exactMatch = idMatches.firstWhere(
              (b) {
                final idNumber = b.idNumber;
                return idNumber != null && 
                       idNumber.replaceAll(RegExp(r'[\s\-]'), '') == cleanValue;
              },
              orElse: () => idMatches.first,
            );
            foundBeneficiary = exactMatch;
          }
        }
      } catch (e) {
        // Not found
      }
    }

    // 4. If still not found, try name search as fallback (partial match)
    if (foundBeneficiary == null && normalizedValue.length >= 3) {
      try {
        final nameMatches = searchList.where((b) {
          final name = b.name.toLowerCase();
          return name.contains(normalizedValue.toLowerCase());
        }).toList();
        
        if (nameMatches.length == 1) {
          foundBeneficiary = nameMatches.first;
        }
      } catch (e) {
        // Not found
      }
    }

    // For "No Order" mode, if not found in local/area list, search directly in Firebase
    if (foundBeneficiary == null && _servingOption == 'noOrder') {
      try {
        final cleanValue = normalizedValue.replaceAll(RegExp(r'[\s\-]'), '');
        
        // Try NFC first (if value looks like NFC code)
        if (normalizedValue.length >= 8 && (normalizedValue.toUpperCase().contains('NFC') || !RegExp(r'^[0-9]+$').hasMatch(normalizedValue))) {
          foundBeneficiary = await BeneficiaryService.getBeneficiaryByNFC(normalizedValue);
        }
        
        // Try mobile number (if it looks like a mobile number)
        if (foundBeneficiary == null && RegExp(r'^01[0-2,5]?[0-9]{8,9}$').hasMatch(cleanValue)) {
          foundBeneficiary = await BeneficiaryService.getBeneficiaryByMobile(cleanValue);
        }
        
        // Try national ID (if it looks like an ID - all digits, 11+ characters)
        if (foundBeneficiary == null && RegExp(r'^[0-9]{11,}$').hasMatch(cleanValue)) {
          foundBeneficiary = await BeneficiaryService.getBeneficiaryByIdNumber(cleanValue);
        }
        
        // If found in Firebase and not in local list, add to local list temporarily for serving
        if (foundBeneficiary != null) {
          // Check if beneficiary is from the same distribution area
          if (foundBeneficiary.distributionArea != widget.queue.distributionArea) {
            // Not from same area - show error
            if (mounted) {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Beneficiary is not assigned to this distribution area'),
                  backgroundColor: Colors.orange,
                ),
              );
            }
            foundBeneficiary = null;
          } else if (!_localBeneficiaries.any((b) => b.id == foundBeneficiary!.id)) {
            // Add to local list if not already present
            setState(() {
              _localBeneficiaries.add(foundBeneficiary!);
            });
          }
        }
      } catch (e) {
        print('Error searching in Firebase for No Order mode: $e');
      }
    }

    // If "without tickets" mode and beneficiary found, check eligibility and add to queue if needed
    if (foundBeneficiary != null && _servingOption == 'withoutTickets') {
      final isEligible = await _checkWithoutTicketsEligibility(foundBeneficiary);
      if (isEligible) {
        // Add beneficiary to queue without queue number
        await _addBeneficiaryToQueueWithoutTicket(foundBeneficiary);
      } else {
        // Not eligible - show message and don't select
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Beneficiary is not eligible for without tickets serving. They may already be in this queue or have a queue number.'),
              backgroundColor: Colors.orange,
              duration: Duration(seconds: 3),
            ),
          );
        }
        return;
      }
    }

    // Update selection if found
    if (foundBeneficiary != null) {
      setState(() {
        _selectedBeneficiary = foundBeneficiary;
        if (normalizedValue.toUpperCase().contains('NFC') || 
            (normalizedValue.length >= 8 && !RegExp(r'^[0-9]+$').hasMatch(normalizedValue))) {
          _nfcCode = normalizedValue;
        }
      });
      _scrollToBeneficiary(foundBeneficiary);
      
      // Show success feedback
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('${AppLanguage.translate('Beneficiary found')}: ${foundBeneficiary.name}'),
            backgroundColor: Colors.green,
            duration: const Duration(seconds: 2),
          ),
        );
      }
    } else {
      // Clear selection if no match found
      setState(() {
        _selectedBeneficiary = null;
      });
    }
  }
  
  // Check if beneficiary is eligible for "without tickets" serving
  Future<bool> _checkWithoutTicketsEligibility(Beneficiary beneficiary) async {
    // 1. Check if beneficiary is NOT in this queue
    if (beneficiary.initialAssignedQueuePoint == _effectiveQueueName) {
      return false; // Already in this queue
    }
    
    // 2. Check if beneficiary IS assigned to the queue's distribution area
    if (beneficiary.distributionArea != widget.queue.distributionArea) {
      return false; // Not assigned to this distribution area
    }
    
    // 3. Check if beneficiary does NOT have a queue number for this queue
    // For multi-day queues, check queueHistory
    if (widget.queue.isMultiDay) {
      try {
        final historyQuery = await FirebaseService.firestore
            .collection('queueHistory')
            .where('dayQueueName', isEqualTo: _effectiveQueueName)
            .where('beneficiaryId', isEqualTo: beneficiary.id)
            .where('action', isEqualTo: 'issued')
            .get();
        
        if (historyQuery.docs.isNotEmpty) {
          return false; // Has a queue number for this day
        }
      } catch (e) {
        print('Error checking queueHistory: $e');
        // If we can't check, assume eligible (fail open)
      }
    } else {
      // For single-day queues, check if beneficiary has a queue number for this queue
      if (beneficiary.initialAssignedQueuePoint == widget.queue.name && beneficiary.queueNumber != null) {
        return false; // Has a queue number for this queue
      }
    }
    
    return true; // All conditions met
  }
  
  // Add beneficiary to queue without issuing a queue number
  Future<void> _addBeneficiaryToQueueWithoutTicket(Beneficiary beneficiary) async {
    try {
      // Update beneficiary's initialAssignedQueuePoint to this queue
      final updatedBeneficiary = beneficiary.copyWith(
        initialAssignedQueuePoint: _effectiveQueueName,
        // Don't set queueNumber - leave it null to indicate "Has No Ticket"
      );
      
      await BeneficiaryService.updateBeneficiary(beneficiary.id, updatedBeneficiary);
      
      // Add to local list if not already present
      if (!_localBeneficiaries.any((b) => b.id == beneficiary.id)) {
        setState(() {
          _localBeneficiaries.add(updatedBeneficiary);
        });
      } else {
        // Update existing entry
        final index = _localBeneficiaries.indexWhere((b) => b.id == beneficiary.id);
        if (index != -1) {
          setState(() {
            _localBeneficiaries[index] = updatedBeneficiary;
          });
        }
      }
      
      print('✅ Added beneficiary ${beneficiary.id} to queue $_effectiveQueueName without ticket');
    } catch (e) {
      print('Error adding beneficiary to queue: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error adding beneficiary to queue: $e'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 3),
          ),
        );
      }
    }
  }

  void _detectByNFC() async {
    setState(() {
      _isNFCScanning = true;
      _selectedBeneficiary = null;
    });

    // Simulate NFC scanning
    await Future.delayed(const Duration(milliseconds: 1000));
    
    // In real app, this would use NFC reader
    // For now, show dialog to enter NFC code
    final nfcCode = await showDialog<String>(
      context: context,
      builder: (context) {
        final controller = TextEditingController();
        return AlertDialog(
          title: Text(AppLanguage.translate('Scan NFC Card')),
          content: TextField(
            controller: controller,
            decoration: InputDecoration(
              hintText: AppLanguage.translate('Enter NFC code'),
              prefixIcon: const Icon(Icons.nfc),
            ),
            autofocus: true,
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: Text(AppLanguage.translate('Cancel')),
            ),
            TextButton(
              onPressed: () => Navigator.pop(context, controller.text),
              child: Text(AppLanguage.translate('OK')),
            ),
          ],
        );
      },
    );

    setState(() {
      _isNFCScanning = false;
    });

    if (nfcCode != null && nfcCode.isNotEmpty) {
      _findBeneficiaryByNFC(nfcCode);
    }
  }

  void _detectByNationalID() async {
    // Simulate OCR scanning
    final idNumber = await showDialog<String>(
      context: context,
      builder: (context) {
        final controller = TextEditingController();
        return AlertDialog(
          title: Text(AppLanguage.translate('Scan National ID')),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextField(
                controller: controller,
                decoration: InputDecoration(
                  hintText: AppLanguage.translate('Enter ID number'),
                  prefixIcon: const Icon(Icons.credit_card),
                ),
                keyboardType: TextInputType.number,
                autofocus: true,
              ),
              const SizedBox(height: 16),
              ElevatedButton.icon(
                onPressed: () {
                  // Simulate OCR scan
                  controller.text = '29000000000'; // Example ID
                },
                icon: const Icon(Icons.camera_alt),
                label: Text(AppLanguage.translate('Scan ID')),
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: Text(AppLanguage.translate('Cancel')),
            ),
            TextButton(
              onPressed: () => Navigator.pop(context, controller.text),
              child: Text(AppLanguage.translate('OK')),
            ),
          ],
        );
      },
    );

    if (idNumber != null && idNumber.isNotEmpty) {
      _findBeneficiaryByID(idNumber);
    }
  }

  void _detectByMobile() {
    showDialog(
      context: context,
      builder: (context) {
        final controller = TextEditingController();
        return AlertDialog(
          title: Text(AppLanguage.translate('Enter Mobile Number')),
          content: TextField(
            controller: controller,
            decoration: InputDecoration(
              hintText: AppLanguage.translate('Enter mobile number'),
              prefixIcon: const Icon(Icons.phone),
            ),
            keyboardType: TextInputType.phone,
            autofocus: true,
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: Text(AppLanguage.translate('Cancel')),
            ),
            TextButton(
              onPressed: () {
                if (controller.text.isNotEmpty) {
                  Navigator.pop(context);
                  _findBeneficiaryByMobile(controller.text);
                }
              },
              child: Text(AppLanguage.translate('OK')),
            ),
          ],
        );
      },
    );
  }

  void _findBeneficiaryByNFC(String nfcCode) {
    if (!mounted) return;
    
    // Normalize the NFC code for comparison
    final normalizedNfcCode = nfcCode.trim().toUpperCase();
    Beneficiary? foundBeneficiary;
    
    try {
      // Try exact match first
      foundBeneficiary = _localBeneficiaries.firstWhere(
        (b) {
          if (b.nfcPreprintedCode == null || b.nfcPreprintedCode!.isEmpty) return false;
          final beneficiaryNfc = b.nfcPreprintedCode!.trim().toUpperCase();
          return beneficiaryNfc == normalizedNfcCode;
        },
      );
    } catch (e) {
      // Try matching with/without NFC_ prefix
      try {
        foundBeneficiary = _localBeneficiaries.firstWhere(
          (b) {
            if (b.nfcPreprintedCode == null || b.nfcPreprintedCode!.isEmpty) return false;
            final beneficiaryNfc = b.nfcPreprintedCode!.trim().toUpperCase();
            // Match exact, with NFC_ prefix, or without NFC_ prefix
            return beneficiaryNfc == normalizedNfcCode ||
                   beneficiaryNfc == 'NFC_$normalizedNfcCode' ||
                   beneficiaryNfc.replaceFirst('NFC_', '') == normalizedNfcCode ||
                   normalizedNfcCode.replaceFirst('NFC_', '') == beneficiaryNfc;
          },
        );
      } catch (e2) {
      foundBeneficiary = null;
      }
    }

    if (foundBeneficiary != null) {
      setState(() {
        _selectedBeneficiary = foundBeneficiary;
        _nfcCode = nfcCode;
        _originalNfcTagId = nfcCode; // Store original for searching
        // Display masked version in search field
        _searchController.text = NFCHelper.maskNfcTagId(nfcCode);
      });
      _scrollToBeneficiary(foundBeneficiary);
      
      // Show success feedback
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('${AppLanguage.translate('Beneficiary found')}: ${foundBeneficiary.name}'),
          backgroundColor: Colors.green,
          duration: const Duration(seconds: 2),
        ),
      );
    } else {
      // Clear selection if not found
      setState(() {
        _selectedBeneficiary = null;
      });
      
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('${AppLanguage.translate('Beneficiary not found')} for NFC: $nfcCode'),
          backgroundColor: Colors.orange,
          duration: const Duration(seconds: 2),
        ),
      );
    }
  }

  void _findBeneficiaryByID(String idNumber) {
    Beneficiary? foundBeneficiary;
    try {
      foundBeneficiary = _localBeneficiaries.firstWhere(
        (b) => b.idNumber == idNumber,
      );
    } catch (e) {
      foundBeneficiary = null;
    }

    if (foundBeneficiary != null) {
      setState(() {
        _selectedBeneficiary = foundBeneficiary;
      });
      _scrollToBeneficiary(foundBeneficiary);
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(AppLanguage.translate('Beneficiary not found'))),
      );
    }
  }

  void _findBeneficiaryByMobile(String mobileNumber) {
    Beneficiary? foundBeneficiary;
    try {
      foundBeneficiary = _localBeneficiaries.firstWhere(
        (b) => b.mobileNumber == mobileNumber,
      );
    } catch (e) {
      foundBeneficiary = null;
    }

    if (foundBeneficiary != null) {
      setState(() {
        _selectedBeneficiary = foundBeneficiary;
      });
      _scrollToBeneficiary(foundBeneficiary);
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(AppLanguage.translate('Beneficiary not found'))),
      );
    }
  }

  void _scrollToBeneficiary(Beneficiary beneficiary) {
    // Find the index of the beneficiary in the sorted list
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted || !_scrollController.hasClients) return;
      
      // Get the current sorted beneficiaries list
      final sortedBeneficiaries = List<Beneficiary>.from(_localBeneficiaries);
      if (_servingOption != 'noOrder') {
        sortedBeneficiaries.sort((a, b) => (a.queueNumber ?? 0).compareTo(b.queueNumber ?? 0));
      }
      
      final index = sortedBeneficiaries.indexWhere((b) => b.id == beneficiary.id);
      if (index >= 0) {
        // Calculate approximate position (each item is roughly 100 pixels tall)
        final itemHeight = 100.0;
        final targetOffset = index * itemHeight;
        
        // Scroll to the beneficiary with animation
        _scrollController.animateTo(
          targetOffset.clamp(0.0, _scrollController.position.maxScrollExtent),
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeInOut,
        );
      }
    });
  }

  void _selectBeneficiary(Beneficiary beneficiary) {
    setState(() {
      _selectedBeneficiary = beneficiary;
    });
  }

  void _showBeneficiaryImage(Beneficiary beneficiary) {
    if (beneficiary.photoPath == null || beneficiary.photoPath!.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('No photo available for this beneficiary'),
          duration: Duration(seconds: 2),
        ),
      );
      return;
    }

    showDialog(
      context: context,
      barrierColor: Colors.black87,
      builder: (context) => Dialog(
        backgroundColor: Colors.transparent,
        insetPadding: const EdgeInsets.all(16),
        child: Stack(
          children: [
            Center(
              child: InteractiveViewer(
                minScale: 0.5,
                maxScale: 4.0,
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(12),
                  child: beneficiary.photoPath!.startsWith('http://') || beneficiary.photoPath!.startsWith('https://')
                      ? Image.network(
                          beneficiary.photoPath!,
                          fit: BoxFit.contain,
                          errorBuilder: (context, error, stackTrace) {
                            return Container(
                              width: 300,
                              height: 300,
                              color: Colors.grey[300],
                              child: const Column(
                                mainAxisAlignment: MainAxisAlignment.center,
                                children: [
                                  Icon(Icons.error_outline, size: 48, color: Colors.grey),
                                  SizedBox(height: 8),
                                  Text('Failed to load image'),
                                ],
                              ),
                            );
                          },
                        )
                      : beneficiary.photoPath!.startsWith('assets/')
                          ? Image.asset(
                              beneficiary.photoPath!,
                              fit: BoxFit.contain,
                              errorBuilder: (context, error, stackTrace) {
                                return Container(
                                  width: 300,
                                  height: 300,
                                  color: Colors.grey[300],
                                  child: const Column(
                                    mainAxisAlignment: MainAxisAlignment.center,
                                    children: [
                                      Icon(Icons.error_outline, size: 48, color: Colors.grey),
                                      SizedBox(height: 8),
                                      Text('Failed to load image'),
                                    ],
                                  ),
                                );
                              },
                            )
                          : Image.file(
                              File(beneficiary.photoPath!),
                              fit: BoxFit.contain,
                              errorBuilder: (context, error, stackTrace) {
                                return Container(
                                  width: 300,
                                  height: 300,
                                  color: Colors.grey[300],
                                  child: const Column(
                                    mainAxisAlignment: MainAxisAlignment.center,
                                    children: [
                                      Icon(Icons.error_outline, size: 48, color: Colors.grey),
                                      SizedBox(height: 8),
                                      Text('Failed to load image'),
                                    ],
                                  ),
                                );
                              },
                            ),
                ),
              ),
            ),
            Positioned(
              top: 8,
              right: 8,
              child: IconButton(
                icon: const Icon(Icons.close, color: Colors.white, size: 28),
                onPressed: () => Navigator.of(context).pop(),
                style: IconButton.styleFrom(
                  backgroundColor: Colors.black54,
                  shape: const CircleBorder(),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildServingBody(List<Beneficiary> sortedBeneficiaries, Set<String> servedBeneficiaryIds, [Map<String, int> daySpecificUnitsTaken = const {}]) {
    return Column(
        children: [
          // Dynamic Search Field Section
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
            color: Colors.white,
            child: Row(
              children: [
                if (_isNFCScanning)
                  const Padding(
                    padding: EdgeInsets.only(right: 8),
                    child: SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    ),
                  ),
                Expanded(
                  child: TextField(
                    controller: _searchController,
                    focusNode: _searchFocusNode,
                    autofocus: true,
                    decoration: InputDecoration(
                      hintText: AppLanguage.translate('Scan NFC, Enter Mobile or National ID'),
                      prefixIcon: Icon(
                        _isNFCScanning ? Icons.nfc : Icons.search,
                        color: const Color(0xFF81CF01),
                      ),
                      suffixIcon: _searchController.text.isNotEmpty
                          ? IconButton(
                              icon: const Icon(Icons.clear),
                              onPressed: () {
                                _searchController.clear();
                                setState(() {
                                  _selectedBeneficiary = null;
                                });
                                _searchFocusNode.requestFocus();
                              },
                            )
                          : null,
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(8),
                        borderSide: const BorderSide(color: Color(0xFF81CF01)),
                      ),
                      enabledBorder: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(8),
                        borderSide: const BorderSide(color: Color(0xFF81CF01)),
                      ),
                      focusedBorder: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(8),
                        borderSide: const BorderSide(color: Color(0xFF81CF01), width: 2),
                      ),
                      filled: true,
                      fillColor: Colors.grey[50],
                      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                    ),
                    keyboardType: TextInputType.text,
                    textInputAction: TextInputAction.search,
                    onChanged: (value) {
                      _handleSearchInput(value);
                    },
                    onSubmitted: (value) {
                      _handleSearchInput(value);
                    },
                  ),
                ),
              ],
            ),
          ),
          // Selected Beneficiary Info
          if (_selectedBeneficiary != null)
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
              color: const Color(0xFF81CF01).withOpacity(0.1),
              child: Row(
                children: [
                  const Icon(Icons.person, color: Color(0xFF81CF01)),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          _selectedBeneficiary!.name,
                          style: const TextStyle(
                            fontWeight: FontWeight.bold,
                            fontSize: 16,
                            color: Color(0xFF1A237E),
                          ),
                        ),
                        Text(
                          'ID: ${_selectedBeneficiary!.idNumber}',
                          style: const TextStyle(fontSize: 12, color: Colors.grey),
                        ),
                      ],
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.close, color: Colors.red),
                    onPressed: () {
                      setState(() {
                        _selectedBeneficiary = null;
                      });
                    },
                  ),
                ],
              ),
            ),
          // Statistics Section
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
            color: Colors.white,
            child: Row(
              children: [
                Expanded(
                  child: _buildStatCard(
                    'Served',
                    '${sortedBeneficiaries.where((b) => servedBeneficiaryIds.contains(b.id)).length}',
                    Icons.check_circle,
                    Colors.green,
                  ),
                ),
                const SizedBox(width: 4),
                Expanded(
                  child: _buildStatCard(
                    'Attendees',
                    '${_localBeneficiaries.where((b) => b.queueNumber != null).length}',
                    Icons.people,
                    Colors.blue,
                  ),
                ),
                const SizedBox(width: 4),
                Expanded(
                  child: _buildStatCard(
                    'Available',
                    '$_availableUnits / ${widget.queue.numberOfAvailableUnits}',
                    Icons.inventory,
                    Colors.orange,
                  ),
                ),
                const SizedBox(width: 4),
                Expanded(
                  child: _buildStatCard(
                    'Est. Q Size',
                    '${widget.queue.estimatedQueueSize}',
                    Icons.assessment,
                    Colors.purple,
                  ),
                ),
              ],
            ),
          ),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
            decoration: BoxDecoration(
              color: Colors.blue.shade50,
              border: Border(bottom: BorderSide(color: Colors.grey[300]!)),
            ),
            child: Row(
              children: [
                const Icon(Icons.settings, size: 18, color: Colors.blue),
                const SizedBox(width: 8),
                const Text(
                  'Current Serving Option: ',
                  style: TextStyle(fontSize: 14, fontWeight: FontWeight.w500),
                ),
                Text(
                  _getServingOptionDisplayName(),
                  style: const TextStyle(
                    fontSize: 14,
                    fontWeight: FontWeight.bold,
                    color: Colors.blue,
                  ),
                ),
              ],
            ),
          ),
          InkWell(
            onTap: () => setState(() => _isQueueDetailsExpanded = !_isQueueDetailsExpanded),
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
              decoration: BoxDecoration(
                border: Border(bottom: BorderSide(color: Colors.grey[300]!)),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  const Text('Queue Details', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                  Icon(_isQueueDetailsExpanded ? Icons.keyboard_arrow_up : Icons.keyboard_arrow_down),
                ],
              ),
            ),
          ),
          AnimatedSize(
            duration: const Duration(milliseconds: 200),
            child: _isQueueDetailsExpanded
                ? Container(
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
                    color: Colors.grey[50],
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Padding(
                          padding: const EdgeInsets.only(bottom: 3),
                          child: Text('Name: ${widget.queue.name}', style: const TextStyle(fontSize: 13)),
                        ),
                        Padding(
                          padding: const EdgeInsets.only(bottom: 3),
                          child: Text('Queue Point: ${widget.queue.queuePoint}', style: const TextStyle(fontSize: 13)),
                        ),
                        Padding(
                          padding: const EdgeInsets.only(bottom: 3),
                          child: Text('Type: ${widget.queue.queueType}', style: const TextStyle(fontSize: 13)),
                        ),
                        Padding(
                          padding: const EdgeInsets.only(bottom: 3),
                          child: Text('Date Range: ${widget.queue.displayDateRange}', style: const TextStyle(fontSize: 13)),
                        ),
                        Padding(
                          padding: const EdgeInsets.only(bottom: 3),
                          child: Text('Time Range: ${widget.queue.displayTimeRange}', style: const TextStyle(fontSize: 13)),
                        ),
                        Text('Unit Name: ${widget.queue.unitName}', style: const TextStyle(fontSize: 13)),
                      ],
                    ),
                  )
                : const SizedBox.shrink(),
          ),
          Expanded(
            child: sortedBeneficiaries.isEmpty
                ? const Center(child: Text('No beneficiaries assigned'))
                : ListView.builder(
                    controller: _scrollController,
                    itemCount: sortedBeneficiaries.length,
                    itemBuilder: (context, index) {
                      final beneficiary = sortedBeneficiaries[index];
                      // Eligibility is based on beneficiary.numberOfUnits set during registration
                      final eligibleUnits = int.tryParse(beneficiary.numberOfUnits) ?? 1;
                      // For multi-day queues, use day-specific units taken; otherwise use global
                      final dayUnitsTaken = widget.queue.isMultiDay 
                          ? (daySpecificUnitsTaken[beneficiary.id] ?? 0)
                          : beneficiary.unitsTaken;
                      final remainingUnits = eligibleUnits - dayUnitsTaken;
                      final maxUnitsToServe = remainingUnits > 0 && _availableUnits > 0
                          ? (remainingUnits < _availableUnits ? remainingUnits : _availableUnits)
                          : 1;
                      
                      final isSelected = _selectedBeneficiary?.id == beneficiary.id;
                      return Card(
                        margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                        elevation: isSelected ? 4 : 1,
                        color: isSelected ? const Color(0xFF81CF01).withOpacity(0.1) : Colors.white,
                        child: Column(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            InkWell(
                              onTap: () => _selectBeneficiary(beneficiary),
                              child: ListTile(
                                leading: Stack(
                                  children: [
                                    GestureDetector(
                                      onTap: () {
                                        _showBeneficiaryImage(beneficiary);
                                      },
                                      child: beneficiary.photoPath != null
                                          ? CircleAvatar(
                                              backgroundImage: beneficiary.photoPath!.startsWith('http://') || beneficiary.photoPath!.startsWith('https://')
                                                  ? NetworkImage(beneficiary.photoPath!)
                                                  : beneficiary.photoPath!.startsWith('assets/')
                                                      ? AssetImage(beneficiary.photoPath!)
                                                      : FileImage(File(beneficiary.photoPath!)) as ImageProvider,
                                              onBackgroundImageError: (exception, stackTrace) {
                                                // Handle image loading errors gracefully
                                              },
                                            )
                                          : const CircleAvatar(child: Icon(Icons.person)),
                                    ),
                                  ],
                                ),
                                title: Text(
                                  beneficiary.name,
                                  style: TextStyle(
                                    fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                                    color: Colors.black87,
                                  ),
                                ),
                                subtitle: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      '${AppLanguage.translate('Eligible for')} ${dayUnitsTaken}/$eligibleUnits ${widget.queue.unitName.toLowerCase()}',
                                      style: TextStyle(
                                        fontWeight: FontWeight.w500,
                                        color: isSelected ? Colors.black87 : const Color(0xFF81CF01),
                                      ),
                                    ),
                                    if (beneficiary.entityName != null) Text('Entity: ${beneficiary.entityName}'),
                                    // Show "Has No Ticket" if beneficiary is in this queue but has no queue number
                                    if (beneficiary.initialAssignedQueuePoint == _effectiveQueueName && beneficiary.queueNumber == null)
                                      Container(
                                        margin: const EdgeInsets.only(top: 4),
                                        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                                        decoration: BoxDecoration(
                                          color: Colors.orange.withOpacity(0.2),
                                          borderRadius: BorderRadius.circular(4),
                                          border: Border.all(color: Colors.orange, width: 1),
                                        ),
                                        child: const Text(
                                          'Has No Ticket',
                                          style: TextStyle(
                                            color: Colors.orange,
                                            fontWeight: FontWeight.bold,
                                            fontSize: 11,
                                          ),
                                        ),
                                      ),
                                    if (beneficiary.queueNumber != null) Text('Queue #${beneficiary.queueNumber}'),
                                    if (beneficiary.idNumber.isNotEmpty) Text('ID: ${beneficiary.idNumber}'),
                                  ],
                                ),
                                trailing: servedBeneficiaryIds.contains(beneficiary.id)
                                    ? const Icon(Icons.check_circle, color: Colors.green)
                                    : null,
                              ),
                            ),
                            if (!servedBeneficiaryIds.contains(beneficiary.id) && remainingUnits > 0 && _availableUnits > 0)
                              Container(
                                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                                decoration: BoxDecoration(
                                  border: Border(
                                    top: BorderSide(color: Colors.grey[300]!),
                                  ),
                                ),
                                child: Row(
                                  mainAxisAlignment: MainAxisAlignment.center,
                                  children: [
                                    IconButton(
                                      onPressed: (_unitsToServe[beneficiary.id] ?? maxUnitsToServe) > 1
                                          ? () {
                                              setState(() {
                                                final currentValue = _unitsToServe[beneficiary.id] ?? maxUnitsToServe;
                                                if (currentValue > 1) {
                                                  _unitsToServe[beneficiary.id] = currentValue - 1;
                                                }
                                              });
                                            }
                                          : null,
                                      icon: const Icon(Icons.remove_circle_outline),
                                      iconSize: 24,
                                      color: Colors.blue,
                                    ),
                                    Container(
                                      width: 50,
                                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),
                                      decoration: BoxDecoration(
                                        border: Border.all(color: Colors.blue),
                                        borderRadius: BorderRadius.circular(8),
                                      ),
                                      child: Text(
                                        '${_unitsToServe[beneficiary.id] ?? maxUnitsToServe}',
                                        textAlign: TextAlign.center,
                                        style: const TextStyle(
                                          fontSize: 18,
                                          fontWeight: FontWeight.bold,
                                          color: Colors.blue,
                                        ),
                                      ),
                                    ),
                                    IconButton(
                                      onPressed: (_unitsToServe[beneficiary.id] ?? maxUnitsToServe) < maxUnitsToServe
                                          ? () {
                                              setState(() {
                                                final currentValue = _unitsToServe[beneficiary.id] ?? maxUnitsToServe;
                                                if (currentValue < maxUnitsToServe) {
                                                  _unitsToServe[beneficiary.id] = currentValue + 1;
                                                }
                                              });
                                            }
                                          : null,
                                      icon: const Icon(Icons.add_circle_outline),
                                      iconSize: 24,
                                      color: Colors.blue,
                                    ),
                                    const SizedBox(width: 16),
                                    ElevatedButton(
                                      onPressed: () {
                                        final units = _unitsToServe[beneficiary.id] ?? maxUnitsToServe;
                                        if (units > 0 && units <= remainingUnits && units <= _availableUnits) {
                                          _serveBeneficiary(beneficiary, units);
                                          setState(() {
                                            _unitsToServe.remove(beneficiary.id);
                                            _selectedBeneficiary = null;
                                          });
                                        }
                                      },
                                      style: ElevatedButton.styleFrom(
                                        backgroundColor: Colors.blue,
                                        foregroundColor: Colors.white,
                                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
                                        minimumSize: const Size(80, 40),
                                      ),
                                      child: Text(AppLanguage.translate('Serve'), style: const TextStyle(fontSize: 14, fontWeight: FontWeight.bold)),
                                    ),
                                  ],
                                ),
                              ),
                          ],
                        ),
                      );
                    },
                  ),
          ),
        ],
      );
  }

  Widget _buildStatCard(String label, String value, IconData icon, Color color) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 3),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(4),
        border: Border.all(color: color.withOpacity(0.3), width: 1),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, color: color, size: 12),
          const SizedBox(height: 1),
          Text(
            value,
            style: TextStyle(
              fontSize: 12,
              fontWeight: FontWeight.bold,
              color: color,
            ),
          ),
          const SizedBox(height: 1),
          Text(
            label,
            style: TextStyle(
              fontSize: 8,
              color: Colors.grey[700],
              fontWeight: FontWeight.w500,
            ),
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
        ],
      ),
    );
  }

  void _handleServingOption(String option) {
    setState(() {
      _servingOption = option;
    });
    Navigator.pop(context);
  }

  String _getServingOptionDisplayName() {
    switch (_servingOption) {
      case 'queueOrder':
        return 'Queue order sequence';
      case 'grace5':
        return 'Grace 5';
      case 'grace10':
        return 'Grace 10';
      case 'noOrder':
        return 'No Order';
      case 'withoutTickets':
        return 'Without Tickets';
      default:
        return 'None';
    }
  }

  Future<void> _serveBeneficiary(Beneficiary beneficiary, int units) async {
    if (units <= 0 || _availableUnits < units) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Not enough units available')),
      );
      return;
    }
    
    // Check if beneficiary was already served today in another queue with the same unit type
    try {
      final today = DateTime.now();
      final todayStart = DateTime(today.year, today.month, today.day);
      final todayEnd = todayStart.add(const Duration(days: 1));
      
      // Query queueHistory for served actions today for this beneficiary
      // Try to query with unitName filter first (for new records that have unitName stored)
      QuerySnapshot? servedHistoryQuery;
      try {
        servedHistoryQuery = await FirebaseService.firestore
            .collection('queueHistory')
            .where('beneficiaryId', isEqualTo: beneficiary.id)
            .where('action', isEqualTo: 'served')
            .where('unitName', isEqualTo: widget.queue.unitName)
            .where('performedAt', isGreaterThanOrEqualTo: FirebaseService.dateTimeToTimestamp(todayStart))
            .where('performedAt', isLessThan: FirebaseService.dateTimeToTimestamp(todayEnd))
            .get();
      } catch (e) {
        // If query fails (e.g., missing index or unitName field), fall back to querying without unitName filter
        print('Note: Could not query with unitName filter, trying without: $e');
        servedHistoryQuery = await FirebaseService.firestore
            .collection('queueHistory')
            .where('beneficiaryId', isEqualTo: beneficiary.id)
            .where('action', isEqualTo: 'served')
            .where('performedAt', isGreaterThanOrEqualTo: FirebaseService.dateTimeToTimestamp(todayStart))
            .where('performedAt', isLessThan: FirebaseService.dateTimeToTimestamp(todayEnd))
            .get();
      }
      
      // Check each served record to see if it's from a different queue with the same unit type
      for (var doc in servedHistoryQuery.docs) {
        final data = doc.data() as Map<String, dynamic>;
        final servedQueueId = data['queueId'] as String?;
        final dayQueueName = data['dayQueueName'] as String?;
        final servedUnitName = data['unitName'] as String?;
        
        // Skip if this is the same queue we're trying to serve in
        if (servedQueueId == widget.queue.name || dayQueueName == _effectiveQueueName) {
          continue;
        }
        
        // Check if unitName matches (either from stored field or by querying the queue)
        bool unitNameMatches = false;
        String? servedQueueName;
        
        if (servedUnitName != null && servedUnitName == widget.queue.unitName) {
          // UnitName is stored and matches
          unitNameMatches = true;
          servedQueueName = servedQueueId; // Use queueId as queue name
        } else if (servedQueueId != null) {
          // UnitName not stored, need to query the queue to check
          try {
            final servedQueueIdFromFirestore = await QueueService.getQueueIdByName(servedQueueId);
            if (servedQueueIdFromFirestore != null) {
              final servedQueue = await QueueService.getQueueById(servedQueueIdFromFirestore);
              if (servedQueue != null) {
                servedQueueName = servedQueue.name;
                if (servedQueue.unitName == widget.queue.unitName) {
                  unitNameMatches = true;
                }
              }
            }
          } catch (e) {
            print('Error checking served queue: $e');
            // Continue checking other records if this one fails
            continue;
          }
        }
        
        if (unitNameMatches && servedQueueName != null) {
          // Beneficiary was already served today in another queue with the same unit type
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('This beneficiary was already served ${widget.queue.unitName.toLowerCase()} today in queue "$servedQueueName". Cannot serve the same type again on the same day.'),
                backgroundColor: Colors.red,
                duration: const Duration(seconds: 5),
              ),
            );
          }
          return;
        }
      }
    } catch (e) {
      print('Error checking if beneficiary was served today in another queue: $e');
      // Continue with serving if check fails (fail open)
    }
    
    // Eligibility is based on beneficiary.numberOfUnits set during registration
    final eligibleUnits = int.tryParse(beneficiary.numberOfUnits) ?? 1;
    
    // For multi-day queues, validate against day-specific units served, not global
    if (widget.queue.isMultiDay) {
      // Get day-specific units already served today
      try {
        final dayHistoryQuery = await FirebaseService.firestore
            .collection('queueHistory')
            .where('dayQueueName', isEqualTo: _effectiveQueueName)
            .where('beneficiaryId', isEqualTo: beneficiary.id)
            .where('action', isEqualTo: 'served')
            .get();
        
        int dayUnitsTaken = 0;
        for (var doc in dayHistoryQuery.docs) {
          final data = doc.data();
          final unitsServed = data['unitsServed'] as int? ?? 0;
          dayUnitsTaken += unitsServed;
        }
        
        // Validate: day-specific units taken + new units must not exceed eligible units
        if (dayUnitsTaken + units > eligibleUnits) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Cannot exceed eligible units. Already served $dayUnitsTaken units today.')),
          );
          return;
        }
      } catch (e) {
        print('⚠️ Warning: Could not check day-specific units served: $e');
        // Fall back to global validation if history check fails
        final newUnitsTaken = beneficiary.unitsTaken + units;
        if (newUnitsTaken > eligibleUnits) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Cannot exceed eligible units')),
          );
          return;
        }
      }
    } else {
      // For single-day queues, use global validation
      final newUnitsTaken = beneficiary.unitsTaken + units;
      if (newUnitsTaken > eligibleUnits) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Cannot exceed eligible units')),
        );
        return;
      }
    }
    
    // Calculate newUnitsTaken for updating beneficiary (still update global for tracking)
    final newUnitsTaken = beneficiary.unitsTaken + units;

    // Show loading indicator
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const Center(child: CircularProgressIndicator()),
    );

    try {
      // Get current admin ID for servedBy field
      final servedBy = AdminService.currentAdminId ?? 'unknown';
      
      // Update beneficiary in Firebase with exact unitsTaken value
      // This ensures the "Eligible for X/Y meals" label updates correctly
      final updatedBeneficiary = beneficiary.copyWith(
        unitsTaken: newUnitsTaken,
        isServed: newUnitsTaken >= eligibleUnits,
      );
      
      print('🔄 Updating beneficiary ${beneficiary.id}: unitsTaken from ${beneficiary.unitsTaken} to $newUnitsTaken');
      
      // Update beneficiary with new unitsTaken and isServed status
      await BeneficiaryService.updateBeneficiary(beneficiary.id, updatedBeneficiary);
      
      print('✅ Beneficiary updated in Firebase: unitsTaken = $newUnitsTaken, isServed = ${updatedBeneficiary.isServed}');
      
      // Record serving action in queueHistory for all queues (for tracking and validation)
      try {
        await FirebaseService.firestore.collection('queueHistory').add({
          'queueId': widget.queue.name,
          'dayQueueName': widget.queue.isMultiDay ? _effectiveQueueName : widget.queue.name, // Store the day-specific queue name for multi-day, or queue name for single-day
          'beneficiaryId': beneficiary.id,
          'action': 'served',
          'unitsServed': units,
          'totalUnitsTaken': newUnitsTaken,
          'unitName': widget.queue.unitName, // Store unitName for easier validation
          'performedBy': AdminService.currentAdmin?.fullName ?? 'system',
          'performedAt': FieldValue.serverTimestamp(),
        });
        print('✅ Recorded serving action in queueHistory for beneficiary ${beneficiary.id}');
      } catch (e) {
        print('⚠️ Warning: Could not record serving action in queueHistory: $e');
        // Don't fail the operation if history tracking fails
      }
      
      // Also record serving metadata (servedAt, servedBy) if needed
      // We can add this to updateBeneficiary later, or use a separate update
      try {
        await FirebaseService.firestore.collection('beneficiaries').doc(beneficiary.id).update({
          'servedAt': FieldValue.serverTimestamp(),
          'servedBy': servedBy,
        });
      } catch (e) {
        print('Note: Could not update servedAt/servedBy: $e');
        // Non-critical, continue
      }
      
      // Update queue's available units in Firebase
      final newAvailableUnits = _availableUnits - units;
      final queueId = await QueueService.getQueueIdByName(widget.queue.name);
      if (queueId != null) {
        await QueueService.updateQueue(queueId, widget.queue.copyWith(
          numberOfAvailableUnits: newAvailableUnits,
        ));
      }
      
      // Update local state immediately for instant UI feedback
      if (mounted) {
        Navigator.pop(context); // Close loading dialog
        
        // Update beneficiary in local list by ID (not index, since list might be filtered/sorted)
        final beneficiaryIndex = _localBeneficiaries.indexWhere((b) => b.id == beneficiary.id);
        if (beneficiaryIndex != -1) {
          _localBeneficiaries[beneficiaryIndex] = updatedBeneficiary;
        } else {
          // If not found in local list, add it (shouldn't happen, but safety check)
          _localBeneficiaries.add(updatedBeneficiary);
        }
        
        setState(() {
          _availableUnits = newAvailableUnits;
          // Force rebuild to show updated unitsTaken immediately
          // StreamBuilder will also update when Firebase stream emits new data
        });
        
        widget.onBeneficiaryUpdated(updatedBeneficiary);
        widget.onQueueUpdated(widget.queue.copyWith(numberOfAvailableUnits: newAvailableUnits));
        
        // Calculate day-specific units taken for success message
        int dayUnitsAfterServing = 0;
        if (widget.queue.isMultiDay) {
          try {
            final dayHistoryQuery = await FirebaseService.firestore
                .collection('queueHistory')
                .where('dayQueueName', isEqualTo: _effectiveQueueName)
                .where('beneficiaryId', isEqualTo: beneficiary.id)
                .where('action', isEqualTo: 'served')
                .get();
            
            for (var doc in dayHistoryQuery.docs) {
              final data = doc.data();
              final unitsServed = data['unitsServed'] as int? ?? 0;
              dayUnitsAfterServing += unitsServed;
            }
          } catch (e) {
            // Fall back to using beneficiary.unitsTaken if query fails
            dayUnitsAfterServing = updatedBeneficiary.unitsTaken;
          }
        } else {
          dayUnitsAfterServing = updatedBeneficiary.unitsTaken;
        }
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('${units} unit(s) served successfully. Eligible: $dayUnitsAfterServing/$eligibleUnits ${widget.queue.unitName.toLowerCase()}'),
            backgroundColor: Colors.green,
          ),
        );
        
        print('✅ UI updated: beneficiary ${beneficiary.name} now shows $dayUnitsAfterServing/$eligibleUnits');
      }
    } catch (e) {
      print('Error serving beneficiary: $e');
      if (mounted) {
        Navigator.pop(context); // Close loading dialog
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error serving units: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    // For multi-day queues, use queueHistory to find all beneficiaries for this day
    if (widget.queue.isMultiDay) {
      return StreamBuilder<QuerySnapshot>(
        stream: FirebaseService.firestore
            .collection('queueHistory')
            .where('dayQueueName', isEqualTo: _effectiveQueueName)
            .where('action', isEqualTo: 'issued')
            .snapshots(),
        builder: (context, historySnapshot) {
          // Get beneficiary IDs from queueHistory
          final beneficiaryIdsFromHistory = historySnapshot.hasData
              ? historySnapshot.data!.docs
                  .map((doc) => doc.data() as Map<String, dynamic>)
                  .map((data) => data['beneficiaryId'] as String?)
                  .where((id) => id != null)
                  .cast<String>()
                  .toSet()
              : <String>{};
          
          // Load beneficiaries from stream (with limit for performance)
          return StreamBuilder<List<Beneficiary>>(
            stream: BeneficiaryService.getBeneficiariesByArea(
              widget.queue.distributionArea,
              limit: 1000, // Limit to reasonable number for performance
              activeOnly: true, // Only active beneficiaries
            ),
            builder: (context, snapshot) {
              // Filter beneficiaries to include those with queue numbers for this day
              final allAreaBeneficiaries = snapshot.hasData ? snapshot.data! : <Beneficiary>[];
              final queuePrefix = '${widget.queue.name}_';
              
              // Get beneficiaries who either:
              // 1. Have initialAssignedQueuePoint matching this day, OR
              // 2. Have a queue number in history for this day
              final filteredBeneficiaries = allAreaBeneficiaries.where((b) {
                // Direct assignment
                if (b.initialAssignedQueuePoint == _effectiveQueueName) {
                  return true;
                }
                // Check if queue point is for this multi-day queue
                if (b.initialAssignedQueuePoint.startsWith(queuePrefix)) {
                  // Check if they have a queue number in history for this specific day
                  if (beneficiaryIdsFromHistory.contains(b.id)) {
                    return true;
                  }
                }
                return false;
              }).toList();
              
              // Merge with local updates
              // Prefer stream data for numberOfUnits (eligibility) since it's the source of truth
              // Prefer local updates for unitsTaken/isServed (recently served) for immediate feedback
              final Map<String, Beneficiary> beneficiaryMap = {};
              // First add all from stream (most authoritative from Firebase, especially for numberOfUnits)
              for (var b in filteredBeneficiaries) {
                beneficiaryMap[b.id] = b;
              }
              // Then merge with local updates (might have recent serving updates not yet in stream)
              for (var b in _localBeneficiaries) {
                if (b.initialAssignedQueuePoint == _effectiveQueueName || 
                    beneficiaryIdsFromHistory.contains(b.id)) {
                  final streamed = beneficiaryMap[b.id];
                  if (streamed == null) {
                    // New beneficiary not in stream yet, add it
                    beneficiaryMap[b.id] = b;
                  } else {
                    // Merge: use stream's numberOfUnits (source of truth), but prefer local for unitsTaken/isServed if more recent
                    if (b.unitsTaken > streamed.unitsTaken || 
                        (b.unitsTaken == streamed.unitsTaken && b.isServed != streamed.isServed)) {
                      // Local has more recent serving data, but keep numberOfUnits from stream
                      beneficiaryMap[b.id] = b.copyWith(numberOfUnits: streamed.numberOfUnits);
                    } else {
                      // Stream is more recent or equal, use stream data (already in map)
                      // This ensures numberOfUnits updates are immediately reflected
                    }
                  }
                }
              }
              
              final currentBeneficiaries = beneficiaryMap.values.toList();
              // Update local list for search functionality
              _localBeneficiaries = currentBeneficiaries;

              final sortedBeneficiaries = List<Beneficiary>.from(currentBeneficiaries);
              if (_servingOption == 'noOrder') {
                // No order - serve in any order
              } else {
                // Sort by queue number
                sortedBeneficiaries.sort((a, b) => (a.queueNumber ?? 0).compareTo(b.queueNumber ?? 0));
              }

              final title = widget.queue.isMultiDay
                  ? 'Serving: ${widget.queue.name} (${widget.queue.fromDate.day}/${widget.queue.fromDate.month}/${widget.queue.fromDate.year})'
                  : 'Serving: ${widget.queue.name}';

              // Check queueHistory for served status for this specific day
              return StreamBuilder<QuerySnapshot>(
                stream: FirebaseService.firestore
                    .collection('queueHistory')
                    .where('dayQueueName', isEqualTo: _effectiveQueueName)
                    .where('action', isEqualTo: 'served')
                    .snapshots(),
                builder: (context, servedSnapshot) {
                  // Calculate day-specific units served for each beneficiary
                  final daySpecificUnitsTaken = <String, int>{};
                  if (servedSnapshot.hasData) {
                    for (var doc in servedSnapshot.data!.docs) {
                      final data = doc.data() as Map<String, dynamic>;
                      final beneficiaryId = data['beneficiaryId'] as String?;
                      final unitsServed = data['unitsServed'] as int? ?? 0;
                      if (beneficiaryId != null) {
                        daySpecificUnitsTaken[beneficiaryId] = 
                            (daySpecificUnitsTaken[beneficiaryId] ?? 0) + unitsServed;
                      }
                    }
                  }
                  
                  // Only mark as "served" if they've received their full eligible units
                  // Get eligible units for each beneficiary to check if fully served
                  final fullyServedBeneficiaryIds = <String>{};
                  for (var beneficiary in sortedBeneficiaries) {
                    final eligibleUnits = int.tryParse(beneficiary.numberOfUnits) ?? 1;
                    final dayUnitsTaken = daySpecificUnitsTaken[beneficiary.id] ?? 0;
                    if (dayUnitsTaken >= eligibleUnits) {
                      fullyServedBeneficiaryIds.add(beneficiary.id);
                    }
                  }

                  return Scaffold(
                    appBar: AppBar(
                      title: Text(title),
                      backgroundColor: const Color(0xFF81CF01),
                      foregroundColor: Colors.white,
                      actions: [
                        IconButton(
                          icon: const Icon(Icons.settings),
                          onPressed: () {
                            showDialog(
                              context: context,
                              builder: (context) => AlertDialog(
                                title: const Text('Serving Options'),
                                content: Column(
                                  mainAxisSize: MainAxisSize.min,
                                  children: [
                                    ListTile(
                                      leading: _servingOption == 'queueOrder'
                                          ? const Icon(Icons.check_circle, color: Color(0xFF81CF01))
                                          : const Icon(Icons.circle_outlined, color: Colors.grey),
                                      title: Text(
                                        'Queue order sequence',
                                        style: TextStyle(
                                          fontWeight: _servingOption == 'queueOrder' ? FontWeight.bold : FontWeight.normal,
                                          color: _servingOption == 'queueOrder' ? const Color(0xFF81CF01) : Colors.black87,
                                        ),
                                      ),
                                      tileColor: _servingOption == 'queueOrder' ? const Color(0xFF81CF01).withOpacity(0.1) : null,
                                      shape: RoundedRectangleBorder(
                                        borderRadius: BorderRadius.circular(8),
                                        side: _servingOption == 'queueOrder'
                                            ? const BorderSide(color: Color(0xFF81CF01), width: 2)
                                            : BorderSide.none,
                                      ),
                                      onTap: () => _handleServingOption('queueOrder'),
                                    ),
                                    ListTile(
                                      leading: _servingOption == 'grace5'
                                          ? const Icon(Icons.check_circle, color: Color(0xFF81CF01))
                                          : const Icon(Icons.circle_outlined, color: Colors.grey),
                                      title: Text(
                                        'Grace 5',
                                        style: TextStyle(
                                          fontWeight: _servingOption == 'grace5' ? FontWeight.bold : FontWeight.normal,
                                          color: _servingOption == 'grace5' ? const Color(0xFF81CF01) : Colors.black87,
                                        ),
                                      ),
                                      tileColor: _servingOption == 'grace5' ? const Color(0xFF81CF01).withOpacity(0.1) : null,
                                      shape: RoundedRectangleBorder(
                                        borderRadius: BorderRadius.circular(8),
                                        side: _servingOption == 'grace5'
                                            ? const BorderSide(color: Color(0xFF81CF01), width: 2)
                                            : BorderSide.none,
                                      ),
                                      onTap: () => _handleServingOption('grace5'),
                                    ),
                                    ListTile(
                                      leading: _servingOption == 'grace10'
                                          ? const Icon(Icons.check_circle, color: Color(0xFF81CF01))
                                          : const Icon(Icons.circle_outlined, color: Colors.grey),
                                      title: Text(
                                        'Grace 10',
                                        style: TextStyle(
                                          fontWeight: _servingOption == 'grace10' ? FontWeight.bold : FontWeight.normal,
                                          color: _servingOption == 'grace10' ? const Color(0xFF81CF01) : Colors.black87,
                                        ),
                                      ),
                                      tileColor: _servingOption == 'grace10' ? const Color(0xFF81CF01).withOpacity(0.1) : null,
                                      shape: RoundedRectangleBorder(
                                        borderRadius: BorderRadius.circular(8),
                                        side: _servingOption == 'grace10'
                                            ? const BorderSide(color: Color(0xFF81CF01), width: 2)
                                            : BorderSide.none,
                                      ),
                                      onTap: () => _handleServingOption('grace10'),
                                    ),
                                    ListTile(
                                      leading: _servingOption == 'noOrder'
                                          ? const Icon(Icons.check_circle, color: Color(0xFF81CF01))
                                          : const Icon(Icons.circle_outlined, color: Colors.grey),
                                      title: Text(
                                        'No Order',
                                        style: TextStyle(
                                          fontWeight: _servingOption == 'noOrder' ? FontWeight.bold : FontWeight.normal,
                                          color: _servingOption == 'noOrder' ? const Color(0xFF81CF01) : Colors.black87,
                                        ),
                                      ),
                                      tileColor: _servingOption == 'noOrder' ? const Color(0xFF81CF01).withOpacity(0.1) : null,
                                      shape: RoundedRectangleBorder(
                                        borderRadius: BorderRadius.circular(8),
                                        side: _servingOption == 'noOrder'
                                            ? const BorderSide(color: Color(0xFF81CF01), width: 2)
                                            : BorderSide.none,
                                      ),
                                      onTap: () => _handleServingOption('noOrder'),
                                    ),
                                    ListTile(
                                      leading: _servingOption == 'withoutTickets'
                                          ? const Icon(Icons.check_circle, color: Color(0xFF81CF01))
                                          : const Icon(Icons.circle_outlined, color: Colors.grey),
                                      title: Text(
                                        'Without Tickets',
                                        style: TextStyle(
                                          fontWeight: _servingOption == 'withoutTickets' ? FontWeight.bold : FontWeight.normal,
                                          color: _servingOption == 'withoutTickets' ? const Color(0xFF81CF01) : Colors.black87,
                                        ),
                                      ),
                                      tileColor: _servingOption == 'withoutTickets' ? const Color(0xFF81CF01).withOpacity(0.1) : null,
                                      shape: RoundedRectangleBorder(
                                        borderRadius: BorderRadius.circular(8),
                                        side: _servingOption == 'withoutTickets'
                                            ? const BorderSide(color: Color(0xFF81CF01), width: 2)
                                            : BorderSide.none,
                                      ),
                                      onTap: () => _handleServingOption('withoutTickets'),
                                    ),
                                  ],
                                ),
      ),
        );
      },
                        ),
                      ],
                    ),
                    body: _buildServingBody(sortedBeneficiaries, fullyServedBeneficiaryIds, daySpecificUnitsTaken),
                  );
                },
              );
            },
          );
        },
      );
    } else {
      // For non-multi-day queues, use the original logic
      return StreamBuilder<List<Beneficiary>>(
        stream: BeneficiaryService.getBeneficiariesByQueueName(_effectiveQueueName),
        builder: (context, snapshot) {
          // Use stream data if available, otherwise use local list filtered by queue
          // Filter local list to only include beneficiaries for this queue
          final filteredLocalBeneficiaries = _localBeneficiaries
              .where((b) => b.initialAssignedQueuePoint == _effectiveQueueName)
              .toList();
          List<Beneficiary> currentBeneficiaries = filteredLocalBeneficiaries;
          
          if (snapshot.hasData) {
            // Stream already filtered by queue name, so no need to filter again
            final streamedBeneficiaries = snapshot.data!;
            
            // Merge stream data with local updates to ensure immediate UI updates
            // Prefer stream data for numberOfUnits (eligibility) since it's the source of truth
            // Prefer local updates for unitsTaken/isServed (recently served) for immediate feedback
            final Map<String, Beneficiary> beneficiaryMap = {};
            // First add all from stream (most authoritative from Firebase, especially for numberOfUnits)
            for (var b in streamedBeneficiaries) {
              beneficiaryMap[b.id] = b;
            }
            // Then update with filtered local list (might have recent updates not yet in stream)
            // This ensures immediate UI updates before Firebase stream catches up
            // Only include beneficiaries that match this queue's name
            for (var b in filteredLocalBeneficiaries) {
              final streamed = beneficiaryMap[b.id];
              if (streamed == null) {
                // New beneficiary not in stream yet, add it
                beneficiaryMap[b.id] = b;
              } else {
                // Merge: use stream's numberOfUnits (source of truth), but prefer local for unitsTaken/isServed if more recent
                if (b.unitsTaken > streamed.unitsTaken || 
                    (b.unitsTaken == streamed.unitsTaken && b.isServed != streamed.isServed)) {
                  // Local has more recent serving data, but keep numberOfUnits from stream
                  beneficiaryMap[b.id] = b.copyWith(numberOfUnits: streamed.numberOfUnits);
                } else {
                  // Stream is more recent or equal, use stream data (already in map)
                  // This ensures numberOfUnits updates are immediately reflected
                }
              }
            }
            
            currentBeneficiaries = beneficiaryMap.values.toList();
            // Update local list for search functionality (already filtered by queue)
            _localBeneficiaries = currentBeneficiaries;
          } else {
            // If no stream data yet, use filtered local list
            currentBeneficiaries = filteredLocalBeneficiaries;
            _localBeneficiaries = filteredLocalBeneficiaries;
          }

          final sortedBeneficiaries = List<Beneficiary>.from(currentBeneficiaries);
          if (_servingOption == 'noOrder') {
            // No order - serve in any order
          } else {
            // Sort by queue number
            sortedBeneficiaries.sort((a, b) => (a.queueNumber ?? 0).compareTo(b.queueNumber ?? 0));
          }

          final title = widget.queue.isMultiDay
              ? 'Serving: ${widget.queue.name} (${widget.queue.fromDate.day}/${widget.queue.fromDate.month}/${widget.queue.fromDate.year})'
              : 'Serving: ${widget.queue.name}';

          // For non-multi-day queues, only mark as served if they've received full eligible units
          final servedBeneficiaryIds = <String>{};
          for (var b in sortedBeneficiaries) {
            final eligibleUnits = int.tryParse(b.numberOfUnits) ?? 1;
            if (b.isServed && b.unitsTaken >= eligibleUnits) {
              servedBeneficiaryIds.add(b.id);
            }
          }

          return Scaffold(
              appBar: AppBar(
                title: Text(title),
                backgroundColor: const Color(0xFF81CF01),
                foregroundColor: Colors.white,
                actions: [
                  IconButton(
                    icon: const Icon(Icons.settings),
                    onPressed: () {
                      showDialog(
                        context: context,
                        builder: (context) => AlertDialog(
                          title: const Text('Serving Options'),
                          content: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              ListTile(
                                leading: _servingOption == 'queueOrder'
                                    ? const Icon(Icons.check_circle, color: Color(0xFF81CF01))
                                    : const Icon(Icons.circle_outlined, color: Colors.grey),
                                title: Text(
                                  'Queue order sequence',
                                  style: TextStyle(
                                    fontWeight: _servingOption == 'queueOrder' ? FontWeight.bold : FontWeight.normal,
                                    color: _servingOption == 'queueOrder' ? const Color(0xFF81CF01) : Colors.black87,
                                  ),
                                ),
                                tileColor: _servingOption == 'queueOrder' ? const Color(0xFF81CF01).withOpacity(0.1) : null,
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(8),
                                  side: _servingOption == 'queueOrder'
                                      ? const BorderSide(color: Color(0xFF81CF01), width: 2)
                                      : BorderSide.none,
                                ),
                                onTap: () => _handleServingOption('queueOrder'),
                              ),
                              ListTile(
                                leading: _servingOption == 'grace5'
                                    ? const Icon(Icons.check_circle, color: Color(0xFF81CF01))
                                    : const Icon(Icons.circle_outlined, color: Colors.grey),
                                title: Text(
                                  'Grace 5',
                                  style: TextStyle(
                                    fontWeight: _servingOption == 'grace5' ? FontWeight.bold : FontWeight.normal,
                                    color: _servingOption == 'grace5' ? const Color(0xFF81CF01) : Colors.black87,
                                  ),
                                ),
                                tileColor: _servingOption == 'grace5' ? const Color(0xFF81CF01).withOpacity(0.1) : null,
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(8),
                                  side: _servingOption == 'grace5'
                                      ? const BorderSide(color: Color(0xFF81CF01), width: 2)
                                      : BorderSide.none,
                                ),
                                onTap: () => _handleServingOption('grace5'),
                              ),
                              ListTile(
                                leading: _servingOption == 'grace10'
                                    ? const Icon(Icons.check_circle, color: Color(0xFF81CF01))
                                    : const Icon(Icons.circle_outlined, color: Colors.grey),
                                title: Text(
                                  'Grace 10',
                                  style: TextStyle(
                                    fontWeight: _servingOption == 'grace10' ? FontWeight.bold : FontWeight.normal,
                                    color: _servingOption == 'grace10' ? const Color(0xFF81CF01) : Colors.black87,
                                  ),
                                ),
                                tileColor: _servingOption == 'grace10' ? const Color(0xFF81CF01).withOpacity(0.1) : null,
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(8),
                                  side: _servingOption == 'grace10'
                                      ? const BorderSide(color: Color(0xFF81CF01), width: 2)
                                      : BorderSide.none,
                                ),
                                onTap: () => _handleServingOption('grace10'),
                              ),
                              ListTile(
                                leading: _servingOption == 'noOrder'
                                    ? const Icon(Icons.check_circle, color: Color(0xFF81CF01))
                                    : const Icon(Icons.circle_outlined, color: Colors.grey),
                                title: Text(
                                  'No Order',
                                  style: TextStyle(
                                    fontWeight: _servingOption == 'noOrder' ? FontWeight.bold : FontWeight.normal,
                                    color: _servingOption == 'noOrder' ? const Color(0xFF81CF01) : Colors.black87,
                                  ),
                                ),
                                tileColor: _servingOption == 'noOrder' ? const Color(0xFF81CF01).withOpacity(0.1) : null,
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(8),
                                  side: _servingOption == 'noOrder'
                                      ? const BorderSide(color: Color(0xFF81CF01), width: 2)
                                      : BorderSide.none,
                                ),
                                onTap: () => _handleServingOption('noOrder'),
                              ),
                              ListTile(
                                leading: _servingOption == 'withoutTickets'
                                    ? const Icon(Icons.check_circle, color: Color(0xFF81CF01))
                                    : const Icon(Icons.circle_outlined, color: Colors.grey),
                                title: Text(
                                  'Without Tickets',
                                  style: TextStyle(
                                    fontWeight: _servingOption == 'withoutTickets' ? FontWeight.bold : FontWeight.normal,
                                    color: _servingOption == 'withoutTickets' ? const Color(0xFF81CF01) : Colors.black87,
                                  ),
                                ),
                                tileColor: _servingOption == 'withoutTickets' ? const Color(0xFF81CF01).withOpacity(0.1) : null,
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(8),
                                  side: _servingOption == 'withoutTickets'
                                      ? const BorderSide(color: Color(0xFF81CF01), width: 2)
                                      : BorderSide.none,
                                ),
                                onTap: () => _handleServingOption('withoutTickets'),
                              ),
                            ],
                          ),
                        ),
                      );
                    },
                  ),
                ],
              ),
              body: _buildServingBody(sortedBeneficiaries, servedBeneficiaryIds, {}),
            );
        },
      );
    }
  }
}

// Issue Queue Number Screen
class IssueQueueNumberScreen extends StatefulWidget {
  final List<Queue> queues;
  final List<Beneficiary> beneficiaries;
  final Function(Queue, Beneficiary, int) onQueueNumberIssued;

  const IssueQueueNumberScreen({
    super.key,
    required this.queues,
    required this.beneficiaries,
    required this.onQueueNumberIssued,
  });

  @override
  State<IssueQueueNumberScreen> createState() => _IssueQueueNumberScreenState();
}

class _IssueQueueNumberScreenState extends State<IssueQueueNumberScreen> {
  Queue? _selectedQueue;
  DateTime? _selectedDay; // Selected day for Multi Day queues
  Beneficiary? _verifiedBeneficiary;
  final TextEditingController _searchController = TextEditingController();
  int? _issuedQueueNumber;
  bool _isNFCScanning = false;
  final FocusNode _searchFocusNode = FocusNode();
  Timer? _searchDebounceTimer;
  int _currentQueueNumber = 0;
  int _totalAttendees = 0;
  String? _lastProcessedTagId; // Track last processed tag ID to prevent duplicate searches
  DateTime? _lastTagDetectionTime; // Track when last tag was detected to prevent rapid duplicate detections
  static const Duration _tagDetectionCooldown = Duration(milliseconds: 1500); // Cooldown period between tag detections
  
  // Verification method selection (0 = NFC, 1 = Mobile, 2 = National ID)
  int _selectedVerificationMethod = 0; // NFC is default

  // Generate daily entries for Multi Day queue
  List<DateTime> _generateDailyEntries(Queue queue) {
    if (!queue.isMultiDay) return [];
    
    final entries = <DateTime>[];
    var date = DateTime(queue.fromDate.year, queue.fromDate.month, queue.fromDate.day);
    final endDate = DateTime(queue.toDate.year, queue.toDate.month, queue.toDate.day);
    
    while (!date.isAfter(endDate)) {
      entries.add(date);
      date = date.add(const Duration(days: 1));
    }
    
    return entries;
  }

  // Get day-specific queue name for Multi Day queues
  String _getDaySpecificQueueName(Queue queue, DateTime day) {
    if (queue.isMultiDay) {
      final dayStr = '${day.year}-${day.month.toString().padLeft(2, '0')}-${day.day.toString().padLeft(2, '0')}';
      return '${queue.name}_$dayStr';
    }
    return queue.name;
  }

  // Get current queue number from Firebase
  Future<int> _getCurrentQueueNumber() async {
    if (_selectedQueue == null) return 0;
    
    // For Multi Day queues, require day selection
    if (_selectedQueue!.isMultiDay && _selectedDay == null) {
      return 0;
    }
    
    try {
      // Get all beneficiaries for this queue's distribution area
      final beneficiaries = await BeneficiaryService.getBeneficiariesByArea(_selectedQueue!.distributionArea).first;
      
      // Get the day-specific queue name
      final queueName = _selectedQueue!.isMultiDay && _selectedDay != null
          ? _getDaySpecificQueueName(_selectedQueue!, _selectedDay!)
          : _selectedQueue!.name;
      
      // Filter by queue name and count those with queue numbers
      final beneficiariesInQueue = beneficiaries
          .where((b) => b.initialAssignedQueuePoint == queueName && b.queueNumber != null)
          .length;
      
      return beneficiariesInQueue + 1;
    } catch (e) {
      print('Error getting current queue number: $e');
      return 1; // Default to 1 if error
    }
  }

  // Get total attendees from Firebase
  Future<int> _getTotalAttendees() async {
    if (_selectedQueue == null) return 0;
    
    // For Multi Day queues, require day selection
    if (_selectedQueue!.isMultiDay && _selectedDay == null) {
      return 0;
    }
    
    try {
      // Get all beneficiaries for this queue's distribution area
      final beneficiaries = await BeneficiaryService.getBeneficiariesByArea(_selectedQueue!.distributionArea).first;
      
      // Get the day-specific queue name
      final queueName = _selectedQueue!.isMultiDay && _selectedDay != null
          ? _getDaySpecificQueueName(_selectedQueue!, _selectedDay!)
          : _selectedQueue!.name;
      
      // Filter by queue name and count those with queue numbers
      return beneficiaries
          .where((b) => b.initialAssignedQueuePoint == queueName && b.queueNumber != null)
          .length;
    } catch (e) {
      print('Error getting total attendees: $e');
      return 0;
    }
  }

  @override
  void initState() {
    super.initState();
    // Auto-start NFC detection as default
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_selectedVerificationMethod == 0) {
        _startNFCDetection();
      } else {
        _searchFocusNode.requestFocus();
      }
    });
  }

  // Load queue statistics when queue is selected
  Future<void> _loadQueueStatistics() async {
    if (_selectedQueue == null) {
      setState(() {
        _currentQueueNumber = 0;
        _totalAttendees = 0;
      });
      return;
    }
    
    final queueNumber = await _getCurrentQueueNumber();
    final totalAttendees = await _getTotalAttendees();
    
    if (mounted) {
      setState(() {
        _currentQueueNumber = queueNumber;
        _totalAttendees = totalAttendees;
      });
    }
  }

  @override
  void dispose() {
    _searchDebounceTimer?.cancel();
    NFCHelper.stopNFCSession(); // Stop NFC scanning on dispose
    _searchController.dispose();
    _searchFocusNode.dispose();
    super.dispose();
  }

  void _startNFCDetection() async {
    if (kIsWeb) return;
    
    setState(() {
      _isNFCScanning = true;
    });
    
    try {
      // Check if NFC is available
      final isAvailable = await NFCHelper.isNFCAvailable();
      if (!isAvailable) {
        if (mounted) {
          setState(() {
            _isNFCScanning = false;
          });
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(AppLanguage.translate('NFC is not available on this device')),
              backgroundColor: Colors.orange,
            ),
          );
        }
        return;
      }

      // Start NFC session - auto-detect when card is tapped
      NFCHelper.startNFCSession(
        context: context,
        onTagDetected: (id) {
          if (mounted) {
            final now = DateTime.now();
            
            // Check if this is the same tag ID as the last one processed
            if (_lastProcessedTagId == id) {
              // Also check cooldown period to prevent rapid duplicate detections
              if (_lastTagDetectionTime != null && 
                  now.difference(_lastTagDetectionTime!) < _tagDetectionCooldown) {
                print('NFC: ⏭️ Same tag ID detected within cooldown period, skipping: $id');
                return; // Don't process the same tag again
              }
            }
            
            // Cancel any pending search
            _searchDebounceTimer?.cancel();
            
            // Update last processed tag ID and detection time
            _lastProcessedTagId = id;
            _lastTagDetectionTime = now;
            
            // Clear previous beneficiary data when new tag is detected
            setState(() {
              _verifiedBeneficiary = null;
              _issuedQueueNumber = null;
              _isNFCScanning = false;
            });
            
            // Store original tag ID for searching, but display masked version
            // Replace text field with masked tag ID (for display only)
            _searchController.text = NFCHelper.maskNfcTagId(id);
            
            print('NFC: 🔍 New tag ID detected, starting search: $id');
            
            // Automatically search for beneficiary by original NFC ID (not masked)
            _handleSearchInput(id);
          }
        },
        onError: (error) {
          if (mounted) {
            setState(() {
              _isNFCScanning = false;
            });
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(error),
                backgroundColor: Colors.red,
              ),
            );
            // Restart NFC detection after error
            Future.delayed(const Duration(milliseconds: 500), () {
              if (mounted && _selectedVerificationMethod == 0) {
                _startNFCDetection();
              }
            });
          }
        },
      );
    } catch (e) {
      print('Error in NFC detection: $e');
      if (mounted) {
        setState(() {
          _isNFCScanning = false;
        });
      }
    }
  }
  
  Future<void> _scanNationalID() async {
    try {
      // Request camera permission
      final hasPermission = await PermissionHelper.requestCameraPermission();
      if (!hasPermission) {
        if (context.mounted) {
          await PermissionHelper.showPermissionDeniedDialog(
            context,
            AppLanguage.translate('Camera permission is required to scan National ID. Please enable it in app settings.'),
          );
        }
        return;
      }

      // Show loading dialog
      if (context.mounted) {
        showDialog(
          context: context,
          barrierDismissible: false,
          builder: (context) => const Center(
            child: CircularProgressIndicator(),
          ),
        );
      }

      // Use image_picker to get the image
      final image_picker.ImagePicker picker = image_picker.ImagePicker();
      final image_picker.XFile? image = await picker.pickImage(
        source: image_picker.ImageSource.camera,
        imageQuality: 85,
      );

      if (!context.mounted) return;
      Navigator.of(context).pop(); // Close loading dialog

      if (image == null) return;

      // Perform OCR on the image using flutter_native_ocr
      String combinedText = '';
      
      try {
        final ocr = FlutterNativeOcr();
        combinedText = await ocr.recognizeText(image.path);
        print('📝 OCR extracted ${combinedText.length} characters from image');
      } catch (e) {
        print('❌ OCR Error: $e');
      }

      try {
        // Parse ID using IDParser
        final parsedData = IDParser.parseIDText(combinedText);
        final idNumber = parsedData['idNumber'] as String?;
        final arabicName = parsedData['name'] as String?;

        if (idNumber != null && idNumber.isNotEmpty) {
          setState(() {
            _searchController.text = idNumber;
            _selectedVerificationMethod = 2; // Switch to National ID method
          });
          
          // Show extracted information
          if (context.mounted) {
            String message = '${AppLanguage.translate('ID Number')}: $idNumber';
            if (arabicName != null && arabicName.isNotEmpty) {
              message += '\n${AppLanguage.translate('Name')}: $arabicName';
            }
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(message),
                backgroundColor: Colors.green,
                duration: const Duration(seconds: 3),
              ),
            );
          }
          
          // Automatically search for beneficiary
          _handleSearchInput(idNumber);
        } else {
          if (context.mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(AppLanguage.translate('Could not extract National ID from image. Please try again or enter manually.')),
                backgroundColor: Colors.orange,
              ),
            );
          }
        }
      } catch (e) {
        print('Error parsing OCR text: $e');
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error processing image: ${e.toString()}'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    } catch (e) {
      if (context.mounted) {
        Navigator.of(context).pop(); // Close loading dialog if still open
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error scanning ID: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Widget _buildVerificationMethodButton(int method, IconData icon, String label, Color color) {
    final isSelected = _selectedVerificationMethod == method;
    return InkWell(
      onTap: () {
        setState(() {
          _selectedVerificationMethod = method;
          _searchController.clear();
          _verifiedBeneficiary = null;
          _issuedQueueNumber = null;
          _lastProcessedTagId = null; // Reset when switching verification methods
        });
        
        if (method == 0) {
          // Start NFC detection
          _startNFCDetection();
        } else {
          // Focus on text field for mobile or ID
          _searchFocusNode.requestFocus();
        }
      },
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 8),
        decoration: BoxDecoration(
          color: isSelected ? color.withOpacity(0.1) : Colors.white,
          border: Border.all(
            color: isSelected ? color : Colors.grey[300]!,
            width: isSelected ? 2 : 1,
          ),
          borderRadius: BorderRadius.circular(8),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              icon,
              color: isSelected ? color : Colors.grey[600],
              size: 24,
            ),
            const SizedBox(height: 4),
            Text(
              label,
              style: TextStyle(
                fontSize: 11,
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                color: isSelected ? color : Colors.grey[600],
              ),
              textAlign: TextAlign.center,
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _handleSearchInput(String value) async {
    if (value.isEmpty) {
      setState(() {
        _verifiedBeneficiary = null;
        _issuedQueueNumber = null;
        _lastProcessedTagId = null; // Reset when search is cleared
      });
      return;
    }

    if (_selectedQueue == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select a queue first')),
      );
      return;
    }

    // For Multi Day queues, require day selection
    if (_selectedQueue!.isMultiDay && _selectedDay == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select a day for this Multi Day queue')),
      );
      return;
    }

    // Get the distribution area ID from the selected queue
    final distributionAreaId = _selectedQueue!.distributionArea;
    
    // Show loading indicator
    setState(() {
      _isNFCScanning = true;
    });

    try {
      Beneficiary? foundBeneficiary;

      // Search based on selected verification method
      if (_selectedVerificationMethod == 0) {
        // NFC method - search by NFC code
        foundBeneficiary = await BeneficiaryService.getBeneficiaryByNFC(value);
      } else if (_selectedVerificationMethod == 1) {
        // Mobile method - search by mobile number
        foundBeneficiary = await BeneficiaryService.getBeneficiaryByMobile(value);
      } else if (_selectedVerificationMethod == 2) {
        // National ID method - search by ID number
        foundBeneficiary = await BeneficiaryService.getBeneficiaryByIdNumber(value);
      } else {
        // Fallback: Auto-detect search type based on input pattern
        // 1. Check if it's a mobile number (11 digits starting with 01)
        if (RegExp(r'^01[0-2,5]{1}[0-9]{8}$').hasMatch(value)) {
          foundBeneficiary = await BeneficiaryService.getBeneficiaryByMobile(value);
        }
        // 2. Check if it's NFC code (starts with "NFC_" or alphanumeric, length >= 8)
        else if (value.toUpperCase().startsWith('NFC_') || (value.length >= 8 && RegExp(r'^[A-Z0-9_]+$').hasMatch(value.toUpperCase()))) {
          foundBeneficiary = await BeneficiaryService.getBeneficiaryByNFC(value);
        }
        // 3. Check if it's national ID (11+ digits)
        else if (RegExp(r'^[0-9]{11,}$').hasMatch(value)) {
          foundBeneficiary = await BeneficiaryService.getBeneficiaryByIdNumber(value);
        }
        // 4. Try all methods if pattern doesn't match
        else {
          foundBeneficiary = await BeneficiaryService.getBeneficiaryByNFC(value);
          if (foundBeneficiary == null) {
            foundBeneficiary = await BeneficiaryService.getBeneficiaryByMobile(value);
          }
          if (foundBeneficiary == null) {
            foundBeneficiary = await BeneficiaryService.getBeneficiaryByIdNumber(value);
          }
        }
      }

      // Process found beneficiary - verify distribution area matches
      if (foundBeneficiary != null) {
        // VERIFY: Check if beneficiary's distribution area matches the queue's distribution area
        if (foundBeneficiary.distributionArea != distributionAreaId) {
          // Beneficiary is not related to this queue's distribution area
            if (mounted) {
              setState(() {
                _verifiedBeneficiary = null;
                _issuedQueueNumber = null;
                _isNFCScanning = false;
              });
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                content: Text(
                  'This beneficiary is not assigned to the selected queue\'s distribution area. '
                  'Please select a queue that matches the beneficiary\'s distribution area.',
                ),
                  backgroundColor: Colors.red,
                duration: const Duration(seconds: 4),
                ),
              );
            // Clear search field
            _searchController.clear();
            }
          return;
          }
        
        // Beneficiary is assigned to the correct distribution area - proceed with verification
          if (mounted) {
            _verifyAndIssueQueueNumber(foundBeneficiary);
        }
      } else {
        // Beneficiary not found
        if (mounted) {
          setState(() {
            _verifiedBeneficiary = null;
            _issuedQueueNumber = null;
            _isNFCScanning = false;
          });
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(AppLanguage.translate('Beneficiary not found')),
              backgroundColor: Colors.red,
            ),
          );
          // Restart NFC detection after showing error to listen for next card
          Future.delayed(const Duration(milliseconds: 500), () {
            if (mounted && _selectedVerificationMethod == 0) {
              _startNFCDetection();
            }
          });
        }
      }
    } catch (e) {
      print('Error searching beneficiary: $e');
      if (mounted) {
        setState(() {
          _verifiedBeneficiary = null;
          _issuedQueueNumber = null;
          _isNFCScanning = false;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error searching beneficiary: $e'),
            backgroundColor: Colors.red,
          ),
        );
        // Restart NFC detection after error
        Future.delayed(const Duration(milliseconds: 500), () {
          if (mounted && _selectedVerificationMethod == 0) {
            _startNFCDetection();
          }
        });
      }
    }
  }

  Future<void> _verifyAndIssueQueueNumber(Beneficiary beneficiary) async {
    // For Multi Day queues, require day selection
    if (_selectedQueue!.isMultiDay && _selectedDay == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select a day for this Multi Day queue')),
      );
      return;
    }

    // MANDATORY: Get the distribution area from the selected queue
    final queueDistributionArea = _selectedQueue!.distributionArea;
    
    // MANDATORY: Always update beneficiary's distribution area to match the selected queue's distribution area
    // This ensures the beneficiary is assigned to the correct distribution area when issuing a queue number
    if (beneficiary.distributionArea != queueDistributionArea) {
      try {
        // Update distribution area first
        final beneficiaryWithUpdatedArea = beneficiary.copyWith(
          distributionArea: queueDistributionArea,
        );
        await BeneficiaryService.updateBeneficiary(beneficiary.id, beneficiaryWithUpdatedArea);
        // Update local beneficiary reference
        beneficiary = beneficiaryWithUpdatedArea;
      } catch (e) {
        print('Error updating beneficiary distribution area: $e');
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error updating beneficiary distribution area: $e'),
              backgroundColor: Colors.red,
            ),
          );
        }
        return;
      }
    }

    // Get the day-specific queue name
    final queueName = _selectedQueue!.isMultiDay && _selectedDay != null
        ? _getDaySpecificQueueName(_selectedQueue!, _selectedDay!)
        : _selectedQueue!.name;

    // For multi-day queues, check queueHistory to see if a queue number was already issued for this specific day
    if (_selectedQueue!.isMultiDay) {
      try {
        print('🔍 Checking queueHistory for beneficiary ${beneficiary.id}, dayQueueName: $queueName');
        final historyQuery = await FirebaseService.firestore
            .collection('queueHistory')
            .where('beneficiaryId', isEqualTo: beneficiary.id)
            .where('dayQueueName', isEqualTo: queueName)
            .where('action', isEqualTo: 'issued')
            .limit(1)
            .get();
        
        print('🔍 QueueHistory query result: ${historyQuery.docs.length} documents found');
        
        if (historyQuery.docs.isNotEmpty) {
          final historyDoc = historyQuery.docs.first.data();
          final existingQueueNumber = historyDoc['queueNumber'];
          print('⚠️ Queue number already exists for this day: $existingQueueNumber');
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Beneficiary already has queue number $existingQueueNumber for this day')),
            );
            setState(() {
              _verifiedBeneficiary = beneficiary;
              _issuedQueueNumber = existingQueueNumber;
            });
          }
          return;
        }
        print('✅ No existing queue number found for this day, proceeding with issuance');
      } catch (e) {
        print('⚠️ Error checking queue history: $e');
        // Check if it's an index error
        if (e.toString().contains('index') || e.toString().contains('Index')) {
          print('⚠️ Firestore index may be missing. Please create a composite index for queueHistory collection with fields: beneficiaryId, dayQueueName, action');
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Note: Queue history check skipped. Queue number will be issued.'),
                duration: Duration(seconds: 2),
              ),
            );
          }
        }
        print('⚠️ Continuing with queue number issuance despite history check error');
        // Continue with normal flow if history check fails - allow issuance
      }
    }
    
    // For non-multi-day queues, check if already has a queue number for this specific queue/day
    if (!_selectedQueue!.isMultiDay && beneficiary.initialAssignedQueuePoint == queueName && beneficiary.queueNumber != null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Beneficiary already has queue number: ${beneficiary.queueNumber}')),
      );
      setState(() {
        _verifiedBeneficiary = beneficiary;
        _issuedQueueNumber = beneficiary.queueNumber;
      });
      return;
    }

    // Auto-issue queue number
    print('📝 Issuing queue number for day: $queueName');
    final queueNumber = await _getCurrentQueueNumber();
    print('📝 Calculated queue number: $queueNumber');
    
    // For multi-day queues: Check if beneficiary already has a queue number for a different day
    // If so, don't update initialAssignedQueuePoint (keep them in original day's list)
    // But still issue the queue number and track it in queueHistory
    String queuePointToUse = queueName;
    
    if (_selectedQueue!.isMultiDay) {
      final queueNamePrefix = '${_selectedQueue!.name}_';
      print('🔍 Current beneficiary queue point: ${beneficiary.initialAssignedQueuePoint}');
      // Check if beneficiary's current queue point is for a different day of this same multi-day queue
      if (beneficiary.initialAssignedQueuePoint.startsWith(queueNamePrefix) && 
          beneficiary.initialAssignedQueuePoint != queueName) {
        // Beneficiary already has a queue number for a different day
        // Keep their original queue assignment to preserve them in that day's list
        // This allows issuing queue numbers for multiple days independently
        print('ℹ️ Beneficiary has queue number for different day, preserving original queue point: ${beneficiary.initialAssignedQueuePoint}');
        queuePointToUse = beneficiary.initialAssignedQueuePoint;
      } else {
        print('ℹ️ Setting queue point to current day: $queueName');
      }
    }
    
    // When issuing a queue number for a new queue, reset served status for this queue
    // Check if beneficiary has been served for THIS specific queue/day
    bool isServedForThisQueue = false;
    int unitsTakenForThisQueue = 0;
    
    // Update beneficiary with queue number and ensure distribution area is set
    try {
      await BeneficiaryService.assignQueueNumber(beneficiary.id, queueNumber);
      
      if (_selectedQueue!.isMultiDay) {
        // For multi-day queues, check queueHistory for this specific day
        try {
          final servedHistoryQuery = await FirebaseService.firestore
              .collection('queueHistory')
              .where('dayQueueName', isEqualTo: queueName)
              .where('beneficiaryId', isEqualTo: beneficiary.id)
              .where('action', isEqualTo: 'served')
              .get();
          
          for (var doc in servedHistoryQuery.docs) {
            final data = doc.data();
            final unitsServed = data['unitsServed'] as int? ?? 0;
            unitsTakenForThisQueue += unitsServed;
          }
          
          // Eligibility is based on beneficiary.numberOfUnits set during registration
          final eligibleUnits = int.tryParse(beneficiary.numberOfUnits) ?? 1;
          isServedForThisQueue = unitsTakenForThisQueue >= eligibleUnits;
        } catch (e) {
          print('⚠️ Warning: Could not check served status for this queue: $e');
          // Default to not served if check fails
          isServedForThisQueue = false;
          unitsTakenForThisQueue = 0;
        }
      } else {
        // For single-day queues, check if beneficiary is assigned to this EXACT queue
        if (beneficiary.initialAssignedQueuePoint == queueName) {
          // Same queue - check if they've been served for this queue
          // Eligibility is based on beneficiary.numberOfUnits set during registration
          final eligibleUnits = int.tryParse(beneficiary.numberOfUnits) ?? 1;
          isServedForThisQueue = beneficiary.isServed && beneficiary.unitsTaken >= eligibleUnits;
          unitsTakenForThisQueue = beneficiary.unitsTaken;
        } else {
          // NEW queue assignment - reset served status and units taken to 0
          isServedForThisQueue = false;
          unitsTakenForThisQueue = 0;
        }
      }
      
      // Update beneficiary - for new queue assignments, don't carry over served status from other queues
      // Only preserve if they're already assigned to this same queue
      await BeneficiaryService.updateBeneficiary(beneficiary.id, beneficiary.copyWith(
        distributionArea: queueDistributionArea, // MANDATORY: Always set to queue's distribution area
        initialAssignedQueuePoint: queuePointToUse, // Only update if this is first queue assignment or same day
        queueNumber: queueNumber,
        // For new queue assignments, reset served status; preserve if already in this queue
        isServed: isServedForThisQueue,
        unitsTaken: unitsTakenForThisQueue,
      ));
      
      // Track queue number assignment in queueHistory for multi-day queues
      if (_selectedQueue!.isMultiDay) {
        try {
          await FirebaseService.firestore.collection('queueHistory').add({
            'queueId': _selectedQueue!.name,
            'dayQueueName': queueName, // Store the day-specific queue name
            'beneficiaryId': beneficiary.id,
            'action': 'issued',
            'queueNumber': queueNumber,
            'performedBy': AdminService.currentAdmin?.fullName ?? 'system',
            'performedAt': FieldValue.serverTimestamp(),
          });
        } catch (e) {
          print('Warning: Could not record queue history: $e');
          // Don't fail the operation if history tracking fails
        }
      }
    } catch (e) {
      print('Error updating beneficiary in Firebase: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error updating beneficiary: $e'),
            backgroundColor: Colors.red,
          ),
        );
        return;
      }
    }
    
    // Update beneficiary with queue number and distribution area
    // Use the queue-specific served status and units taken calculated above
    final updatedBeneficiary = beneficiary.copyWith(
      distributionArea: queueDistributionArea, // MANDATORY: Always set to queue's distribution area
      initialAssignedQueuePoint: queuePointToUse, // Preserve original if different day, otherwise set to current day
      queueNumber: queueNumber,
      isServed: isServedForThisQueue, // Use queue-specific served status
      unitsTaken: unitsTakenForThisQueue, // Use queue-specific units taken
    );

    widget.onQueueNumberIssued(_selectedQueue!, updatedBeneficiary, queueNumber);

    if (mounted) {
      setState(() {
        _verifiedBeneficiary = updatedBeneficiary;
        _issuedQueueNumber = queueNumber;
      });

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Queue number $queueNumber issued successfully')),
      );

      // Reload queue statistics after issuing number
      await _loadQueueStatistics();

      // Restart NFC detection to listen for next card
      Future.delayed(const Duration(milliseconds: 500), () {
        if (mounted && _selectedVerificationMethod == 0) {
          _startNFCDetection();
        }
      });

      // Clear search field after successful issue
      _searchController.clear();
      _searchFocusNode.requestFocus();
    }
  }


  @override
  Widget build(BuildContext context) {
    const tealGreen = Color(0xFF81CF01);
    const darkBlue = Color(0xFF1A237E);

    // Filter queues to show only today's queues (queues active today)
    final today = DateTime.now();
    final todayOnly = DateTime(today.year, today.month, today.day);
    final todayQueues = widget.queues.where((q) {
      final fromDateOnly = DateTime(q.fromDate.year, q.fromDate.month, q.fromDate.day);
      final toDateOnly = DateTime(q.toDate.year, q.toDate.month, q.toDate.day);
      // Include queue if today falls between fromDate and toDate (inclusive)
      return todayOnly.compareTo(fromDateOnly) >= 0 && todayOnly.compareTo(toDateOnly) <= 0;
    }).toList();

    // Reset selected queue if it's not in today's queues
    if (_selectedQueue != null && !todayQueues.contains(_selectedQueue)) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          setState(() {
            _selectedQueue = null;
            _selectedDay = null;
            _verifiedBeneficiary = null;
            _issuedQueueNumber = null;
          });
        }
      });
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Issue Queue Number'),
        backgroundColor: tealGreen,
        foregroundColor: Colors.white,
      ),
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Color(0xFFE8F5E9), Colors.white],
          ),
        ),
        child: Column(
          children: [
            Expanded(
              child: SingleChildScrollView(
                padding: const EdgeInsets.all(20.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text(
                      'Issue Queue Number',
                      style: TextStyle(
                        fontSize: 24,
                        fontWeight: FontWeight.bold,
                        color: darkBlue,
                      ),
                    ),
                    const SizedBox(height: 32),
                    const Text('Select Queue *', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
                    const SizedBox(height: 8),
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 16),
                      decoration: BoxDecoration(
                        border: Border.all(color: const Color(0xFFE0E0E0)),
                        borderRadius: BorderRadius.circular(8),
                        color: Colors.white,
                      ),
                      child: DropdownButtonHideUnderline(
                        child: DropdownButton<Queue>(
                          value: _selectedQueue,
                          isExpanded: true,
                          hint: const Text('Select queue'),
                          items: todayQueues.map((queue) {
                            return DropdownMenuItem(
                              value: queue,
                              child: Text(
                                queue.name,
                                overflow: TextOverflow.ellipsis,
                                maxLines: 1,
                              ),
                            );
                          }).toList(),
                          onChanged: (value) {
                            setState(() {
                              _selectedQueue = value;
                              _selectedDay = null; // Reset day selection when queue changes
                              _verifiedBeneficiary = null;
                              _issuedQueueNumber = null;
                              _searchController.clear();
                            });
                            _loadQueueStatistics();
                          },
                        ),
                      ),
                    ),
                    // Day selection for Multi Day queues
                    if (_selectedQueue != null && _selectedQueue!.isMultiDay) ...[
                      const SizedBox(height: 24),
                      const Text('Select Day *', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
                      const SizedBox(height: 8),
                      Container(
                        padding: const EdgeInsets.symmetric(horizontal: 16),
                        decoration: BoxDecoration(
                          border: Border.all(color: const Color(0xFFE0E0E0)),
                          borderRadius: BorderRadius.circular(8),
                          color: Colors.white,
                        ),
                        child: DropdownButtonHideUnderline(
                          child: DropdownButton<DateTime>(
                            value: _selectedDay,
                            isExpanded: true,
                            hint: const Text('Select day'),
                            items: _generateDailyEntries(_selectedQueue!).map((day) {
                              final isToday = day.year == DateTime.now().year &&
                                            day.month == DateTime.now().month &&
                                            day.day == DateTime.now().day;
                              final isPast = day.isBefore(DateTime.now().subtract(const Duration(days: 1)));
                              final dayLabel = isToday 
                                  ? '${day.day}/${day.month}/${day.year} (Today)'
                                  : isPast
                                      ? '${day.day}/${day.month}/${day.year} (Past)'
                                      : '${day.day}/${day.month}/${day.year}';
                              
                              return DropdownMenuItem(
                                value: day,
                                child: Text(
                                  dayLabel,
                                  overflow: TextOverflow.ellipsis,
                                  maxLines: 1,
                                  style: TextStyle(
                                    color: isPast ? Colors.grey : (isToday ? Colors.blue : Colors.black),
                                    fontWeight: isToday ? FontWeight.bold : FontWeight.normal,
                                  ),
                                ),
                              );
                            }).toList(),
                            onChanged: (value) {
                              setState(() {
                                _selectedDay = value;
                                _verifiedBeneficiary = null;
                                _issuedQueueNumber = null;
                              });
                              _loadQueueStatistics();
                            },
                          ),
                        ),
                      ),
                    ],
                    const SizedBox(height: 24),
                    const Text('Verify Beneficiary *', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
                    const SizedBox(height: 12),
                    // Verification Method Selection Buttons
                    Row(
                      children: [
                        Expanded(
                          child: _buildVerificationMethodButton(
                            0,
                            Icons.nfc,
                            AppLanguage.translate('NFC Card'),
                            tealGreen,
                          ),
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: _buildVerificationMethodButton(
                            1,
                            Icons.phone,
                            AppLanguage.translate('Mobile'),
                            Colors.blue,
                          ),
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: _buildVerificationMethodButton(
                            2,
                            Icons.badge,
                            AppLanguage.translate('National ID'),
                            Colors.orange,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),
                    // Dynamic Search Field
                    Row(
                      children: [
                        // Loading indicator removed as requested
                        Expanded(
                          child: ValueListenableBuilder<TextEditingValue>(
                            valueListenable: _searchController,
                            builder: (context, value, child) {
                              String hintText;
                              IconData prefixIcon;
                              
                              if (_selectedVerificationMethod == 0) {
                                hintText = AppLanguage.translate('Tap NFC card or enter NFC code');
                                prefixIcon = _isNFCScanning ? Icons.nfc : Icons.nfc;
                              } else if (_selectedVerificationMethod == 1) {
                                hintText = AppLanguage.translate('Enter mobile number');
                                prefixIcon = Icons.phone;
                              } else {
                                hintText = AppLanguage.translate('Enter National ID or scan');
                                prefixIcon = Icons.badge;
                              }
                              
                              return TextField(
                                controller: _searchController,
                                focusNode: _searchFocusNode,
                                autofocus: _selectedVerificationMethod != 0,
                                decoration: InputDecoration(
                                  hintText: hintText,
                                  prefixIcon: Icon(
                                    prefixIcon,
                                    color: tealGreen,
                                  ),
                                  suffixIcon: Row(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      if (_selectedVerificationMethod == 2)
                                        IconButton(
                                          icon: const Icon(Icons.camera_alt),
                                          onPressed: _scanNationalID,
                                          tooltip: AppLanguage.translate('Scan National ID'),
                                        ),
                                      if (value.text.isNotEmpty)
                                        IconButton(
                                          icon: const Icon(Icons.clear),
                                          onPressed: () {
                                            _searchController.clear();
                                            setState(() {
                                              _verifiedBeneficiary = null;
                                              _issuedQueueNumber = null;
                                            });
                                            if (_selectedVerificationMethod != 0) {
                                              _searchFocusNode.requestFocus();
                                            }
                                          },
                                        ),
                                    ],
                                  ),
                                  border: OutlineInputBorder(
                                    borderRadius: BorderRadius.circular(8),
                                    borderSide: BorderSide(color: tealGreen),
                                  ),
                                  enabledBorder: OutlineInputBorder(
                                    borderRadius: BorderRadius.circular(8),
                                    borderSide: BorderSide(color: tealGreen),
                                  ),
                                  focusedBorder: OutlineInputBorder(
                                    borderRadius: BorderRadius.circular(8),
                                    borderSide: BorderSide(color: tealGreen, width: 2),
                                  ),
                                  filled: true,
                                  fillColor: Colors.grey[50],
                                  contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                                ),
                                keyboardType: _selectedVerificationMethod == 1 
                                    ? TextInputType.phone 
                                    : TextInputType.text,
                                textInputAction: TextInputAction.search,
                                onChanged: (value) {
                                  // Debounce search to avoid too many Firebase calls
                                  _searchDebounceTimer?.cancel();
                                  _searchDebounceTimer = Timer(const Duration(milliseconds: 500), () {
                                    _handleSearchInput(value);
                                  });
                                },
                                onSubmitted: (value) {
                                  _handleSearchInput(value);
                                },
                              );
                            },
                          ),
                        ),
                      ],
                    ),
                    if (_verifiedBeneficiary != null) ...[
                      const SizedBox(height: 32),
                      Container(
                        padding: const EdgeInsets.all(20),
                        decoration: BoxDecoration(
                          color: Colors.white,
                          borderRadius: BorderRadius.circular(12),
                          border: Border.all(color: Colors.grey.withOpacity(0.3)),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.grey.withOpacity(0.2),
                              spreadRadius: 2,
                              blurRadius: 8,
                              offset: const Offset(0, 4),
                            ),
                          ],
                        ),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Row(
                              children: [
                                Container(
                                  width: 80,
                                  height: 80,
                                  decoration: BoxDecoration(
                                    borderRadius: BorderRadius.circular(8),
                                    border: Border.all(color: Colors.grey.withOpacity(0.3)),
                                    color: Colors.grey[200],
                                  ),
                                  child: const Icon(Icons.person, size: 40, color: Colors.grey),
                                ),
                                const SizedBox(width: 16),
                                Expanded(
                                  child: Column(
                                    crossAxisAlignment: CrossAxisAlignment.start,
                                    children: [
                                      Text(
                                        _verifiedBeneficiary!.name,
                                        style: const TextStyle(
                                          fontSize: 20,
                                          fontWeight: FontWeight.bold,
                                        ),
                                      ),
                                      const SizedBox(height: 4),
                                      Text('ID: ${_verifiedBeneficiary!.idNumber}'),
                                      Text('Type: ${_verifiedBeneficiary!.type}'),
                                      Text('Gender: ${_verifiedBeneficiary!.gender}'),
                                      if (_verifiedBeneficiary!.mobileNumber != null)
                                        Text('Mobile: ${_verifiedBeneficiary!.mobileNumber}'),
                                    ],
                                  ),
                                ),
                              ],
                            ),
                            const SizedBox(height: 20),
                            if (_issuedQueueNumber != null) ...[
                              Container(
                                padding: const EdgeInsets.all(16),
                                decoration: BoxDecoration(
                                  color: tealGreen.withOpacity(0.1),
                                  borderRadius: BorderRadius.circular(8),
                                  border: Border.all(color: tealGreen, width: 2),
                                ),
                                child: Column(
                                  children: [
                                    const Text(
                                      'Queue Number Issued',
                                      style: TextStyle(
                                        fontSize: 16,
                                        fontWeight: FontWeight.bold,
                                        color: tealGreen,
                                      ),
                                    ),
                                    const SizedBox(height: 8),
                                    Text(
                                      '$_issuedQueueNumber',
                                      style: const TextStyle(
                                        fontSize: 48,
                                        fontWeight: FontWeight.bold,
                                        color: tealGreen,
                                      ),
                                    ),
                                    const SizedBox(height: 8),
                                    Text(
                                      'Current Queue Number: $_currentQueueNumber',
                                      style: const TextStyle(fontSize: 14),
                                    ),
                                  ],
                                ),
                              ),
                            ],
                          ],
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            ),
            if (_selectedQueue != null)
              Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: Colors.white,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.grey.withOpacity(0.2),
                      spreadRadius: 2,
                      blurRadius: 8,
                      offset: const Offset(0, -2),
                    ),
                  ],
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceAround,
                  children: [
                    Expanded(
                      child: _buildStatItem('Total Attendees', '$_totalAttendees', Icons.people),
                    ),
                    Expanded(
                      child: _buildStatItem('Available Units', '${_selectedQueue!.numberOfAvailableUnits}', Icons.inventory),
                    ),
                    Expanded(
                      child: _buildStatItem('Estimated Size', '${_selectedQueue!.estimatedQueueSize}', Icons.assessment),
                    ),
                  ],
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildStatItem(String label, String value, IconData icon) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(icon, color: const Color(0xFF81CF01), size: 24),
        const SizedBox(height: 4),
        Text(
          value,
          style: const TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
            color: Color(0xFF1A237E),
          ),
          overflow: TextOverflow.ellipsis,
          maxLines: 1,
        ),
        Text(
          label,
          style: const TextStyle(
            fontSize: 12,
            color: Colors.grey,
          ),
          textAlign: TextAlign.center,
          overflow: TextOverflow.ellipsis,
          maxLines: 2,
        ),
      ],
    );
  }
}

// Request Admin Account Screen (Guest)
class RequestAdminAccountScreen extends StatefulWidget {
  final List<DistributionArea> distributionAreas;
  final Function(Admin) onRequestSubmitted;

  const RequestAdminAccountScreen({
    super.key,
    required this.distributionAreas,
    required this.onRequestSubmitted,
  });

  @override
  State<RequestAdminAccountScreen> createState() => _RequestAdminAccountScreenState();
}

class _RequestAdminAccountScreenState extends State<RequestAdminAccountScreen> {
  final _formKey = GlobalKey<FormState>();
  final _fullNameController = TextEditingController();
  final _mobileController = TextEditingController();
  final _passwordController = TextEditingController();
  final _otpController = TextEditingController();
  final _notesController = TextEditingController();
  final _referenceController = TextEditingController();
  final _newQueuePointController = TextEditingController();
  final _newQueuePointDescController = TextEditingController();

  String? _selectedCountry = 'Egypt';
  String? _selectedGovernorate;
  String? _selectedCity;
  String? _selectedQueuePoint;
  bool _useNewQueuePoint = false;
  String? _selectedRole; // 'Admin' or 'Q_Admin' only
  bool _isOTPVerified = false;
  String? _otpCode;
  bool _isOTPSent = false;

  final Map<String, List<String>> _egyptGovernoratesCities = {
    'Cairo': ['Cairo', 'Nasr City', 'Heliopolis', 'Maadi', 'Zamalek', 'New Cairo', '6th of October City'],
    'Giza': ['Giza', '6th of October', 'Sheikh Zayed', 'Dokki', 'Mohandessin', 'Agouza', 'Faisal', 'Haram'],
    'Alexandria': ['Alexandria', 'Montaza', 'Sidi Bishr', 'Stanley', 'Smouha'],
    'Qalyubia': ['Banha', 'Qalyub', 'Shubra El Kheima', 'Tukh'],
    'Port Said': ['Port Said', 'Port Fouad'],
    'Suez': ['Suez', 'Arish'],
    'Dakahlia': ['Mansoura', 'Talkha', 'Mit Ghamr', 'Aga'],
    'Sharqia': ['Zagazig', '10th of Ramadan', 'Belbeis', 'Abu Hammad'],
    'Monufia': ['Shibin El Kom', 'Menouf', 'Tala', 'Ashmoun'],
    'Beheira': ['Damanhur', 'Kafr El Dawwar', 'Rashid', 'Edku'],
    'Gharbia': ['Tanta', 'Mahalla', 'Kafr El Zayat', 'Zefta'],
    'Kafr El Sheikh': ['Kafr El Sheikh', 'Desouk', 'Fuwa', 'Bilqas'],
    'Damietta': ['Damietta', 'New Damietta', 'Ras El Bar'],
    'Ismailia': ['Ismailia', 'Fayed', 'Abu Suwayr'],
    'North Sinai': ['Arish', 'Sheikh Zuweid', 'Rafah'],
    'South Sinai': ['Sharm El Sheikh', 'Dahab', 'Nuweiba', 'Taba'],
    'Red Sea': ['Hurghada', 'Marsa Alam', 'Safaga', 'El Gouna'],
    'New Valley': ['Kharga', 'Dakhla', 'Farafra'],
    'Matruh': ['Marsa Matruh', 'El Alamein', 'Sidi Barrani'],
    'Luxor': ['Luxor', 'Esna', 'Armant'],
    'Aswan': ['Aswan', 'Kom Ombo', 'Edfu'],
    'Qena': ['Qena', 'Luxor', 'Nag Hammadi'],
    'Sohag': ['Sohag', 'Akhmim', 'Girga'],
    'Assiut': ['Assiut', 'Abnoub', 'Manfalut'],
    'Minya': ['Minya', 'Malawi', 'Abu Qurqas'],
    'Beni Suef': ['Beni Suef', 'Biba', 'Al Fashn'],
    'Faiyum': ['Faiyum', 'Tamiya', 'Sinnuris'],
  };

  // Helper method to get governorate display name based on current language
  String _getGovernorateDisplayName(String governorate) {
    const Map<String, Map<String, String>> governorateNames = {
      'Cairo': {'ar': 'القاهرة', 'en': 'Cairo'},
      'Alexandria': {'ar': 'الإسكندرية', 'en': 'Alexandria'},
      'Giza': {'ar': 'الجيزة', 'en': 'Giza'},
      'Qalyubia': {'ar': 'القليوبية', 'en': 'Qalyubia'},
      'Sharqia': {'ar': 'الشرقية', 'en': 'Sharqia'},
      'Dakahlia': {'ar': 'الدقهلية', 'en': 'Dakahlia'},
      'Beheira': {'ar': 'البحيرة', 'en': 'Beheira'},
      'Kafr El Sheikh': {'ar': 'كفر الشيخ', 'en': 'Kafr El Sheikh'},
      'Monufia': {'ar': 'المنوفية', 'en': 'Monufia'},
      'Gharbia': {'ar': 'الغربية', 'en': 'Gharbia'},
      'Damietta': {'ar': 'دمياط', 'en': 'Damietta'},
      'Port Said': {'ar': 'بورسعيد', 'en': 'Port Said'},
      'Ismailia': {'ar': 'الإسماعيلية', 'en': 'Ismailia'},
      'Suez': {'ar': 'السويس', 'en': 'Suez'},
      'Faiyum': {'ar': 'الفيوم', 'en': 'Fayoum'},
      'Beni Suef': {'ar': 'بني سويف', 'en': 'Beni Suef'},
      'Minya': {'ar': 'المنيا', 'en': 'Minya'},
      'Assiut': {'ar': 'أسيوط', 'en': 'Assiut'},
      'Sohag': {'ar': 'سوهاج', 'en': 'Sohag'},
      'Qena': {'ar': 'قنا', 'en': 'Qena'},
      'Luxor': {'ar': 'الأقصر', 'en': 'Luxor'},
      'Aswan': {'ar': 'أسوان', 'en': 'Aswan'},
      'Red Sea': {'ar': 'البحر الأحمر', 'en': 'Red Sea'},
      'New Valley': {'ar': 'الوادي الجديد', 'en': 'New Valley'},
      'Matruh': {'ar': 'مطروح', 'en': 'Matrouh'},
      'North Sinai': {'ar': 'شمال سيناء', 'en': 'North Sinai'},
      'South Sinai': {'ar': 'جنوب سيناء', 'en': 'South Sinai'},
    };
    final names = governorateNames[governorate];
    if (names == null) return governorate;
    return AppLanguage.isArabic ? names['ar']! : names['en']!;
  }

  // Helper method to build governorate dropdown with localized names
  Widget _buildGovernorateDropdown(String? selectedKey, Function(String?) onChanged, {bool enabled = true}) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        border: Border.all(color: const Color(0xFFE0E0E0)),
        borderRadius: BorderRadius.circular(8),
        color: enabled ? Colors.white : Colors.grey[200],
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: selectedKey,
          isExpanded: true,
          hint: Text(AppLanguage.translate('Select governorate')),
          items: _egyptGovernoratesCities.keys.map((gov) {
            final displayName = _getGovernorateDisplayName(gov);
            return DropdownMenuItem(value: gov, child: Text(displayName));
          }).toList(),
          onChanged: enabled ? onChanged : null,
        ),
      ),
    );
  }

  List<String> get _availableCities {
    if (_selectedGovernorate == null) return [];
    return _egyptGovernoratesCities[_selectedGovernorate] ?? [];
  }

  // This will be populated from Firestore based on selected city
  List<DistributionArea> _availableDistributionAreas = [];

  @override
  void dispose() {
    _fullNameController.dispose();
    _mobileController.dispose();
    _otpController.dispose();
    _notesController.dispose();
    _referenceController.dispose();
    _newQueuePointController.dispose();
    _newQueuePointDescController.dispose();
    super.dispose();
  }

  Future<void> _sendOTP() async {
    if (_mobileController.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(AppLanguage.translate('Please enter mobile number first'))),
      );
      return;
    }

    final regex = RegExp(r'^01[0-2,5]{1}[0-9]{8}$');
    if (!regex.hasMatch(_mobileController.text)) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(AppLanguage.translate('Please enter a valid Egyptian mobile number'))),
      );
      return;
    }

    // Show loading
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const Center(child: CircularProgressIndicator()),
    );

    try {
    // Simulate OTP sending
    await Future.delayed(const Duration(milliseconds: 1000));
    
    // Generate random 6-digit OTP
    _otpCode = (100000 + (DateTime.now().millisecondsSinceEpoch % 900000)).toString();
    
    setState(() {
      _isOTPSent = true;
      _isOTPVerified = false;
        _otpController.clear();
      });

      // Close loading dialog
      if (mounted) Navigator.pop(context);

      // Send notification with OTP
      await _showOTPNotification(_otpCode!);

    ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('${AppLanguage.translate('OTP sent to')} ${_mobileController.text}'),
          backgroundColor: Colors.green,
        ),
      );
    } catch (e) {
      if (mounted) Navigator.pop(context);
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error sending OTP: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  Future<void> _showOTPNotification(String otp) async {
    // Always show dialog for now (works on both web and mobile)
    // In the future, can add browser notifications for web
    _showOTPDialog(otp);
    
    // Optional: Try to show browser notification on web (non-blocking)
    if (kIsWeb) {
      _tryShowWebNotification(otp);
    }
  }

  Future<void> _tryShowWebNotification(String otp) async {
    // This is a non-blocking attempt to show browser notification
    // The dialog will always show regardless
    try {
      // Browser notification code would go here
      // For now, we rely on the dialog which works reliably
    } catch (e) {
      // Silently fail - dialog is already shown
    }
  }

  void _showOTPDialog(String otp) {
    if (!mounted) return;
    
    // Use a small delay to ensure the loading dialog is closed first
    Future.delayed(const Duration(milliseconds: 300), () {
      if (!mounted) return;
      
      showDialog(
        context: context,
        barrierDismissible: true,
        builder: (context) => AlertDialog(
          title: Text(AppLanguage.translate('OTP Verification')),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text('${AppLanguage.translate('Your OTP code is')}:'),
              const SizedBox(height: 8),
              Text(
                otp,
                style: const TextStyle(
                  fontSize: 32,
                  fontWeight: FontWeight.bold,
                  color: Color(0xFF81CF01),
                  letterSpacing: 4,
                ),
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.pop(context);
                setState(() {
                  _otpController.text = otp;
                });
                // Auto-verify if OTP is filled
                Future.delayed(const Duration(milliseconds: 100), () {
                  _verifyOTP();
                });
              },
              child: Text(AppLanguage.translate('Fill OTP')),
            ),
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: Text(AppLanguage.translate('Close')),
            ),
          ],
        ),
      );
    });
  }

  dynamic _createWebNotification(String title, String body, String otp) {
    if (kIsWeb) {
      try {
        // Use JavaScript interop to create notification
        // This is a simplified approach - in production you'd use proper JS interop
        return null; // Will use dialog fallback for now
      } catch (e) {
        return null;
      }
    }
    return null;
  }

  void _setupNotificationClickHandler(dynamic notification, String otp) {
    // Handle notification click to auto-fill OTP
    // This would be implemented with proper JS interop
  }

  Future<bool> _requestWebNotificationPermission() async {
    if (kIsWeb) {
      try {
        // For now, always return false to use dialog fallback
        // In production, implement proper browser notification API
        return false;
      } catch (e) {
        print('Notification permission error: $e');
        return false;
      }
    }
    return false;
  }

  void _verifyOTP() {
    if (_otpController.text == _otpCode) {
      setState(() {
        _isOTPVerified = true;
      });
      // Don't show SnackBar - message will appear under mobile field
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(AppLanguage.translate('Invalid OTP. Please try again'))),
      );
    }
  }

  Future<void> _handleSubmit() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }
    
    if (!_isOTPVerified) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please verify mobile number with OTP first')),
      );
      return;
    }
    if (_selectedGovernorate == null || _selectedCity == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select governorate and city')),
      );
      return;
    }
    if (_selectedQueuePoint == null && !_useNewQueuePoint) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select or create a queue point')),
      );
      return;
    }
    if (_useNewQueuePoint && _newQueuePointController.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter queue point name')),
      );
      return;
    }
    if (_passwordController.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter password')),
      );
      return;
    }

    // Show loading indicator
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const Center(child: CircularProgressIndicator()),
    );

    try {
      // Get distribution point name
      String distributionPointName;
      String? distributionPointDescription;
      bool isNewDistributionArea = false;
      
      if (_useNewQueuePoint) {
        // Using new distribution point - will be created on approval
        distributionPointName = _newQueuePointController.text;
        distributionPointDescription = _newQueuePointDescController.text.isNotEmpty
            ? _newQueuePointDescController.text
            : null;
        isNewDistributionArea = true;
      } else {
        // Using predefined distribution point from database
        distributionPointName = _selectedQueuePoint!;
        distributionPointDescription = null;
        isNewDistributionArea = false;
      }

      final adminRequest = Admin(
        id: '', // Will be set by Firestore
        country: _selectedCountry!,
        governorate: _selectedGovernorate!,
        city: _selectedCity!,
        distributionPoint: distributionPointName,
        distributionPointDescription: distributionPointDescription,
        fullName: _fullNameController.text,
        mobile: _mobileController.text,
        password: _passwordController.text,
        role: _selectedRole,
        notes: _notesController.text,
        reference: _referenceController.text.isNotEmpty ? _referenceController.text : null,
        status: 'pending',
        isRequestedByGuest: true,
        createdAt: DateTime.now(),
      );

      // Save to Firestore
      print('💾 Saving admin request to Firestore...');
      final requestId = await AdminRequestService.createRequest(
        adminRequest,
        isNewDistributionArea: isNewDistributionArea,
      );
      print('✅ Admin request saved to Firestore with ID: $requestId');

      // Update admin request with the ID from Firestore
      final createdRequest = adminRequest.copyWith(id: requestId);

      // Also call the callback for backward compatibility
      widget.onRequestSubmitted(createdRequest);
      
      if (!mounted) return;
      
      Navigator.pop(context); // Close loading dialog
      Navigator.of(context).pop(); // Close the screen
      
      if (!mounted) return;
      
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Admin request submitted successfully. Waiting for approval.'),
          backgroundColor: Colors.green,
        ),
      );
    } catch (e, stackTrace) {
      print('❌ Error submitting admin request: $e');
      print('Stack trace: $stackTrace');
      if (mounted) {
        Navigator.pop(context); // Close loading dialog
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error submitting request: $e'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 5),
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    const tealGreen = Color(0xFF81CF01);
    const darkBlue = Color(0xFF1A237E);

    return Scaffold(
      appBar: AppBar(
        title: Text(AppLanguage.translate('Request Admin Account')),
        backgroundColor: tealGreen,
        foregroundColor: Colors.white,
      ),
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Color(0xFFE8F5E9), Colors.white],
          ),
        ),
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(20.0),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Request Admin Account',
                  style: TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                    color: darkBlue,
                  ),
                ),
                const SizedBox(height: 8),
                const Text(
                  'Fill in your information to request admin access',
                  style: TextStyle(fontSize: 14, color: Colors.grey),
                ),
                const SizedBox(height: 32),
                _buildLabel('Country *'),
                const SizedBox(height: 8),
                _buildDropdown(
                  _selectedCountry ?? '',
                  ['Egypt'],
                  (value) => setState(() => _selectedCountry = value),
                ),
                const SizedBox(height: 24),
                _buildLabel('Governorate *'),
                const SizedBox(height: 8),
                _buildGovernorateDropdown(
                  _selectedGovernorate,
                  (value) => setState(() {
                    _selectedGovernorate = value;
                    _selectedCity = null;
                    _selectedQueuePoint = null;
                  }),
                ),
                const SizedBox(height: 24),
                _buildLabel('City *'),
                const SizedBox(height: 8),
                _buildDropdown(
                  _selectedCity ?? '',
                  _availableCities,
                  (value) => setState(() {
                    _selectedCity = value;
                    _selectedQueuePoint = null;
                    _useNewQueuePoint = false;
                  }),
                  enabled: _selectedGovernorate != null,
                ),
                const SizedBox(height: 24),
                _buildLabel('Q Point (Distribution Point) *'),
                const SizedBox(height: 8),
                // Use StreamBuilder to load distribution areas from Firestore
                StreamBuilder<List<DistributionArea>>(
                  stream: DistributionAreaService.getAllAreas(),
                  builder: (context, snapshot) {
                    // Show loading if we're waiting for initial data
                    if (snapshot.connectionState == ConnectionState.waiting) {
                      return const SizedBox(
                        height: 50,
                        child: Center(child: CircularProgressIndicator()),
                      );
                    }
                    
                    // Show loading if connection is active but no data yet (first load)
                    if (snapshot.connectionState == ConnectionState.active && !snapshot.hasData) {
                      return const SizedBox(
                        height: 50,
                        child: Center(child: CircularProgressIndicator()),
                      );
                    }
                    
                    // If there's an error, show error message but still allow "Others" option
                    if (snapshot.hasError) {
                      print('⚠️ Error loading distribution areas: ${snapshot.error}');
                      return Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            'Error loading areas. You can create a new one below.',
                            style: TextStyle(color: Colors.orange[700], fontSize: 12),
                          ),
                          const SizedBox(height: 8),
                          _buildDropdown(
                            _useNewQueuePoint ? 'Others' : (_selectedQueuePoint ?? ''),
                            ['Others'],
                            (value) {
                              setState(() {
                                _useNewQueuePoint = true;
                                _selectedQueuePoint = null;
                              });
                            },
                            enabled: _selectedCity != null,
                          ),
                        ],
                      );
                    }
                    
                    // Filter areas by selected city
                    final allAreas = snapshot.data ?? <DistributionArea>[];
                    final cityAreas = _selectedCity != null
                        ? allAreas.where((area) => area.city == _selectedCity).toList()
                        : <DistributionArea>[];
                    
                    // Update local list
                    _availableDistributionAreas = cityAreas;
                    
                    // Create list of area names + "Others" option
                    final areaNames = cityAreas.map((area) => area.areaName).toList();
                    final dropdownItems = <String>[...areaNames, 'Others'];
                    
                    // If no areas found for the city, show message but allow "Others"
                    if (_selectedCity != null && cityAreas.isEmpty && allAreas.isNotEmpty) {
                      return Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            'No distribution areas found for this city. You can create a new one.',
                            style: TextStyle(color: Colors.grey[600], fontSize: 12),
                          ),
                          const SizedBox(height: 8),
                          _buildDropdown(
                            _useNewQueuePoint ? 'Others' : (_selectedQueuePoint ?? ''),
                            ['Others'],
                            (value) {
                              setState(() {
                                _useNewQueuePoint = true;
                                _selectedQueuePoint = null;
                              });
                            },
                            enabled: true,
                          ),
                        ],
                      );
                    }
                    
                    return _buildDropdown(
                      _useNewQueuePoint ? 'Others' : (_selectedQueuePoint ?? ''),
                      dropdownItems,
                      (value) {
                        setState(() {
                          if (value == 'Others') {
                            _useNewQueuePoint = true;
                            _selectedQueuePoint = null;
                          } else {
                            _useNewQueuePoint = false;
                            _selectedQueuePoint = value;
                          }
                        });
                      },
                      enabled: _selectedCity != null,
                    );
                  },
                ),
                if (_useNewQueuePoint) ...[
                  const SizedBox(height: 16),
                  TextFormField(
                    controller: _newQueuePointController,
                    decoration: _buildInputDecoration('Queue Point Name *'),
                    validator: (value) => value?.isEmpty ?? true ? 'Required' : null,
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    controller: _newQueuePointDescController,
                    maxLines: 3,
                    decoration: _buildInputDecoration('Queue Point Description'),
                  ),
                ],
                const SizedBox(height: 24),
                _buildLabel('Full Name *'),
                const SizedBox(height: 8),
                TextFormField(
                  controller: _fullNameController,
                  decoration: _buildInputDecoration('Enter full name'),
                  validator: (value) => value?.isEmpty ?? true ? 'Required' : null,
                ),
                const SizedBox(height: 24),
                _buildLabel('Mobile *'),
                const SizedBox(height: 8),
                Row(
                  children: [
                    Expanded(
                      child: TextFormField(
                        controller: _mobileController,
                        keyboardType: TextInputType.phone,
                        decoration: _buildInputDecoration('Enter mobile number'),
                        enabled: !_isOTPVerified,
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return 'Required';
                          }
                          final regex = RegExp(r'^01[0-2,5]{1}[0-9]{8}$');
                          if (!regex.hasMatch(value)) {
                            return 'Invalid Egyptian mobile number';
                          }
                          return null;
                        },
                      ),
                    ),
                    const SizedBox(width: 8),
                    ElevatedButton(
                      onPressed: _isOTPVerified ? null : _sendOTP,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: tealGreen,
                        foregroundColor: Colors.white,
                      ),
                      child: Text(_isOTPVerified ? 'Verified' : 'Send OTP'),
                    ),
                  ],
                ),
                if (_isOTPVerified) ...[
                  const SizedBox(height: 8),
                  Row(
                    children: [
                      const Icon(
                        Icons.check_circle,
                        color: Colors.green,
                        size: 20,
                      ),
                      const SizedBox(width: 8),
                      Text(
                        AppLanguage.translate('Mobile number verified'),
                        style: const TextStyle(
                          color: Colors.green,
                          fontSize: 14,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ),
                ],
                if (_isOTPSent && !_isOTPVerified) ...[
                  const SizedBox(height: 16),
                  Row(
                    children: [
                      Expanded(
                        child: TextFormField(
                          controller: _otpController,
                          keyboardType: TextInputType.number,
                          decoration: _buildInputDecoration('Enter OTP'),
                          maxLength: 6,
                        ),
                      ),
                      const SizedBox(width: 8),
                      ElevatedButton(
                        onPressed: _verifyOTP,
                        style: ElevatedButton.styleFrom(
                          backgroundColor: tealGreen,
                          foregroundColor: Colors.white,
                        ),
                        child: const Text('Verify'),
                      ),
                    ],
                  ),
                ],
                const SizedBox(height: 24),
                _buildLabel('Password *'),
                const SizedBox(height: 8),
                TextFormField(
                  controller: _passwordController,
                  obscureText: true,
                  decoration: _buildInputDecoration('Enter password'),
                  validator: (value) => value?.isEmpty ?? true ? 'Required' : null,
                ),
                const SizedBox(height: 24),
                _buildLabel('Role *'),
                const SizedBox(height: 8),
                _buildDropdown(
                  _selectedRole ?? '',
                  ['Admin', 'Q_Admin'], // Only Admin and Q_Admin, not Super_Admin
                  (value) => setState(() => _selectedRole = value),
                ),
                const SizedBox(height: 24),
                _buildLabel('Notes *'),
                const SizedBox(height: 8),
                TextFormField(
                  controller: _notesController,
                  maxLines: 3,
                  decoration: _buildInputDecoration('Enter notes'),
                  validator: (value) => value?.isEmpty ?? true ? 'Required' : null,
                ),
                const SizedBox(height: 24),
                _buildLabel('Reference (Optional)'),
                const SizedBox(height: 8),
                TextFormField(
                  controller: _referenceController,
                  decoration: _buildInputDecoration('Enter reference'),
                ),
                const SizedBox(height: 32),
                ElevatedButton(
                  onPressed: _handleSubmit,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: tealGreen,
                    foregroundColor: Colors.white,
                    minimumSize: const Size(double.infinity, 0),
                    padding: const EdgeInsets.symmetric(vertical: 16),
                  ),
                  child: Text(AppLanguage.translate('Submit Request')),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildLabel(String text) {
    return Text(
      AppLanguage.translate(text),
      style: const TextStyle(fontSize: 14, fontWeight: FontWeight.w500, color: Color(0xFF1A237E)),
    );
  }

  InputDecoration _buildInputDecoration(String hint) {
    return InputDecoration(
      hintText: AppLanguage.translate(hint),
      border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
      filled: true,
      fillColor: Colors.white,
    );
  }

  Widget _buildDropdown(String value, List<String> items, Function(String?) onChanged, {bool enabled = true}) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        border: Border.all(color: const Color(0xFFE0E0E0)),
        borderRadius: BorderRadius.circular(8),
        color: enabled ? Colors.white : Colors.grey[200],
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: value.isEmpty ? null : value,
          isExpanded: true,
          hint: Text(enabled ? 'Select' : 'Select previous field first'),
          items: items.map((item) => DropdownMenuItem(value: item, child: Text(AppLanguage.translate(item)))).toList(),
          onChanged: enabled ? onChanged : null,
        ),
      ),
    );
  }
}

// Reports Screen
class ReportsScreen extends StatefulWidget {
  final List<Queue> queues;
  final List<Beneficiary> beneficiaries;
  final List<DistributionArea> distributionAreas;

  const ReportsScreen({
    super.key,
    required this.queues,
    required this.beneficiaries,
    required this.distributionAreas,
  });

  @override
  State<ReportsScreen> createState() => _ReportsScreenState();
}

class _ReportsScreenState extends State<ReportsScreen> {
  String? _selectedDistributionArea;
  List<DistributionArea> _distributionAreas = [];
  List<Map<String, dynamic>> _servedReports = [];
  List<Map<String, dynamic>> _allServedReports = []; // Store all reports for filtering
  bool _isLoadingReports = false;
  List<Queue> _allQueues = [];

  @override
  void initState() {
    super.initState();
    _loadServedReports();
    // Initialize with widget queues, then update from stream
    _allQueues = widget.queues;
  }

  List<DistributionArea> _filterDistributionAreas(List<DistributionArea> allAreas) {
    final currentAdmin = AdminService.currentAdmin;
    
    // Super Admin or admin with distributionPoint == "All" can see all areas
    if (currentAdmin != null && 
        (currentAdmin.isSuperAdmin || currentAdmin.distributionPoint.toLowerCase() == 'all')) {
      return allAreas;
    } else if (currentAdmin != null && currentAdmin.distributionPoint.isNotEmpty) {
      final filteredAreas = allAreas.where((area) {
        final adminPoint = currentAdmin.distributionPoint.toLowerCase();
        final areaName = area.areaName.toLowerCase();
        return areaName.contains(adminPoint) || adminPoint.contains(areaName);
      }).toList();
      return filteredAreas.isNotEmpty ? filteredAreas : allAreas;
    } else {
      return allAreas;
    }
  }

  Future<void> _loadServedReports() async {
    setState(() {
      _isLoadingReports = true;
    });

    try {
      final reports = await BeneficiaryService.getServedBeneficiariesReport(_selectedDistributionArea);
      setState(() {
        _allServedReports = reports; // Store all reports
        _servedReports = reports;
        _isLoadingReports = false;
      });
    } catch (e) {
      print('Error loading served reports: $e');
      setState(() {
        _isLoadingReports = false;
      });
    }
  }

  List<DistributionArea> _getAvailableDistributionAreas() {
    // Get unique distribution areas from the served reports
    final areaIds = <String>{};
    for (final report in _allServedReports) {
      final beneficiary = report['beneficiary'] as Beneficiary;
      if (beneficiary.distributionArea.isNotEmpty) {
        areaIds.add(beneficiary.distributionArea);
      }
    }
    
    // Return distribution areas that match the IDs in reports
    return _distributionAreas.where((area) => areaIds.contains(area.id)).toList()
      ..sort((a, b) => a.fullName.compareTo(b.fullName));
  }

  Future<List<Map<String, dynamic>>> _loadAllReports() async {
    try {
      // Load all reports without filtering by distribution area
      final reports = await BeneficiaryService.getServedBeneficiariesReport(null);
      print('Loaded ${reports.length} reports for export');
      return reports;
    } catch (e) {
      print('Error loading all reports: $e');
      rethrow; // Re-throw so caller can handle the error
    }
  }

  String? _getUnitNameForBeneficiary(Beneficiary beneficiary) {
    try {
      // Use _allQueues which includes both widget.queues and stream data
      final queuesToSearch = _allQueues.isNotEmpty ? _allQueues : widget.queues;
      
      // First try to find queue by initialAssignedQueuePoint (queue name)
      if (beneficiary.initialAssignedQueuePoint.isNotEmpty) {
        final queuesByName = queuesToSearch.where(
          (q) => q.name == beneficiary.initialAssignedQueuePoint,
        ).toList();
        if (queuesByName.isNotEmpty) {
          return queuesByName.first.unitName;
        }
      }
      
      // If not found, try to find by distribution area
      if (beneficiary.distributionArea.isNotEmpty) {
        final queuesByArea = queuesToSearch.where(
          (q) => q.distributionArea == beneficiary.distributionArea,
        ).toList();
        if (queuesByArea.isNotEmpty) {
          return queuesByArea.first.unitName;
        }
      }
      
      // Default fallback
      return 'Meals';
    } catch (e) {
      print('Error getting unit name for beneficiary: $e');
      return 'Meals';
    }
  }

  String _getDistributionAreaName(String? areaId) {
    if (areaId == null || areaId.isEmpty) {
      return 'N/A';
    }
    
    try {
      final area = _distributionAreas.firstWhere(
        (area) => area.id == areaId,
        orElse: () => DistributionArea(
          id: '',
          country: '',
          governorate: '',
          city: '',
          areaName: areaId, // Fallback to ID if not found
        ),
      );
      return area.areaName.isNotEmpty ? area.areaName : areaId;
    } catch (e) {
      print('Error getting distribution area name: $e');
      return areaId; // Return ID as fallback
    }
  }

  Future<void> _exportToExcel() async {
    // Export directly for the selected queue point (no dialog)
    try {
      // Show loading
      final rootNavigator = Navigator.of(context, rootNavigator: true);
      var loadingShown = false;
      showDialog(
        context: rootNavigator.context,
        barrierDismissible: false,
        builder: (context) => const Center(child: CircularProgressIndicator()),
      );
      loadingShown = true;

      void closeLoading() {
        if (loadingShown && rootNavigator.canPop()) {
          rootNavigator.pop();
        }
        loadingShown = false;
      }

      // Get data to export - use selected area only
      List<Map<String, dynamic>> reportsToExport;
      String areaName;

      if (_servedReports.isEmpty) {
        if (context.mounted) {
          closeLoading();
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('No data to export'),
              backgroundColor: Colors.orange,
            ),
          );
        }
        return;
      }
      reportsToExport = _servedReports;
      
      // Get selected area name for filename
      if (_selectedDistributionArea != null) {
        final selectedArea = _distributionAreas.firstWhere(
          (area) => area.id == _selectedDistributionArea,
          orElse: () => DistributionArea(
            id: '',
            country: '',
            governorate: '',
            city: '',
            areaName: 'All Areas',
          ),
        );
        areaName = selectedArea.areaName;
      } else {
        areaName = 'All Areas';
      }

      if (reportsToExport.isEmpty) {
        if (context.mounted) {
          closeLoading(); // Close loading
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('No data to export'),
              backgroundColor: Colors.orange,
            ),
          );
        }
        return;
      }

      // Create Excel file
      final excel = excel_package.Excel.createExcel();
      
      // Delete default sheet - try multiple approaches
      try {
        // First, try to get and delete the default sheet
        final defaultSheetName = excel.getDefaultSheet();
        if (defaultSheetName != null && defaultSheetName.isNotEmpty && defaultSheetName != 'Point Q Report') {
          excel.delete(defaultSheetName);
        }
      } catch (e) {
        // If getDefaultSheet doesn't work, try deleting common default names
        try {
          if (excel.sheets.containsKey('Sheet1')) {
            excel.delete('Sheet1');
          }
        } catch (_) {}
      }
      
      // Create new sheet with our data (this will create it if it doesn't exist)
      final sheet = excel['Point Q Report'];
      
      // Final cleanup: ensure no other sheets exist
      try {
        // Get all sheet names and delete any that aren't our target sheet
        final allSheetNames = excel.sheets.keys.toList();
        for (final sheetName in allSheetNames) {
          if (sheetName != 'Point Q Report') {
            excel.delete(sheetName);
          }
        }
      } catch (e) {
        // If sheets property doesn't exist or isn't accessible, continue
        print('Note: Could not access sheets list for cleanup: $e');
      }

      // Add headers
      final headers = [
        'Serving Date',
        'Serving Time',
        'Beneficiary Name',
        'Distribution Area',
        'Queue Point',
        'No. of Units',
        'Unit Name',
      ];
      // Add headers
      for (int i = 0; i < headers.length; i++) {
        final cell = sheet.cell(excel_package.CellIndex.indexByColumnRow(columnIndex: i, rowIndex: 0));
        cell.value = excel_package.TextCellValue(headers[i]);
        // Style header with bold text (colors may not be available in this version)
        cell.cellStyle = excel_package.CellStyle(
          bold: true,
        );
      }

      // Add data rows
      for (int i = 0; i < reportsToExport.length; i++) {
        final report = reportsToExport[i];
        final beneficiary = report['beneficiary'] as Beneficiary;
        final servedAt = report['servedAt'] as DateTime?;
        final unitName = _getUnitNameForBeneficiary(beneficiary);

        final servingDate = servedAt != null
            ? '${servedAt.day}/${servedAt.month}/${servedAt.year}'
            : 'N/A';
        final servingTime = servedAt != null
            ? '${servedAt.hour.toString().padLeft(2, '0')}:${servedAt.minute.toString().padLeft(2, '0')}'
            : 'N/A';

        // Add data row
        final rowIndex = i + 1; // +1 because row 0 is headers
        final distributionAreaName = _getDistributionAreaName(beneficiary.distributionArea);
        final rowData = [
          servingDate,
          servingTime,
          beneficiary.name,
          distributionAreaName, // Use area name instead of ID
          beneficiary.initialAssignedQueuePoint.isNotEmpty ? beneficiary.initialAssignedQueuePoint : 'N/A',
          beneficiary.unitsTaken,
          unitName ?? 'N/A',
        ];
        
        for (int col = 0; col < rowData.length; col++) {
          final cell = sheet.cell(excel_package.CellIndex.indexByColumnRow(columnIndex: col, rowIndex: rowIndex));
          if (col == 5) { // Units column is integer
            cell.value = excel_package.IntCellValue(rowData[col] as int);
          } else {
            cell.value = excel_package.TextCellValue(rowData[col].toString());
          }
        }
      }

      // Generate filename with timestamp
      final timestamp = DateTime.now().toString().replaceAll(':', '-').split('.')[0];
      final filename = 'Point_Q_Report_${areaName.replaceAll(' ', '_')}_$timestamp.xlsx';

      // Save file
      final bytes = excel.save();
      if (bytes == null) {
        if (context.mounted) {
          Navigator.pop(context);
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Error: Could not generate Excel file'),
              backgroundColor: Colors.red,
            ),
          );
        }
        return;
      }

      // Convert List<int> to Uint8List
      final uint8Bytes = Uint8List.fromList(bytes!);
      
      if (kIsWeb) {
        // Close loading before invoking share (share dialogs can block/never return on some platforms)
        if (context.mounted) {
          closeLoading();
        }
        // For web, create XFile from bytes
        final xlsx = XFile.fromData(
          uint8Bytes,
          mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
          name: filename,
        );
        try {
          await Share.shareXFiles([xlsx], text: 'Point Q Report');
        } catch (e) {
          if (context.mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Exported file generated but share is not available: $e'),
                backgroundColor: Colors.orange,
              ),
            );
          }
        }
      } else {
        // For mobile/desktop, save to device
        final directory = await getApplicationDocumentsDirectory();
        final filePath = '${directory.path}/$filename';
        final file = File(filePath);
        await file.writeAsBytes(uint8Bytes);

        // Close loading BEFORE share to avoid stuck loader if share sheet blocks/doesn't return.
        if (context.mounted) {
          closeLoading();
        }

        // Share the file on mobile platforms; on desktop just show the saved path.
        final isMobile = defaultTargetPlatform == TargetPlatform.android ||
            defaultTargetPlatform == TargetPlatform.iOS;
        if (isMobile) {
          try {
            final xFile = XFile(filePath);
            await Share.shareXFiles([xFile], text: 'Point Q Report');
          } catch (e) {
            if (context.mounted) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('Saved to: $filePath (sharing failed: $e)'),
                  backgroundColor: Colors.orange,
                ),
              );
            }
          }
        } else {
          if (context.mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Report saved to: $filePath'),
                backgroundColor: Colors.green,
              ),
            );
          }
        }
      }

      // Success message is already shown above (either in share success or file path message)
      // No need to show duplicate message
    } catch (e) {
      // Close loading dialog
      if (context.mounted) {
        final rootNavigator = Navigator.of(context, rootNavigator: true);
        if (rootNavigator.canPop()) {
          rootNavigator.pop();
        }
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error exporting report: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
      print('Error exporting to Excel: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    const tealGreen = Color(0xFF81CF01);
    final activeQueues = widget.queues.where((q) => q.status == 'active' && !q.isCompleted).length;
    final totalBeneficiaries = widget.beneficiaries.length;
    final servedBeneficiaries = widget.beneficiaries.where((b) => b.isServed == true).length;

    return Scaffold(
      appBar: AppBar(
        title: Text(AppLanguage.translate('Reports')),
        backgroundColor: tealGreen,
        foregroundColor: Colors.white,
        actions: [
          IconButton(
            icon: const Icon(Icons.download),
            tooltip: 'Export to Excel',
            onPressed: _exportToExcel,
          ),
        ],
      ),
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Color(0xFFE8F5E9), Colors.white],
          ),
        ),
        child: Column(
          children: [
            // Queue Point Filter
            Padding(
              padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                    AppLanguage.translate('Queue Point'),
                style: const TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w600,
                      color: Color(0xFF1A237E),
                    ),
                  ),
                  const SizedBox(height: 8),
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                    decoration: BoxDecoration(
                      border: Border.all(color: const Color(0xFFE0E0E0)),
                      borderRadius: BorderRadius.circular(8),
                      color: Colors.white,
                    ),
                    child: StreamBuilder<List<DistributionArea>>(
                      stream: DistributionAreaService.getAllAreas().timeout(
                        const Duration(seconds: 10),
                        onTimeout: (sink) {
                          sink.addError(TimeoutException('Loading queue points timed out'));
                        },
                      ),
                      builder: (context, snapshot) {
                        List<DistributionArea> displayAreas = [];

                        if (snapshot.hasData) {
                          displayAreas = _filterDistributionAreas(snapshot.data!);
                          // Update local list for export function
                          if (mounted) {
                            WidgetsBinding.instance.addPostFrameCallback((_) {
                              if (mounted) {
                                setState(() {
                                  _distributionAreas = displayAreas;
                                });
                              }
                            });
                          }
                        } else if (snapshot.hasError) {
                          // Handle error case - fallback to widget data if available
                          displayAreas = widget.distributionAreas.isNotEmpty
                              ? _filterDistributionAreas(widget.distributionAreas)
                              : [];
                          print('Error loading distribution areas: ${snapshot.error}');
                          if (mounted) {
                            WidgetsBinding.instance.addPostFrameCallback((_) {
                              if (mounted) {
                                setState(() {
                                  _distributionAreas = displayAreas;
                                });
                              }
                            });
                          }
                        } else if (snapshot.connectionState == ConnectionState.none) {
                          // Stream not connected - fallback to widget data
                          displayAreas = widget.distributionAreas.isNotEmpty
                              ? _filterDistributionAreas(widget.distributionAreas)
                              : [];
                          if (mounted) {
                            WidgetsBinding.instance.addPostFrameCallback((_) {
                              if (mounted) {
                                setState(() {
                                  _distributionAreas = displayAreas;
                                });
                              }
                            });
                          }
                        }

                        // Determine if we're still loading
                        final isLoading = snapshot.connectionState == ConnectionState.waiting && !snapshot.hasData;

                        // Validate selected value exists in current areas
                        String? validSelectedValue = _selectedDistributionArea;
                        if (validSelectedValue != null && displayAreas.isNotEmpty) {
                          final exists = displayAreas.any((area) => area.id == validSelectedValue);
                          if (!exists) {
                            // Reset selection if it doesn't exist anymore
                            if (mounted) {
                              WidgetsBinding.instance.addPostFrameCallback((_) {
                                if (mounted) {
                                  setState(() {
                                    _selectedDistributionArea = null;
                                  });
                                  _loadServedReports(); // Reload reports with no filter
                                }
                              });
                            }
                            validSelectedValue = null;
                          }
                        }

                        return DropdownButtonHideUnderline(
                          child: DropdownButton<String>(
                            value: validSelectedValue,
                            isExpanded: true,
                            hint: Text(isLoading
                                ? AppLanguage.translate('Loading...')
                                : snapshot.hasError
                                    ? AppLanguage.translate('Error loading queue points')
                                    : AppLanguage.translate('Select Queue Point')),
                            items: displayAreas.isEmpty
                                ? [
                                    DropdownMenuItem<String>(
                                      value: null,
                                      enabled: false,
                                      child: Text(
                                        isLoading
                                            ? AppLanguage.translate('Loading...')
                                            : snapshot.hasError
                                                ? AppLanguage.translate('Error: Unable to load queue points')
                                                : AppLanguage.translate('No queue points available'),
                                        style: TextStyle(color: Colors.grey[600]),
                                      ),
                                    ),
                                  ]
                                : [
                                    if (displayAreas.length > 1)
                                      DropdownMenuItem<String>(
                                        value: null,
                                        child: Text(AppLanguage.translate('All Queue Points')),
                                      ),
                                    ...displayAreas.map((area) {
                                      return DropdownMenuItem<String>(
                                        value: area.id,
                                        child: Text(
                                          area.fullName,
                                          overflow: TextOverflow.ellipsis,
                                          maxLines: 1,
                                        ),
                                      );
                                    }).toList(),
                                  ],
                            onChanged: displayAreas.isEmpty ? null : (value) {
                              setState(() {
                                _selectedDistributionArea = value;
                              });
                              _loadServedReports();
                            },
                          ),
                        );
                      },
                    ),
                  ),
                ],
              ),
            ),
            // Detailed Reports Section
            Expanded(
              child: StreamBuilder<List<Queue>>(
                stream: QueueService.getAllQueues(),
                builder: (context, queueSnapshot) {
                  // Update local queues list when stream data is available
                  if (queueSnapshot.hasData) {
                    WidgetsBinding.instance.addPostFrameCallback((_) {
                      if (mounted) {
                        setState(() {
                          _allQueues = queueSnapshot.data!;
                        });
                      }
                    });
                  }
                  
                  return _isLoadingReports
                      ? const Center(child: CircularProgressIndicator())
                      : _servedReports.isEmpty
                          ? Center(
                              child: Column(
                                mainAxisAlignment: MainAxisAlignment.center,
                                children: [
                                  Icon(
                                    Icons.description_outlined,
                                    size: 64,
                                    color: Colors.grey[400],
              ),
              const SizedBox(height: 16),
                                  Text(
                                    'No served beneficiaries found',
                                    style: TextStyle(
                                      fontSize: 18,
                                      fontWeight: FontWeight.w500,
                                      color: Colors.grey[700],
                                    ),
                                  ),
                                ],
                              ),
                            )
                          : SingleChildScrollView(
                              padding: const EdgeInsets.symmetric(horizontal: 16),
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
              Text(
                                    'Point Q Report - Served Beneficiaries',
                style: const TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                                      color: Color(0xFF1A237E),
                ),
              ),
              const SizedBox(height: 16),
                                  // Table Header
                                  Container(
                                    padding: const EdgeInsets.all(12),
                                    decoration: BoxDecoration(
                                      color: tealGreen.withOpacity(0.1),
                                      borderRadius: BorderRadius.circular(8),
                                    ),
                                    child: Row(
                                      children: [
                                        Expanded(
                                          flex: 2,
                                          child: Text(
                                            'Serving Date',
                                            style: const TextStyle(
                                              fontWeight: FontWeight.bold,
                                              fontSize: 14,
                                            ),
                                          ),
                                        ),
                                        Expanded(
                                          flex: 2,
                                          child: Text(
                                            'Serving Time',
                                            style: const TextStyle(
                                              fontWeight: FontWeight.bold,
                                              fontSize: 14,
                                            ),
                                          ),
                                        ),
            Expanded(
                                          flex: 3,
                                          child: Text(
                                            'Beneficiary Name',
                    style: const TextStyle(
                                              fontWeight: FontWeight.bold,
                      fontSize: 14,
                                            ),
                                          ),
                                        ),
                                        Expanded(
                                          flex: 2,
                                          child: Text(
                                            'No. of Units',
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                                              fontSize: 14,
                                            ),
                                          ),
                                        ),
                                        Expanded(
                                          flex: 2,
                                          child: Text(
                                            'Unit Name',
                                            style: const TextStyle(
                                              fontWeight: FontWeight.bold,
                                              fontSize: 14,
                                            ),
                    ),
                  ),
                ],
                                    ),
                                  ),
                                  const SizedBox(height: 8),
                                  // Table Rows
                                  ..._servedReports.map((report) {
                                    final beneficiary = report['beneficiary'] as Beneficiary;
                                    final servedAt = report['servedAt'] as DateTime?;
                                    final unitName = _getUnitNameForBeneficiary(beneficiary);
                                    
                                    return Container(
                                      margin: const EdgeInsets.only(bottom: 8),
                                      padding: const EdgeInsets.all(12),
                                      decoration: BoxDecoration(
                                        color: Colors.white,
                                        borderRadius: BorderRadius.circular(8),
                                        border: Border.all(color: Colors.grey.withOpacity(0.2)),
                                      ),
                                      child: Row(
                                        children: [
                                          Expanded(
                                            flex: 2,
                                            child: Text(
                                              servedAt != null
                                                  ? '${servedAt.day}/${servedAt.month}/${servedAt.year}'
                                                  : 'N/A',
                                              style: const TextStyle(fontSize: 12),
                                            ),
                                          ),
                                          Expanded(
                                            flex: 2,
                                            child: Text(
                                              servedAt != null
                                                  ? '${servedAt.hour.toString().padLeft(2, '0')}:${servedAt.minute.toString().padLeft(2, '0')}'
                                                  : 'N/A',
                                              style: const TextStyle(fontSize: 12),
                                            ),
                                          ),
                                          Expanded(
                                            flex: 3,
                                            child: Text(
                                              beneficiary.name,
                                              style: const TextStyle(fontSize: 12),
                                              overflow: TextOverflow.ellipsis,
                                            ),
                                          ),
                                          Expanded(
                                            flex: 2,
                                            child: Text(
                                              beneficiary.unitsTaken.toString(),
                                              style: const TextStyle(fontSize: 12),
                                            ),
                                          ),
                                          Expanded(
                                            flex: 2,
                                            child: Text(
                                              unitName ?? 'N/A',
                                              style: const TextStyle(fontSize: 12),
                                              overflow: TextOverflow.ellipsis,
                                            ),
                                          ),
                                        ],
                                      ),
                                    );
                                  }).toList(),
                                ],
                              ),
                            );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// Settings Screen
class SettingsScreen extends StatefulWidget {
  const SettingsScreen({super.key});

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  bool _notificationsEnabled = true;
  bool _darkModeEnabled = false;

  @override
  void initState() {
    super.initState();
    // Sync with current language
    AppLanguage.languageNotifier.addListener(_onLanguageChanged);
  }

  @override
  void dispose() {
    AppLanguage.languageNotifier.removeListener(_onLanguageChanged);
    super.dispose();
  }

  void _onLanguageChanged() {
    if (mounted) {
      setState(() {});
    }
  }

  @override
  Widget build(BuildContext context) {
    const tealGreen = Color(0xFF81CF01);
    final currentLanguage = AppLanguage.currentLanguage;

    return Scaffold(
      appBar: AppBar(
        title: Text(AppLanguage.translate('Settings')),
        backgroundColor: tealGreen,
        foregroundColor: Colors.white,
      ),
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Color(0xFFE8F5E9), Colors.white],
          ),
        ),
        child: ListView(
          padding: const EdgeInsets.all(16),
          children: [
            Text(
              AppLanguage.translate('Preferences'),
              style: const TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
                color: Color(0xFF2D3748),
              ),
            ),
            const SizedBox(height: 16),
            Card(
              child: SwitchListTile(
                title: Text(AppLanguage.translate('Enable Notifications')),
                subtitle: Text(AppLanguage.translate('Receive push notifications')),
                value: _notificationsEnabled,
                onChanged: (value) {
                  setState(() {
                    _notificationsEnabled = value;
                  });
                },
                activeColor: tealGreen,
              ),
            ),
            const SizedBox(height: 12),
            Card(
              child: SwitchListTile(
                title: Text(AppLanguage.translate('Dark Mode')),
                subtitle: Text(AppLanguage.translate('Switch to dark theme')),
                value: _darkModeEnabled,
                onChanged: (value) {
                  setState(() {
                    _darkModeEnabled = value;
                  });
                },
                activeColor: tealGreen,
              ),
            ),
            const SizedBox(height: 24),
            Text(
              AppLanguage.translate('Language'),
              style: const TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
                color: Color(0xFF2D3748),
              ),
            ),
            const SizedBox(height: 16),
            Card(
              child: ListTile(
                title: Text(AppLanguage.translate('Language')),
                subtitle: Text(currentLanguage == 'English' ? AppLanguage.translate('English') : AppLanguage.translate('Arabic')),
                trailing: Icon(
                  AppLanguage.isArabic ? Icons.arrow_back_ios : Icons.arrow_forward_ios,
                  size: 16,
                ),
                onTap: () {
                  showDialog(
                    context: context,
                    builder: (context) => AlertDialog(
                      title: Text(AppLanguage.translate('Select Language')),
                      content: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          ListTile(
                            title: Text(AppLanguage.translate('English')),
                            leading: Radio<String>(
                              value: 'English',
                              groupValue: currentLanguage,
                              onChanged: (value) {
                                if (value != null) {
                                  AppLanguage.setLanguage(value);
                                  Navigator.pop(context);
                                }
                              },
                            ),
                            onTap: () {
                              AppLanguage.setLanguage('English');
                              Navigator.pop(context);
                            },
                          ),
                          ListTile(
                            title: Text(AppLanguage.translate('Arabic')),
                            leading: Radio<String>(
                              value: 'Arabic',
                              groupValue: currentLanguage,
                              onChanged: (value) {
                                if (value != null) {
                                  AppLanguage.setLanguage(value);
                                  Navigator.pop(context);
                                }
                              },
                            ),
                            onTap: () {
                              AppLanguage.setLanguage('Arabic');
                              Navigator.pop(context);
                            },
                          ),
                        ],
                      ),
                    ),
                  );
                },
              ),
            ),
            const SizedBox(height: 24),
            Text(
              AppLanguage.translate('About'),
              style: const TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
                color: Color(0xFF2D3748),
              ),
            ),
            const SizedBox(height: 16),
            Card(
              child: ListTile(
                title: Text(AppLanguage.translate('App Version')),
                subtitle: const Text('1.0.0'),
              ),
            ),
            const SizedBox(height: 12),
            Card(
              child: ListTile(
                title: Text(AppLanguage.translate('Terms & Conditions')),
                trailing: Icon(
                  AppLanguage.isArabic ? Icons.arrow_back_ios : Icons.arrow_forward_ios,
                  size: 16,
                ),
                onTap: () {},
              ),
            ),
            const SizedBox(height: 12),
            Card(
              child: ListTile(
                title: Text(AppLanguage.translate('Privacy Policy')),
                trailing: Icon(
                  AppLanguage.isArabic ? Icons.arrow_back_ios : Icons.arrow_forward_ios,
                  size: 16,
                ),
                onTap: () {},
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// Help & Support Screen
class HelpSupportScreen extends StatefulWidget {
  const HelpSupportScreen({super.key});

  @override
  State<HelpSupportScreen> createState() => _HelpSupportScreenState();
}

class _HelpSupportScreenState extends State<HelpSupportScreen> {
  final Map<String, bool> _expandedSections = {};

  @override
  Widget build(BuildContext context) {
    const tealGreen = Color(0xFF81CF01);
    const darkBlue = Color(0xFF1A237E);

    return Scaffold(
      appBar: AppBar(
        title: Text(AppLanguage.translate('Help & Support')),
        backgroundColor: tealGreen,
        foregroundColor: Colors.white,
      ),
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Color(0xFFE8F5E9), Colors.white],
          ),
        ),
        child: ListView(
          padding: const EdgeInsets.all(16),
          children: [
            // Welcome Section
            Card(
              elevation: 2,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              child: Container(
                padding: const EdgeInsets.all(20),
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(12),
                  gradient: LinearGradient(
                    colors: [tealGreen.withOpacity(0.1), Colors.white],
                  ),
                ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                    Row(
                      children: [
                        Icon(Icons.info_outline, color: tealGreen, size: 28),
                        const SizedBox(width: 12),
                        Expanded(
                          child: Text(
                            AppLanguage.translate('Welcome to EQMS'),
                            style: const TextStyle(
                              fontSize: 22,
                    fontWeight: FontWeight.bold,
                              color: darkBlue,
                            ),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),
                    Text(
                      AppLanguage.translate('This guide will help you understand and use all features of the Electronic Queue Management System.'),
                      style: TextStyle(fontSize: 14, color: Colors.grey[700]),
                    ),
                  ],
                ),
              ),
                ),
                const SizedBox(height: 24),
            
            // Table of Contents
            _buildSectionHeader('Table of Contents', Icons.list),
            const SizedBox(height: 12),
            _buildTOCItem('1. Dashboard Overview', 'dashboard'),
            _buildTOCItem('2. Creating Queues', 'create_queue'),
            _buildTOCItem('3. Adding Beneficiaries', 'add_beneficiary'),
            _buildTOCItem('4. Serving Units', 'serving'),
            _buildTOCItem('5. Admin Management', 'admin_management'),
            _buildTOCItem('6. Profile & Settings', 'profile'),
            _buildTOCItem('7. Language Settings', 'language'),
            _buildTOCItem('8. Guest Mode', 'guest_mode'),
            
            const SizedBox(height: 24),
            
            // Feature Guides
            _buildFeatureSection(
              'dashboard',
              'Dashboard Overview',
              Icons.dashboard,
              [
                AppLanguage.translate('The Dashboard is your main control center.'),
                AppLanguage.translate('Step 1: View statistics cards showing Total Queues, Active Queues, Total Beneficiaries, and Served Beneficiaries.'),
                AppLanguage.translate('Step 2: Use the Distribution Area dropdown to filter queues by location.'),
                AppLanguage.translate('Step 3: Browse all your queues in the list below.'),
                AppLanguage.translate('Step 4: Tap on any queue card to view details or manage it.'),
                AppLanguage.translate('Step 5: Use the action buttons (Edit, Start, Suspend, Complete, Delete) to manage queues.'),
                AppLanguage.translate('Navigation: Use the bottom navigation bar to switch between Dashboard, Add Queue, Add Beneficiary, Beneficiaries, and Distribution Areas.'),
              ],
            ),
            
            _buildFeatureSection(
              'create_queue',
              'Creating Queues',
              Icons.add_circle,
              [
                AppLanguage.translate('Queues help you organize and manage service distribution.'),
                AppLanguage.translate('Step 1: Navigate to "Add Queue" from the bottom navigation bar.'),
                AppLanguage.translate('Step 2: Enter a Queue Name (required).'),
                AppLanguage.translate('Step 3: Select a Distribution Area from the dropdown (required).'),
                AppLanguage.translate('Step 4: Choose Queue Type: Single Day or Multi Day.'),
                AppLanguage.translate('Step 5: Set the date range using "From Date & Time" and "To Date & Time" buttons.'),
                AppLanguage.translate('Step 6: Select Unit Name (Meals, Bags, Blankets, or Others). If "Others", enter a custom unit name.'),
                AppLanguage.translate('Step 7: Enter Number of Available Units (required).'),
                AppLanguage.translate('Step 8: Enter Estimated Queue Size (required).'),
                AppLanguage.translate('Step 9: Optionally enable "Direct Serve Option" to allow serving without tickets.'),
                AppLanguage.translate('Step 10: Select Priority groups if needed (Female, Elderly, Disability).'),
                AppLanguage.translate('Step 11: Tap "Create Queue" to save.'),
              ],
            ),
            
            _buildFeatureSection(
              'add_beneficiary',
              'Adding Beneficiaries',
              Icons.person_add,
              [
                AppLanguage.translate('Beneficiaries are the people who will receive services from your queues.'),
                AppLanguage.translate('Step 1: Navigate to "Add Beneficiary" from the bottom navigation bar.'),
                AppLanguage.translate('Step 2: Select Distribution Area (required).'),
                AppLanguage.translate('Step 3: Scan or upload ID Copy using the "Scan ID" button (required).'),
                AppLanguage.translate('Step 4: Select Beneficiary Type: Normal, Child, Widowed, Divorced, Sick, Disability, or Elderly.'),
                AppLanguage.translate('Step 5: Select Gender: Male or Female (required).'),
                AppLanguage.translate('Step 6: Enter Name (required). You can extract name from ID if ID is scanned.'),
                AppLanguage.translate('Step 7: Enter ID Number (required). The system will check for duplicates.'),
                AppLanguage.translate('Step 8: Enter Mobile Number (required).'),
                AppLanguage.translate('Step 9: If beneficiary is an Entity, toggle the switch and enter Entity Name.'),
                AppLanguage.translate('Step 10: Enter Number of Units (required).'),
                AppLanguage.translate('Step 11: Optionally enter NFC Preprinted Code if available.'),
                AppLanguage.translate('Step 12: Optionally add a Photo by tapping "Take Photo" or "Select Photo".'),
                AppLanguage.translate('Step 13: Tap "Register Beneficiary" to save.'),
              ],
            ),
            
            _buildFeatureSection(
              'serving',
              'Serving Units',
              Icons.restaurant,
              [
                AppLanguage.translate('The Serving screen allows you to serve units to beneficiaries in a queue.'),
                AppLanguage.translate('Step 1: From Dashboard, tap on a queue card to open Queue Details.'),
                AppLanguage.translate('Step 2: Tap the "Start" button to activate the queue for serving.'),
                AppLanguage.translate('Step 3: Tap "Serve" or navigate to the Serving screen.'),
                AppLanguage.translate('Step 4: Search for a beneficiary by:'),
                AppLanguage.translate('  - Scanning NFC card'),
                AppLanguage.translate('  - Entering Mobile Number'),
                AppLanguage.translate('  - Entering National ID'),
                AppLanguage.translate('Step 5: The system will automatically find and select the beneficiary.'),
                AppLanguage.translate('Step 6: Tap the "Serve" button on the beneficiary card.'),
                AppLanguage.translate('Step 7: In the popup, the maximum units are selected by default. Use the minus button to decrease if needed.'),
                AppLanguage.translate('Step 8: Tap "Serve" to confirm and mark the beneficiary as served.'),
                AppLanguage.translate('Step 9: View statistics: Served count, Attendees, Available units, and Estimated Queue Size.'),
                AppLanguage.translate('Serving Options: Access via Settings icon to enable Grace periods, No Order mode, or Without Tickets mode.'),
              ],
            ),
            
            _buildFeatureSection(
              'admin_management',
              'Admin Management',
              Icons.admin_panel_settings,
              [
                AppLanguage.translate('Admin Management is available only for Super Admins.'),
                AppLanguage.translate('Step 1: Access Admin Management from the Dashboard menu (gear icon) or AppBar.'),
                AppLanguage.translate('Step 2: View three tabs: Create Admin, Admin Requests, and Admins List.'),
                AppLanguage.translate('Creating Admin:'),
                AppLanguage.translate('  - Fill in admin details (Country, Governorate, City, Distribution Point)'),
                AppLanguage.translate('  - Enter Full Name, Mobile Number, Password'),
                AppLanguage.translate('  - Select Role: Super Admin, Q Admin, or Admin'),
                AppLanguage.translate('  - Tap "Create Admin"'),
                AppLanguage.translate('Admin Requests:'),
                AppLanguage.translate('  - View pending admin account requests from guests'),
                AppLanguage.translate('  - Review request details'),
                AppLanguage.translate('  - Approve or Reject requests'),
                AppLanguage.translate('Admins List:'),
                AppLanguage.translate('  - View all created admins'),
                AppLanguage.translate('  - Edit or manage admin accounts'),
              ],
            ),
            
            _buildFeatureSection(
              'profile',
              'Profile & Settings',
              Icons.person,
              [
                AppLanguage.translate('Access your profile and app settings.'),
                AppLanguage.translate('Step 1: Tap the Profile icon in the AppBar or open the drawer menu.'),
                AppLanguage.translate('Step 2: View your profile information: Name, Role, and Mobile Number.'),
                AppLanguage.translate('Change Password:'),
                AppLanguage.translate('  - Tap "Change Password"'),
                AppLanguage.translate('  - Enter Current Password'),
                AppLanguage.translate('  - Enter New Password'),
                AppLanguage.translate('  - Confirm New Password'),
                AppLanguage.translate('  - Tap "Change Password" button'),
                AppLanguage.translate('Language Settings:'),
                AppLanguage.translate('  - Tap "Language"'),
                AppLanguage.translate('  - Select English or Arabic'),
                AppLanguage.translate('  - The app will switch language and layout immediately'),
                AppLanguage.translate('Help & Support:'),
                AppLanguage.translate('  - Tap "Help & Support" to view this guide'),
                AppLanguage.translate('Logout:'),
                AppLanguage.translate('  - Tap the red "Logout" button at the bottom'),
                AppLanguage.translate('  - Confirm to log out and return to login screen'),
              ],
            ),
            
            _buildFeatureSection(
              'language',
              'Language Settings',
              Icons.language,
              [
                AppLanguage.translate('The app supports both English and Arabic languages.'),
                AppLanguage.translate('Step 1: Go to Profile screen.'),
                AppLanguage.translate('Step 2: Tap on "Language" option.'),
                AppLanguage.translate('Step 3: Select your preferred language: English or Arabic.'),
                AppLanguage.translate('Step 4: The app will immediately switch to the selected language.'),
                AppLanguage.translate('Features:'),
                AppLanguage.translate('  - All text, labels, and messages are translated'),
                AppLanguage.translate('  - Layout automatically switches to RTL (Right-to-Left) for Arabic'),
                AppLanguage.translate('  - Icons and arrows flip direction for Arabic'),
                AppLanguage.translate('  - All functionality remains the same in both languages'),
              ],
            ),
            
            _buildFeatureSection(
              'guest_mode',
              'Guest Mode',
              Icons.person_outline,
              [
                AppLanguage.translate('Guest Mode allows visitors to register as beneficiaries without logging in.'),
                AppLanguage.translate('Step 1: From the Login screen, tap "Continue as Guest".'),
                AppLanguage.translate('Step 2: You will see the Guest Dashboard.'),
                AppLanguage.translate('Step 3: Options available:'),
                AppLanguage.translate('  - Register as Beneficiary: Fill in your information to register'),
                AppLanguage.translate('  - Request Admin Account: Submit a request to become an admin'),
                AppLanguage.translate('Registering as Beneficiary:'),
                AppLanguage.translate('  - Follow the same steps as "Adding Beneficiaries"'),
                AppLanguage.translate('  - After registration, you can view your queue number'),
                AppLanguage.translate('Requesting Admin Account:'),
                AppLanguage.translate('  - Fill in your information'),
                AppLanguage.translate('  - Select Distribution Area'),
                AppLanguage.translate('  - Submit the request'),
                AppLanguage.translate('  - Wait for Super Admin approval'),
                AppLanguage.translate('Note: Guests have limited access and cannot manage queues or serve units.'),
              ],
            ),
            
                const SizedBox(height: 24),
            
            // Tips Section
            Card(
              elevation: 2,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              child: Container(
                padding: const EdgeInsets.all(20),
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(12),
                  color: Colors.blue.withOpacity(0.1),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Icon(Icons.lightbulb_outline, color: Colors.blue, size: 28),
                        const SizedBox(width: 12),
                        Text(
                          AppLanguage.translate('Tips & Best Practices'),
                          style: const TextStyle(
                            fontSize: 20,
                            fontWeight: FontWeight.bold,
                            color: darkBlue,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    _buildTipItem(AppLanguage.translate('Always scan beneficiary ID to ensure accurate data entry')),
                    _buildTipItem(AppLanguage.translate('Use NFC cards for faster beneficiary lookup during serving')),
                    _buildTipItem(AppLanguage.translate('Set appropriate queue sizes to avoid overbooking')),
                    _buildTipItem(AppLanguage.translate('Regularly check queue status and update as needed')),
                    _buildTipItem(AppLanguage.translate('Use priority settings to serve vulnerable groups first')),
                    _buildTipItem(AppLanguage.translate('Keep beneficiary information up to date')),
                    _buildTipItem(AppLanguage.translate('Use the search feature to quickly find beneficiaries')),
                    _buildTipItem(AppLanguage.translate('Review statistics regularly to track service delivery')),
                  ],
                ),
              ),
            ),
            
                const SizedBox(height: 24),
            
            // Contact Support
            Card(
              elevation: 2,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              child: Container(
                padding: const EdgeInsets.all(20),
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(12),
                  color: Colors.orange.withOpacity(0.1),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Icon(Icons.support_agent, color: Colors.orange, size: 28),
                        const SizedBox(width: 12),
                        Text(
                          AppLanguage.translate('Need More Help?'),
                          style: const TextStyle(
                            fontSize: 20,
                            fontWeight: FontWeight.bold,
                            color: darkBlue,
                          ),
                ),
              ],
            ),
                    const SizedBox(height: 12),
                    Text(
                      AppLanguage.translate('If you need additional assistance or encounter any issues, please contact your system administrator or support team.'),
                      style: TextStyle(fontSize: 14, color: Colors.grey[700]),
                    ),
                  ],
                ),
              ),
            ),
            
            const SizedBox(height: 32),
          ],
        ),
      ),
    );
  }

  Widget _buildSectionHeader(String title, IconData icon) {
    const tealGreen = Color(0xFF81CF01);
    return Row(
      children: [
        Icon(icon, color: tealGreen, size: 24),
        const SizedBox(width: 12),
        Text(
          AppLanguage.translate(title),
          style: const TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
            color: Color(0xFF1A237E),
          ),
        ),
      ],
    );
  }

  Widget _buildTOCItem(String title, String sectionId) {
    return InkWell(
      onTap: () {
        // Scroll to section
        setState(() {
          _expandedSections[sectionId] = true;
        });
      },
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
        child: Row(
          children: [
            Icon(
              AppLanguage.isArabic ? Icons.arrow_back_ios : Icons.arrow_forward_ios,
              size: 14,
              color: Colors.grey,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Text(
                AppLanguage.translate(title),
                style: const TextStyle(fontSize: 16, color: Color(0xFF1A237E)),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFeatureSection(String id, String title, IconData icon, List<String> steps) {
    final isExpanded = _expandedSections[id] ?? false;
    const tealGreen = Color(0xFF81CF01);
    
    return Card(
      elevation: 2,
      margin: const EdgeInsets.only(bottom: 12),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: ExpansionTile(
        key: ValueKey(id),
        initiallyExpanded: isExpanded,
        onExpansionChanged: (expanded) {
          setState(() {
            _expandedSections[id] = expanded;
          });
        },
        leading: Icon(icon, color: tealGreen),
        title: Text(
          AppLanguage.translate(title),
          style: const TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
            color: Color(0xFF1A237E),
          ),
        ),
        children: [
          Container(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: steps.asMap().entries.map((entry) {
                final step = entry.value;
                return Padding(
                  padding: const EdgeInsets.only(bottom: 12),
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      if (step.startsWith('Step ') || step.startsWith('  -'))
                        Container(
                          width: 6,
                          height: 6,
                          margin: EdgeInsets.only(
                            top: 8,
                            right: AppLanguage.isArabic ? 0 : 12,
                            left: AppLanguage.isArabic ? 12 : 0,
                          ),
                          decoration: const BoxDecoration(
                            color: tealGreen,
                            shape: BoxShape.circle,
                          ),
                        )
                      else
                        SizedBox(width: AppLanguage.isArabic ? 0 : 18),
                      Expanded(
                        child: Text(
                          step,
                          style: TextStyle(
                            fontSize: 14,
                            color: Colors.grey[800],
                            height: 1.5,
                          ),
                        ),
                      ),
                    ],
                  ),
                );
              }).toList(),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildTipItem(String tip) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Icon(Icons.check_circle_outline, color: Colors.blue, size: 20),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              tip,
              style: TextStyle(fontSize: 14, color: Colors.grey[800], height: 1.5),
            ),
          ),
        ],
      ),
    );
  }
}

// Queue History Screen
class QueueHistoryScreen extends StatefulWidget {
  final List<DistributionArea> distributionAreas;

  const QueueHistoryScreen({
    super.key,
    required this.distributionAreas,
  });

  @override
  State<QueueHistoryScreen> createState() => _QueueHistoryScreenState();
}

class _QueueHistoryScreenState extends State<QueueHistoryScreen> {
  String? _selectedDistributionArea;
  List<DistributionArea> _distributionAreas = [];
  
  // Track expansion state for Multi Day queue accordions
  final Map<String, bool> _multiDayQueueExpanded = {};
  final Map<String, Set<String>> _dailyEntryExpanded = {};

  @override
  void initState() {
    super.initState();
    _distributionAreas = widget.distributionAreas;
    _loadDistributionAreas();
  }

  Future<void> _loadDistributionAreas() async {
    try {
      final allAreas = await DistributionAreaService.getAllAreas().first;
      setState(() {
        _distributionAreas = allAreas.isNotEmpty ? allAreas : widget.distributionAreas;
      });
    } catch (e) {
      print('Error loading distribution areas: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(AppLanguage.translate('Queue History')),
        backgroundColor: const Color(0xFF81CF01),
        foregroundColor: Colors.white,
      ),
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Color(0xFFE8F5E9), Colors.white],
          ),
        ),
        child: SafeArea(
          child: LayoutBuilder(
            builder: (context, constraints) {
              final isLandscape = MediaQuery.of(context).orientation == Orientation.landscape;
              final padding = isLandscape ? 8.0 : 16.0;
              final spacing = isLandscape ? 4.0 : 8.0;
              
              return Column(
                children: [
                  Padding(
                    padding: EdgeInsets.all(padding),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          AppLanguage.translate('Distribution Area'),
                          style: TextStyle(
                            fontSize: isLandscape ? 14 : 16,
                            fontWeight: FontWeight.w600,
                            color: const Color(0xFF1A237E),
                          ),
                        ),
                        SizedBox(height: spacing),
                        StreamBuilder<List<DistributionArea>>(
                          stream: DistributionAreaService.getAllAreas(),
                          initialData: _distributionAreas,
                          builder: (context, snapshot) {
                            List<DistributionArea> displayAreas = snapshot.data ?? _distributionAreas;
                            
                            final currentAdmin = AdminService.currentAdmin;
                            if (currentAdmin != null && !currentAdmin.isSuperAdmin) {
                              final adminPoint = currentAdmin.distributionPoint.toLowerCase();
                              displayAreas = displayAreas.where((area) {
                                final areaName = area.areaName.toLowerCase();
                                return areaName.contains(adminPoint) || adminPoint.contains(areaName);
                              }).toList();
                            }
                            
                            return DropdownButtonFormField<String>(
                              value: _selectedDistributionArea,
                              isExpanded: true,
                              decoration: InputDecoration(
                                border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                                filled: true,
                                fillColor: Colors.white,
                                hintText: AppLanguage.translate('Select Distribution Area'),
                              ),
                              items: [
                                DropdownMenuItem<String>(
                                  value: null,
                                  child: Text(AppLanguage.translate('All Areas')),
                                ),
                                ...displayAreas.map((area) {
                                  return DropdownMenuItem<String>(
                                    value: area.id,
                                    child: Text(area.fullName),
                                  );
                                }).toList(),
                              ],
                              onChanged: (value) {
                                setState(() {
                                  _selectedDistributionArea = value;
                                });
                              },
                            );
                          },
                        ),
                        SizedBox(height: spacing * 2),
                        Text(
                          AppLanguage.translate('All Queues'),
                          style: TextStyle(
                            fontSize: isLandscape ? 16 : 20,
                            fontWeight: FontWeight.bold,
                            color: const Color(0xFF1A237E),
                          ),
                        ),
                        SizedBox(height: spacing),
                      ],
                    ),
                  ),
                  Expanded(
                    child: StreamBuilder<List<Queue>>(
                      stream: QueueService.getQueuesForHistory(limit: 500),
                      builder: (context, snapshot) {
                        // Show loading only on initial connection, not when data is already available
                        if (snapshot.connectionState == ConnectionState.waiting && !snapshot.hasData) {
                          return const Center(
                            child: Column(
                              mainAxisAlignment: MainAxisAlignment.center,
                              children: [
                                CircularProgressIndicator(),
                                SizedBox(height: 16),
                                Text(
                                  'Loading queues...',
                                  style: TextStyle(
                                    fontSize: 14,
                                    color: Colors.grey,
                                  ),
                                ),
                              ],
                            ),
                          );
                        }
                        
                        if (snapshot.hasError) {
                          return Center(
                            child: Padding(
                              padding: const EdgeInsets.all(16.0),
                              child: Column(
                                mainAxisAlignment: MainAxisAlignment.center,
                                children: [
                                  Icon(Icons.error_outline, size: 48, color: Colors.red[300]),
                                  const SizedBox(height: 16),
                                  Text(
                                    'Error loading queues',
                                    style: TextStyle(
                                      fontSize: 16,
                                      fontWeight: FontWeight.w500,
                                      color: Colors.red[700],
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          );
                        }
                        
                        final allQueues = snapshot.hasData ? snapshot.data! : <Queue>[];
                        final currentAdmin = AdminService.currentAdmin;
                        
                        List<Queue> filteredQueues;
                        if (currentAdmin != null && currentAdmin.isSuperAdmin) {
                          filteredQueues = _selectedDistributionArea != null
                              ? allQueues.where((q) => q.distributionArea == _selectedDistributionArea).toList()
                              : allQueues;
                        } else {
                          final adminAreas = _distributionAreas.map((area) => area.id).toList();
                          filteredQueues = allQueues.where((q) => adminAreas.contains(q.distributionArea)).toList();
                          if (_selectedDistributionArea != null) {
                            filteredQueues = filteredQueues.where((q) => q.distributionArea == _selectedDistributionArea).toList();
                          }
                        }
                        
                        // Sort by fromDate descending (newest first)
                        filteredQueues.sort((a, b) => b.fromDate.compareTo(a.fromDate));
                        
                        if (filteredQueues.isEmpty) {
                          return Center(
                            child: Padding(
                              padding: const EdgeInsets.all(32.0),
                              child: Column(
                                mainAxisAlignment: MainAxisAlignment.center,
                                children: [
                                  Icon(
                                    Icons.queue_outlined,
                                    size: 64,
                                    color: Colors.grey[400],
                                  ),
                                  const SizedBox(height: 16),
                                  Text(
                                    'No queues found',
                                    style: TextStyle(
                                      fontSize: 18,
                                      fontWeight: FontWeight.w500,
                                      color: Colors.grey[700],
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          );
                        }
                        
                        return ListView.builder(
                          itemCount: filteredQueues.length,
                          padding: const EdgeInsets.only(bottom: 16),
                          cacheExtent: 500,
                          itemBuilder: (context, index) {
                            final queue = filteredQueues[index];
                            if (queue.isMultiDay) {
                              return _buildMultiDayQueueAccordion(queue, index);
                            } else {
                              return _buildQueueRow(queue, index);
                            }
                          },
                        );
                      },
                    ),
                  ),
                ],
              );
            },
          ),
        ),
      ),
    );
  }

  Widget _buildQueueRow(Queue queue, int index) {
    const tealGreen = Color(0xFF81CF01);
    
    // Don't load beneficiaries here - load them on-demand when user clicks View
    return Container(
      margin: EdgeInsets.only(bottom: 12, left: 16, right: 16, top: index > 0 ? 12 : 0),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: tealGreen.withOpacity(0.3),
          width: 2,
        ),
        boxShadow: [
          BoxShadow(
            color: tealGreen.withOpacity(0.2),
            spreadRadius: 2,
            blurRadius: 8,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      queue.name,
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                        color: Color(0xFF1A237E),
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      '${queue.displayDateRange} • ${queue.displayTimeRange}',
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.grey[600],
                      ),
                    ),
                    Text(
                      '${queue.numberOfAvailableUnits} ${queue.unitName}',
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.grey[600],
                      ),
                    ),
                  ],
                ),
              ),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: _getStatusColor(queue.status).withOpacity(0.2),
                  borderRadius: BorderRadius.circular(4),
                ),
                child: Text(
                  queue.status,
                  style: TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                    color: _getStatusColor(queue.status),
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: [
              _buildActionButton(
                icon: Icons.visibility,
                label: AppLanguage.translate('View'),
                color: tealGreen,
                onPressed: () async {
                  // Load beneficiaries on-demand when user clicks View
                  try {
                    final beneficiariesForQueue = await BeneficiaryService.getBeneficiariesByQueueName(queue.name).first;
                    if (mounted) {
                      Navigator.of(context).push(
                        MaterialPageRoute(
                          builder: (context) => QueueViewScreen(
                            queue: queue,
                            beneficiaries: beneficiariesForQueue,
                            onQueueUpdated: (updatedQueue) {},
                            onBeneficiaryUpdated: (beneficiary) {},
                          ),
                        ),
                      );
                    }
                  } catch (e) {
                    if (mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text('Error loading queue: $e'),
                          backgroundColor: Colors.red,
                        ),
                      );
                    }
                  }
                },
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildMultiDayQueueAccordion(Queue queue, int displayIndex) {
    final queueKey = queue.name;
    final isQueueExpanded = _multiDayQueueExpanded[queueKey] ?? false;
    final dailyEntries = _generateDailyEntries(queue);
    
    // Don't load beneficiaries here - load them on-demand when user clicks View
    return Container(
          margin: EdgeInsets.only(bottom: 12, left: 16, right: 16, top: displayIndex > 0 ? 12 : 0),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(
              color: Colors.blue.withOpacity(0.3),
              width: 2,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.blue.withOpacity(0.2),
                spreadRadius: 2,
                blurRadius: 8,
                offset: const Offset(0, 4),
              ),
            ],
          ),
          child: ExpansionTile(
            initiallyExpanded: isQueueExpanded,
            onExpansionChanged: (expanded) {
              setState(() {
                _multiDayQueueExpanded[queueKey] = expanded;
              });
            },
            tilePadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            childrenPadding: const EdgeInsets.only(bottom: 8),
            leading: Icon(
              Icons.calendar_today,
              color: Colors.blue.shade700,
            ),
            title: Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          Flexible(
                            child: Text(
                              queue.name,
                              style: const TextStyle(
                                fontSize: 18,
                                fontWeight: FontWeight.bold,
                                color: Color(0xFF1A237E),
                              ),
                              overflow: TextOverflow.ellipsis,
                              maxLines: 1,
                            ),
                          ),
                          const SizedBox(width: 8),
                          Container(
                            padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                            decoration: BoxDecoration(
                              color: Colors.blue.shade100,
                              borderRadius: BorderRadius.circular(4),
                            ),
                            child: Text(
                              'Multi Day',
                              style: TextStyle(
                                fontSize: 10,
                                fontWeight: FontWeight.bold,
                                color: Colors.blue.shade900,
                              ),
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 4),
                      Text(
                        '${queue.displayDateRange} • ${queue.displayTimeRange}',
                        style: TextStyle(
                          fontSize: 12,
                          color: Colors.grey[600],
                        ),
                      ),
                      Text(
                        '${dailyEntries.length} days • ${queue.numberOfAvailableUnits} ${queue.unitName}',
                        style: TextStyle(
                          fontSize: 12,
                          color: Colors.grey[600],
                        ),
                      ),
                    ],
                  ),
                ),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: _getStatusColor(queue.status).withOpacity(0.2),
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: Text(
                    queue.status,
                    style: TextStyle(
                      fontSize: 12,
                      fontWeight: FontWeight.bold,
                      color: _getStatusColor(queue.status),
                    ),
                  ),
                ),
              ],
            ),
            children: dailyEntries.map((entry) {
              final dayKey = '${queueKey}_${entry['date']}';
              final isDayExpanded = _dailyEntryExpanded[queueKey]?.contains(dayKey) ?? false;
              final day = entry['date'] as DateTime;
              final dayQueueName = entry['dayQueueName'] as String;
              
              return ExpansionTile(
                initiallyExpanded: isDayExpanded,
                onExpansionChanged: (expanded) {
                  setState(() {
                    _dailyEntryExpanded.putIfAbsent(queueKey, () => <String>{}).clear();
                    if (expanded) {
                      _dailyEntryExpanded[queueKey]!.add(dayKey);
                    }
                  });
                },
                tilePadding: const EdgeInsets.symmetric(horizontal: 24, vertical: 4),
                leading: Icon(Icons.event, size: 20, color: Colors.blue.shade600),
                title: Text(
                  '${day.day}/${day.month}/${day.year}',
                  style: const TextStyle(fontSize: 14, fontWeight: FontWeight.w600),
                ),
                trailing: IconButton(
                  icon: const Icon(Icons.visibility, size: 20),
                  color: const Color(0xFF81CF01),
                  onPressed: () async {
                    // Load beneficiaries on-demand when user clicks View
                    try {
                      final allAreaBeneficiaries = await BeneficiaryService.getBeneficiariesByArea(queue.distributionArea, limit: 1000, activeOnly: true).first;
                      final dayBeneficiaries = allAreaBeneficiaries.where((b) {
                        return b.initialAssignedQueuePoint == dayQueueName;
                      }).toList();
                      
                      if (mounted) {
                        final dayQueue = queue.copyWith(
                          fromDate: DateTime(day.year, day.month, day.day),
                          toDate: DateTime(day.year, day.month, day.day),
                        );
                        Navigator.of(context).push(
                          MaterialPageRoute(
                            builder: (context) => QueueViewScreen(
                              queue: dayQueue,
                              beneficiaries: dayBeneficiaries,
                              onQueueUpdated: (updatedQueue) {},
                              onBeneficiaryUpdated: (beneficiary) {},
                            ),
                          ),
                        );
                      }
                    } catch (e) {
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                            content: Text('Error loading queue: $e'),
                            backgroundColor: Colors.red,
                          ),
                        );
                      }
                    }
                  },
                ),
                children: [],
              );
            }).toList(),
          ),
        );
  }

  List<Map<String, dynamic>> _generateDailyEntries(Queue queue) {
    final entries = <Map<String, dynamic>>[];
    final currentDate = queue.fromDate;
    final endDate = queue.toDate;
    var date = DateTime(currentDate.year, currentDate.month, currentDate.day);
    final end = DateTime(endDate.year, endDate.month, endDate.day);
    
    while (date.isBefore(end) || date.isAtSameMomentAs(end)) {
      final dayQueueName = '${queue.name}_${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
      entries.add({
        'date': date,
        'dayQueueName': dayQueueName,
      });
      date = date.add(const Duration(days: 1));
    }
    
    return entries;
  }

  Widget _buildActionButton({
    required IconData icon,
    required String label,
    required Color color,
    required VoidCallback onPressed,
  }) {
    return ElevatedButton.icon(
      onPressed: onPressed,
      icon: Icon(icon, size: 18),
      label: Text(label),
      style: ElevatedButton.styleFrom(
        backgroundColor: color,
        foregroundColor: Colors.white,
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      ),
    );
  }

  Color _getStatusColor(String status) {
    switch (status.toLowerCase()) {
      case 'active':
        return Colors.green;
      case 'suspended':
        return Colors.orange;
      case 'completed':
        return Colors.blue;
      default:
        return Colors.grey;
    }
  }
}

